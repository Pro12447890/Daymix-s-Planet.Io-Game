<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Daymix‚Äôs Planet.Io v2.7 Fixed & AI+</title>
<style>
@font-face { font-family: 'Comic Sans MS'; src: local('Comic Sans MS'); }
:root { --joy-size: 150px; --joy-x: 50px; --joy-y: 50px; --aim-size: 180px; --aim-x: 60px; --aim-y: 60px; --primary-glow: #00BFFF; --bg-dark: #050a10; }
body { margin: 0; overflow: hidden; background: #050510; font-family: 'Segoe UI', 'Comic Sans MS', sans-serif; color: white; user-select: none; touch-action: none; -webkit-tap-highlight-color: transparent; }
canvas { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; }
#ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
.interactive { pointer-events: auto; }

/* TOP HUD */
.top-hud { position: absolute; top: max(10px, 1vmin); left: max(10px, 1vmin); right: max(10px, 1vmin); display: flex; justify-content: space-between; align-items: flex-start; z-index: 5; }
.profile-badge { background: rgba(0,0,0,0.6); border: 2px solid #fff; border-radius: 15px; padding: 0.5em 1em; display: flex; align-items: center; gap: 10px; font-size: max(16px, 2vmin); width: fit-content; pointer-events: auto; }

/* Exit Button - Default PC Position */
.exit-btn { position: absolute; top: 10px; left: 25%; transform: translateX(-50%); background: rgba(255, 0, 0, 0.6); border: 2px solid #ff4444; color: white; padding: 8px 15px; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 16px; pointer-events: auto; transition: 0.2s; z-index: 20; }
.exit-btn:hover { background: rgba(255, 0, 0, 0.9); box-shadow: 0 0 10px red; }
/* Mobile Override Class for Pause Btn */
body.mobile-layout .exit-btn { left: auto; right: 10px; top: 10px; transform: none; padding: 5px 10px; font-size: 14px; z-index: 25; }

.fps-badge { position: absolute; top: 60px; left: 20px; background: rgba(0,0,0,0.6); border: 2px solid #555; border-radius: 10px; padding: 0.2em 0.8em; font-weight: bold; font-family: monospace; font-size: 14px; width: fit-content; text-shadow: 1px 1px 0 #000; pointer-events: none; }
.fps-badge.right-side { left: auto; right: 120px; top: 10px; }

.lb-wrapper { position: absolute; right: 0; top: 60px; display: flex; flex-direction: column; align-items: flex-end; pointer-events: auto; }
.lb-header { background: rgba(0,0,0,0.8); padding: 5px 10px; border: 2px solid var(--primary-glow); border-bottom: none; border-radius: 10px 10px 0 0; font-size: 12px; cursor: pointer; color: var(--primary-glow); font-weight: bold; width: 100px; text-align: center; }
.leaderboard { text-align: right; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 10px 0 10px 10px; border-right: 4px solid var(--primary-glow); transition: height 0.3s; overflow: hidden; min-width: 150px; }
.lb-row { font-size: max(12px, 1.5vmin); margin-bottom: 4px; white-space: nowrap; }
.lb-collapsed .leaderboard { display: none; }
.lb-collapsed .lb-header { border-bottom: 2px solid var(--primary-glow); border-radius: 10px; }

.boss-timer-container { position: absolute; top: 50px; left: 50%; transform: translateX(-50%); background: rgba(50, 0, 0, 0.7); border: 2px solid #ff4500; padding: 5px 15px; border-radius: 20px; text-align: center; box-shadow: 0 0 15px #ff4500; display: none; min-width: 140px; }
.boss-label { font-size: 12px; color: #ffaeae; text-transform: uppercase; font-weight: bold; }
.boss-time-val { font-size: 24px; font-weight: bold; color: #fff; font-family: monospace; }
.boss-wave-timer { font-size: 14px; color: #ffff00; margin-top: 2px; font-family: monospace; }

/* INVENTORY & TOGGLE */
.inv-toggle-btn { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); width: 60px; height: 60px; border-radius: 12px; background: rgba(0,0,0,0.6); border: 2px solid #fff; font-size: 30px; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: 0.2s; box-shadow: 0 0 10px #000; z-index: 12; }
.inventory-hud { display: none; position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); flex-direction: column; gap: 5px; align-items: center; z-index: 12; background: rgba(0,10,20,0.95); border: 2px solid #444; border-radius: 15px; padding: 10px 20px; min-width: 200px; box-shadow: 0 0 20px rgba(0,0,0,0.8); }
.inv-title { font-size: 12px; color: gold; font-weight: bold; margin-bottom: 5px; }
.inv-slots-row { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
.inv-slot-box { width: 50px; height: 50px; background: #222; border: 2px solid #555; border-radius: 10px; position: relative; display: flex; justify-content: center; align-items: center; font-size: 24px; cursor: pointer; transition: 0.2s; overflow: hidden; }
.inv-slot-box.active { border-color: #00BFFF; box-shadow: 0 0 10px #00BFFF; background: #333; }
.inv-count-badge { position: absolute; bottom: -8px; right: -8px; background: #333; border: 1px solid #777; color: #fff; font-size: 10px; padding: 2px 5px; border-radius: 4px; z-index: 2; }
.inv-timer-overlay { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(0, 255, 255, 0.3); transition: height 0.1s linear; pointer-events: none; }

/* ABILITIES (Right Side) */
.ability-btn-group { position: absolute; right: 20px; top: 50%; transform: translateY(-50%); display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: center; z-index: 15; pointer-events: none; direction: rtl; transition: transform 0.3s; }
.ability-btn-group.hidden-mobile { transform: translateX(150%); } 
.ab-btn { width: 50px; height: 50px; border-radius: 50%; border: 3px solid #fff; display: flex; justify-content: center; align-items: center; font-size: 22px; cursor: pointer; pointer-events: auto; position: relative; background: #333; box-shadow: 0 0 10px #000; transition: transform 0.1s; direction: ltr; }
.ab-btn:active { transform: scale(0.95); }
.ab-btn.cd { filter: grayscale(1); opacity: 0.5; cursor: default; }
.ab-btn.active-mode { border-color: #ff0; box-shadow: 0 0 15px #ff0; animation: pulseGlow 1s infinite; }
.ab-btn.blue-active-mode { border-color: #00BFFF; box-shadow: 0 0 20px #00BFFF; animation: pulseBlue 0.5s infinite alternate; background: #002244; }

@keyframes pulseGlow { 0% { box-shadow: 0 0 15px #ff0; } 50% { box-shadow: 0 0 25px #ff0; border-color: #fff; } 100% { box-shadow: 0 0 15px #ff0; } }
@keyframes pulseBlue { 0% { box-shadow: 0 0 15px #00BFFF; } 100% { box-shadow: 0 0 30px #00BFFF; border-color: #fff; } }

.ab-cd-text { position: absolute; font-weight: bold; color: #fff; font-size: 14px; text-shadow: 1px 1px 0 #000; }
.ab-stock { position: absolute; bottom: -5px; right: -5px; background: red; color: white; border-radius: 50%; width: 18px; height: 18px; font-size: 10px; display: flex; justify-content: center; align-items: center; border: 1px solid #fff; }

.mob-wep-toggle { display: none; position: absolute; top: 100px; right: 10px; width: 45px; height: 45px; background: rgba(0,0,0,0.6); border: 2px solid gold; border-radius: 10px; color: gold; font-size: 24px; justify-content: center; align-items: center; pointer-events: auto; z-index: 16; cursor: pointer; }

.ammo-display { position: absolute; bottom: 140px; right: 50%; transform: translateX(50%); display: flex; gap: 5px; pointer-events: none; align-items: flex-end; }
.ammo-dot { width: 12px; height: 12px; border-radius: 50%; background: #555; border: 1px solid #fff; }
.ammo-dot.active { background: #0ff; box-shadow: 0 0 5px #0ff; }
.reload-timer-text { position: absolute; top: -25px; width: 100%; text-align: center; color: #0ff; font-weight: bold; font-family: monospace; font-size: 14px; text-shadow: 1px 1px 0 #000; display: none; }

.joystick-area { position: absolute; width: var(--joy-size); height: var(--joy-size); background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; pointer-events: auto; display: none; z-index: 16; }
.joystick-knob { position: absolute; top: 50%; left: 50%; width: 40%; height: 40%; background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px #000; transition: background 0.2s; }
.joystick-knob.auto-aim { background: #FF8C00; box-shadow: 0 0 15px #FF8C00; }
#joystick { bottom: var(--joy-y); left: var(--joy-x); }
#aimJoystick { width: var(--aim-size); height: var(--aim-size); bottom: var(--aim-y); right: var(--aim-x); border-color: rgba(100, 200, 255, 0.4); display: none; }
#aimJoystick .joystick-knob { background: rgba(100, 200, 255, 0.8); }

#mobile-controls { display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; pointer-events: none; }
/* New Mobile Use Item Button (Replaces Spin) */
.mobile-action-btn { position: absolute; bottom: 80px; right: 40px; width: 60px; height: 60px; background: rgba(74, 144, 226, 0.5); border: 4px solid #fff; border-radius: 50%; pointer-events: auto; display: flex; justify-content: center; align-items: center; font-size: 24px; transition: transform 0.5s; z-index: 16; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
.mob-count { position: absolute; top: -5px; right: -5px; background: red; width: 20px; height: 20px; border-radius: 50%; font-size: 12px; display: none; justify-content: center; align-items: center; border: 1px solid #fff; }
.mobile-action-btn.boost-btn { bottom: 30px; right: 130px; width: 50px; height: 50px; background: rgba(255, 69, 0, 0.5); border-color: #ff4500; font-size: 20px; }
.mobile-action-btn.boost-btn:active { background: rgba(255, 69, 0, 0.9); transform: scale(0.9); }

/* Spin overlay used on PC now mostly */
.spin-cards { display: flex; gap: 10px; }
.spin-card { background: #333; padding: 10px; border-radius: 10px; border: 2px solid #fff; cursor: pointer; text-align: center; }
#spin-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 50; justify-content: center; align-items: center; }

.minimap-container { position: absolute; bottom: 20px; right: 20px; width: 15vmin; height: 15vmin; min-width: 100px; min-height: 100px; background: rgba(0, 10, 30, 0.8); border: 2px solid var(--primary-glow); border-radius: 15px; overflow: hidden; z-index: 15; }
#minimapCanvas { width: 100%; height: 100%; }

/* Language Button */
.lang-btn {
    position: relative;
    border: 2px solid #00FFFF;
    border-radius: 20px;
    background: transparent;
    color: #00FFFF;
    padding: 8px 16px 8px 30px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    text-transform: uppercase;
    margin-top: 15px;
    display: flex;
    align-items: center;
    box-shadow: 0 0 10px rgba(0,255,255,0.3);
    transition: 0.2s;
}
.lang-btn:hover { box-shadow: 0 0 15px rgba(0,255,255,0.6); background: rgba(0,255,255,0.1); }
.lang-btn::before {
    content: '';
    position: absolute;
    left: 10px;
    width: 12px;
    height: 12px;
    background: #A020F0; /* Purple dot */
    border-radius: 50%;
}

@media (max-width: 900px) {
    .ab-btn { width: 45px; height: 45px; font-size: 20px; }
    .inv-toggle-btn { display: none; }
    .inventory-hud { display: none; }
    .fps-badge { font-size: 12px; }
    .ammo-display { bottom: auto; top: 150px; right: 20px; transform: none; flex-direction: column; }
    .mobile-action-btn { width: 50px; height: 50px; font-size: 20px; bottom: 60px; right: 30px; } /* Updated */
    .mob-wep-toggle { display: flex; }
    /* Shift weapons down on mobile */
    .ability-btn-group { top: 60%; transform: translateY(-50%); } 
    
    .mode-cards { 
        display: grid; 
        grid-template-columns: 1fr 1fr; 
        width: 95%; 
        justify-items: center; 
        gap: 15px;
        padding-bottom: 40px; /* Space for scrolling */
    }
    #modeScreen, #difficultyScreen { 
        justify-content: flex-start; 
        padding-top: 50px; 
        overflow-y: auto; 
    }
}

/* MENUS - FIXED CENTERING */
.menu-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-dark); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; overflow-y: auto; box-sizing: border-box; }
.game-title { font-size: min(8vw, 60px); font-weight: bold; color: #3fa9f5; text-shadow: 0 0 20px rgba(63, 169, 245, 0.6); margin-bottom: 2vh; text-align: center; flex-shrink: 0; }
.name-input-container { display: flex; align-items: center; gap: 10px; margin-bottom: 2vh; position: relative; flex-shrink: 0; }
.name-input { background: transparent; border: none; border-bottom: 2px solid #fff; color: #fff; font-size: 24px; text-align: center; width: 200px; padding: 5px; outline: none; font-family: inherit; font-weight: bold; }
.gear-btn { font-size: 28px; cursor: pointer; transition: transform 0.3s; }
.gear-btn:hover { transform: rotate(90deg); color: var(--primary-glow); }
.color-picker-pop { position: absolute; top: 100%; left: 50%; transform: translateX(-50%); background: #222; border: 1px solid #555; padding: 10px; border-radius: 8px; display: none; gap: 5px; z-index: 20; width: 160px; flex-wrap: wrap; justify-content: center; }
.color-opt { width: 24px; height: 24px; border-radius: 50%; cursor: pointer; border: 2px solid #000; }
.menu-buttons { display: flex; flex-direction: column; gap: 2vh; width: min(300px, 80vw); padding-bottom: 40px; }
.neon-btn { background: rgba(255,255,255,0.05); border: 2px solid #fff; color: #fff; padding: 15px; font-size: 20px; font-weight: bold; cursor: pointer; text-transform: uppercase; position: relative; overflow: hidden; transition: 0.2s; border-radius: 8px; flex-shrink: 0; }
.neon-btn:hover { border-color: var(--primary-glow); color: var(--primary-glow); box-shadow: 0 0 15px var(--primary-glow); }
.neon-btn:active { transform: scale(0.95); }
.free-coins-btn { border-color: gold; color: gold; font-size: 14px; padding: 10px; margin-top: 10px; }
.ripple { position: absolute; border-radius: 50%; transform: scale(0); animation: rippleAnim 0.6s linear; background: rgba(255, 255, 255, 0.3); pointer-events: none; }
@keyframes rippleAnim { to { transform: scale(4); opacity: 0; } }
#hudEditorScreen { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 200; }
.hud-editor-overlay { position: absolute; width: 100%; height: 100%; }
.hud-control { position: absolute; border: 2px dashed #0f0; background: rgba(0, 255, 0, 0.2); border-radius: 50%; touch-action: none; cursor: grab; display: flex; justify-content: center; align-items: center; color: #fff; font-weight: bold; }
.hud-options { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; background: #111; padding: 10px; border-radius: 10px; border: 1px solid #555; }
/* Shop Styles */
#shopScreen { justify-content: flex-start; padding-top: 20px; box-sizing: border-box; }
.shop-header { width: 90%; max-width: 1000px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-shrink: 0; }
.money-display { font-size: 24px; border: 2px solid #fff; padding: 8px 20px; border-radius: 10px; background: rgba(0,0,0,0.3); display: flex; align-items: center; gap: 10px; }
.close-btn { width: 40px; height: 40px; display: flex; justify-content: center; align-items: center; font-size: 24px; border: 2px solid #fff; border-radius: 8px; cursor: pointer; }
.shop-tabs { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center; flex-shrink: 0; }
.tab-btn { background: transparent; border: 2px solid #555; color: #888; padding: 8px 16px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: 0.2s; }
.tab-btn.active { border-color: var(--primary-glow); color: #fff; box-shadow: 0 0 10px var(--primary-glow); background: rgba(0, 191, 255, 0.1); }
.shop-content-area { width: 100%; flex: 1; display: flex; flex-direction: column; align-items: center; position: relative; overflow-y: auto; max-height: 500px; }
.shop-row-container { display: flex; align-items: center; width: 100%; justify-content: center; }
.cards-scroll-area { display: flex; gap: 30px; overflow-x: auto; padding: 20px; scroll-behavior: smooth; align-items: center; scrollbar-width: none; width: 80%; }
.shop-card { flex: 0 0 220px; height: 340px; background: linear-gradient(135deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0.01) 100%); border: 2px solid #555; border-radius: 20px; display: flex; flex-direction: column; align-items: center; padding: 15px; transition: all 0.3s; position: relative; box-sizing: border-box; }
.shop-card.selected { border-color: var(--primary-glow); box-shadow: 0 0 20px var(--primary-glow); background: rgba(0,191,255,0.05); }
.card-img-box { width: 100px; height: 100px; margin: 20px 0; display: flex; justify-content: center; align-items: center; }
.card-planet-preview { width: 80px; height: 80px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.2); }
.card-upgrade-icon { font-size: 50px; }
.card-title { font-size: 18px; font-weight: bold; margin-bottom: 5px; text-align: center; }
.card-desc { font-size: 12px; color: #aaa; text-align: center; margin-bottom: auto; line-height: 1.2; }
.card-btn { width: 100%; padding: 10px; margin-top: 10px; background: transparent; border: 2px solid #fff; color: #fff; font-weight: bold; cursor: pointer; border-radius: 8px; transition: 0.2s; }
.card-btn.buy { border-color: gold; color: gold; }
.shop-footer-desc { position: absolute; bottom: 0; left: 0; width: 100%; text-align: center; color: #ccc; font-size: 14px; background: rgba(0,0,0,0.8); padding: 15px 0; height: auto; min-height: 40px; border-top: 1px solid #333; z-index: 10; }

#modeScreen, #difficultyScreen, #modifierScreen { display: none; }
.mode-cards { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; flex-shrink: 0; margin-bottom: 20px; }
.mode-card, .diff-card { width: 140px; height: 140px; background: rgba(255,255,255,0.05); border: 2px solid #555; border-radius: 15px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: 0.2s; flex-shrink: 0; }
.mode-card:hover, .diff-card:hover { border-color: var(--primary-glow); box-shadow: 0 0 20px var(--primary-glow); transform: scale(1.05); }
.mode-icon { font-size: 40px; margin-bottom: 10px; }
.diff-card { height: 160px; padding: 10px; font-size: 14px; }
.diff-title { font-size: 18px; font-weight: bold; margin-bottom: 10px; }
.diff-desc { font-size: 12px; color: #aaa; text-align: center; }
.arena-section { margin-top: 30px; width: 90%; max-width: 800px; flex-shrink: 0; margin-bottom: 20px; }
.arena-title { text-align: center; font-size: 24px; font-weight: bold; margin-bottom: 15px; color: #fff; letter-spacing: 2px; }
.arena-cards { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
.arena-card { width: 160px; height: 180px; border: 2px solid #555; border-radius: 15px; background: rgba(0,0,0,0.3); display: flex; flex-direction: column; align-items: center; padding: 10px; cursor: pointer; transition: 0.2s; flex-shrink: 0; }
.arena-card:hover { border-color: #ff4500; box-shadow: 0 0 15px #ff4500; transform: translateY(-5px); }
.arena-card-title { color: #fff; font-weight: bold; font-size: 16px; margin-bottom: 10px; text-align: center; }
.arena-card-desc { font-size: 12px; color: #aaa; text-align: center; margin-top: auto; margin-bottom: auto; }
.arena-card.selected-arena { box-shadow: 0 0 25px currentColor; background: rgba(255,255,255,0.05); border-color: currentColor; }

#arenaEventDisplay { position: absolute; top: 120px; width: 100%; text-align: center; color: #ff4500; font-weight: bold; font-size: 18px; text-shadow: 1px 1px 0 #000; z-index: 5; display: none; }
#notif-area { position: absolute; top: 20%; width: 100%; text-align: center; pointer-events: none; z-index: 100; }
.notif-msg { font-size: 24px; color: gold; text-shadow: 2px 2px 0 #000; animation: fadeUp 1.5s forwards; }
@keyframes fadeUp { 0% { opacity:1; transform:translateY(0); } 100% { opacity:0; transform:translateY(-50px); } }

#gameOverScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: transparent; z-index: 200; display: none; flex-direction: column; align-items: center; justify-content: center; opacity: 0; transition: opacity 2s, background-color 2s; pointer-events: none; }
#gameOverScreen.active { background: rgba(0, 0, 0, 0.95); opacity: 1; pointer-events: auto; }
#frozenHud { position: absolute; top: 25%; left: 50%; transform: translateX(-50%); background: rgba(0, 191, 255, 0.4); border: 2px solid #00BFFF; padding: 10px 20px; border-radius: 10px; display: none; flex-direction: column; align-items: center; pointer-events: none; }
.frozen-text { color: #fff; font-weight: bold; font-size: 20px; text-shadow: 0 0 10px #00BFFF; }
.frozen-timer { font-size: 30px; font-family: monospace; }
#bossArrow { position: absolute; width: 40px; height: 40px; pointer-events: none; display: none; z-index: 10; transform-origin: center; }
#bossArrow::after { content: '‚û§'; font-size: 40px; color: red; text-shadow: 0 0 10px yellow; position: absolute; top: -20px; left: -10px; transform: rotate(0deg); }
#pauseMenu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 150; display: none; flex-direction: column; justify-content: center; align-items: center; }
.mod-container { width: 90%; max-width: 600px; display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; flex-shrink: 0; }
.mod-row { display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; }
.mod-slider { width: 50%; }
#modeToggles { position: relative; width:90%; max-width:600px; margin-bottom:20px; display: flex; flex-direction: column; gap: 10px; align-items: flex-start; flex-shrink: 0; }
.mode-toggle-row { display: flex; align-items: center; gap: 10px; font-size: 14px; color: #aaa; cursor: pointer; }
.mode-checkbox { width: 20px; height: 20px; border: 2px solid #fff; display: flex; justify-content: center; align-items: center; }
.mode-checkbox.checked::after { content: '‚úì'; color: var(--primary-glow); font-weight: bold; }
#lightStripText { position: absolute; top: 80px; width: 100%; text-align: center; color: gold; font-weight: bold; font-size: 20px; text-shadow: 2px 2px 0 #000; display: none; z-index: 5; }
#lightStripTimerVal { display: block; font-size: 24px; color: #fff; margin-top: 5px; font-family: monospace; }
#blueStripText { position: absolute; top: 130px; width: 100%; text-align: center; color: #00BFFF; font-weight: bold; font-size: 20px; text-shadow: 0 0 10px #00BFFF; display: none; z-index: 5; }
#blueStripTimerVal { display: block; font-size: 24px; color: #fff; margin-top: 5px; font-family: monospace; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui-layer" style="display: none;">
    <div class="top-hud interactive">
        <div class="hud-left-group">
            <div class="profile-badge">
                <span style="font-size:20px;">ü™ô</span><span id="coinsVal">0</span>
                <span style="margin-left: 10px; font-size: 14px; color: #aaa;">Score: <span id="scoreVal" style="color:white">0</span></span>
            </div>
        </div>
        
        <button class="exit-btn" onclick="ui.pauseGame()" data-lang-key="pause">–ü–ê–£–ó–ê</button>
        <div class="fps-badge" id="fpsCounter">60 FPS</div>
        
        <div class="boss-timer-container" id="bossHud">
            <div class="boss-label" id="bossLabel">BOSS IN</div>
            <div class="boss-time-val" id="bossTimerDisplay">00:00</div>
            <div class="boss-wave-timer" id="bossWaveDisplay"></div>
        </div>
        
        <div class="lb-wrapper" id="lbWrapper">
            <div class="lb-header" onclick="ui.toggleLb()">TOP 10 ‚ñº</div>
            <div class="leaderboard" id="lb-body">
                <div id="lb-content"></div>
            </div>
        </div>
    </div>
    
    <div id="lightStripText" data-lang-key="rayAttack">–†–ï–ñ–ò–ú –õ–£–ß–ï–í–û–ô –ê–¢–ê–ö–ò<div id="lightStripTimerVal">0.0</div></div>
    <div id="blueStripText" data-lang-key="blueAttack">–†–ï–ñ–ò–ú –ì–û–õ–£–ë–û–ô –ê–¢–ê–ö–ò<div id="blueStripTimerVal">0.0</div></div>
    <div id="arenaEventDisplay"></div>
    <div id="survivalTimer" style="display:none; position:absolute; top:80px; left:50%; transform:translateX(-50%); font-weight:bold; color:yellow; font-size:20px; text-shadow:1px 1px 0 #000;"></div>

    <!-- Inventory Toggle & HUD -->
    <div class="inv-toggle-btn interactive" id="invToggle" onclick="ui.toggleInventory()">üéí</div>
    <div class="inventory-hud interactive" id="pc-inventory">
        <div class="inv-title" data-lang-key="items">–ü–†–ï–î–ú–ï–¢–´</div>
        <div class="inv-slots-row" id="pcInvSlots">
            <div class="inv-slot-box" id="slot_speed" onclick="ui.manualUse('speed')">‚ö°<div class="inv-count-badge" id="cnt_speed">0</div><div class="inv-timer-overlay" id="time_speed"></div></div>
            <div class="inv-slot-box" id="slot_magnet" onclick="ui.manualUse('magnet')">üß≤<div class="inv-count-badge" id="cnt_magnet">0</div><div class="inv-timer-overlay" id="time_magnet"></div></div>
            <div class="inv-slot-box" id="slot_grow" onclick="ui.manualUse('grow')">üí™<div class="inv-count-badge" id="cnt_grow">0</div><div class="inv-timer-overlay" id="time_grow"></div></div>
            <div class="inv-slot-box" id="slot_bonus" onclick="ui.manualUse('bonus')">‚≠ê<div class="inv-count-badge" id="cnt_bonus">0</div><div class="inv-timer-overlay" id="time_bonus"></div></div>
        </div>
    </div>

    <!-- Right-side Vertical Abilities (2 Columns) -->
    <div class="mob-wep-toggle interactive" onclick="ui.toggleMobileAbilities()">‚öîÔ∏è</div>
    <div class="ability-btn-group" id="abilityGroup">
        <!-- Column 1 (Right) -->
        <div class="ab-btn interactive" id="btnShield" style="background:#05a; border-color:#59f;" onclick="game.useShield()">üõ°Ô∏è<div id="cdShield" class="ab-cd-text"></div></div>
        <div class="ab-btn interactive" id="btnWave" style="background:#d32;" onclick="game.useWave()">üí•<div id="cdWave" class="ab-cd-text"></div></div>
        <div class="ab-btn interactive" id="btnGreat" style="background:#8A2BE2;" onclick="game.useGreatImpact()">üéá<div id="cdGreat" class="ab-cd-text"></div></div>
        <div class="ab-btn interactive" id="btnRay" style="background:#FFA500;" onclick="game.useRay()">‚ö°<div id="cdRay" class="ab-cd-text"></div></div>
        <div class="ab-btn interactive" id="btnGrav" style="background:#40E0D0; border-color:#8A2BE2;" onclick="game.useGravityManeuver()">üåå<div id="cdGrav" class="ab-cd-text"></div></div>
        
        <!-- Column 2 (Left) -->
        <div class="ab-btn interactive" id="btnMoon" style="background:#888;" onclick="game.useMoon()">üåô<div id="cdMoon" class="ab-cd-text"></div></div>
        <div class="ab-btn interactive" id="btnIceSword" style="background:#0ff; border-color:#fff;" onclick="game.useIceSword()">üó°Ô∏è<div id="cdIceSword" class="ab-cd-text"></div></div>
        <div class="ab-btn interactive" id="btnBlueBullet" style="background:#00BFFF;" onclick="game.useBlueBullet()">‚ùÑÔ∏è<div id="cdBlueBullet" class="ab-cd-text"></div></div>
        <div class="ab-btn interactive" id="btnVampire" style="background:#800000; border-color:#f00;" onclick="game.useVampire()">ü©∏<div class="ab-stock" id="stockVampire">5</div></div>
        <div class="ab-btn interactive" id="btnStrip" style="background:#333; border-color:#ff0;" onclick="game.toggleLightStrip()">üî´</div>
        <div class="ab-btn interactive" id="btnBlueStrip" style="background:#001133; border-color:#00BFFF;" onclick="game.toggleBlueStrip()">üíé</div>
    </div>

    <div class="ammo-display" id="ammoHud">
        <div id="reloadTimerDisplay" class="reload-timer-text">0.0</div>
        <div class="ammo-dot" id="ammo1"></div>
        <div class="ammo-dot" id="ammo2"></div>
        <div class="ammo-dot" id="ammo3"></div>
        <div class="ammo-dot" id="ammo4" style="display:none"></div>
        <div class="ammo-dot" id="ammo5" style="display:none"></div>
        <div class="ammo-dot" id="ammo6" style="display:none"></div>
        <div class="ammo-dot" id="ammo7" style="display:none"></div>
    </div>
    <div class="joystick-area" id="aimJoystick"><div class="joystick-knob" id="aimKnob"></div></div>
    <div id="mobile-controls">
        <div class="joystick-area" id="joystick"><div class="joystick-knob" id="knob"></div></div>
        <div class="mobile-action-btn boost-btn" id="mobBoostBtn" ontouchstart="game.setSprinting(true)" ontouchend="game.setSprinting(false)">üí®</div>
        <!-- Replaced Spin Button with Item Use Button -->
        <div class="mobile-action-btn" id="mobItemBtn" onclick="game.handleMobileBtn()">
            <span id="mobileItemIcon">üéí</span>
            <div id="mobSlotCount" class="mob-count">0</div>
        </div>
    </div>
    <div class="minimap-container interactive"><canvas id="minimapCanvas"></canvas></div>
    <div id="spin-overlay"><div class="spin-cards" id="spinCards"></div></div>
    <div id="frozenHud"><div class="frozen-text" data-lang-key="frozen">‚ùÑÔ∏è –ó–ê–ú–û–†–û–ó–ö–ê ‚ùÑÔ∏è</div><div class="frozen-timer" id="frozenTimerVal">5.0</div></div>
    <div id="bossArrow"></div>
    <div id="pauseMenu" class="interactive">
        <h1 style="color:white; margin-bottom:30px;" data-lang-key="pause">–ü–ê–£–ó–ê</h1>
        <button class="neon-btn" style="width:200px; margin-bottom:20px;" onclick="ui.resumeGame()" data-lang-key="continue">–ü–†–û–î–û–õ–ñ–ò–¢–¨</button>
        <button class="neon-btn" style="width:200px; border-color:red; color:red;" onclick="ui.exitGame()" data-lang-key="menu">–ú–ï–ù–Æ</button>
    </div>
</div>
<!-- ... –û—Å—Ç–∞–ª—å–Ω–æ–π HTML –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ... -->
<div id="gameOverScreen" class="interactive">
    <h1 style="color:red; font-size:60px; text-shadow:0 0 20px #fff; margin-bottom:20px;" data-lang-key="gameOver">–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê</h1>
    <h3 style="color:#fff; margin-bottom:10px;"><span data-lang-key="score">–°—á–µ—Ç</span>: <span id="finalScore">0</span></h3>
    <h3 style="color:gold; margin-bottom:40px;"><span data-lang-key="coins">–ú–æ–Ω–µ—Ç</span>: <span id="finalCoins">0</span></h3>
    <button class="neon-btn" onclick="ui.showMainMenu(); document.getElementById('gameOverScreen').className=''; document.getElementById('gameOverScreen').style.display='none';" data-lang-key="mainMenu">–ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ</button>
</div>
<div id="notif-area"></div>
<div id="hudEditorScreen">
    <div class="hud-editor-overlay">
        <div id="editMoveJoy" class="hud-control" data-lang-key="move">–î–í–ò–ñ–ï–ù–ò–ï</div>
        <div id="editAimJoy" class="hud-control" data-lang-key="aim">–ü–†–ò–¶–ï–õ</div>
    </div>
    <div class="hud-options">
        <div style="color:white"><span data-lang-key="size">–†–∞–∑–º–µ—Ä</span>: <input type="range" min="80" max="300" id="editorSizeSlider"></div>
        <button class="neon-btn" style="padding:5px 15px; font-size:14px;" onclick="ui.saveHudLayout()" data-lang-key="save">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
        <button class="neon-btn" style="padding:5px 15px; font-size:14px; border-color:red;" onclick="ui.toggleHudEditor(false)" data-lang-key="cancel">–û—Ç–º–µ–Ω–∞</button>
    </div>
</div>
<div id="mainMenu" class="menu-screen interactive">
    <div class="game-title" id="titleText">Daymix‚Äôs Planet.Io</div>
    <div class="name-input-container">
        <input type="text" id="playerNameInput" class="name-input" placeholder="Name" maxlength="12" value="Player">
        <div class="gear-btn" onclick="ui.toggleColorPicker()">‚öôÔ∏è</div>
        <div id="colorPicker" class="color-picker-pop">
            <div class="color-opt" style="background:#1E90FF" onclick="ui.setPlayerColor('#1E90FF')"></div>
            <div class="color-opt" style="background:#DC143C" onclick="ui.setPlayerColor('#DC143C')"></div>
            <div class="color-opt" style="background:#32CD32" onclick="ui.setPlayerColor('#32CD32')"></div>
            <div class="color-opt" style="background:#FFD700" onclick="ui.setPlayerColor('#FFD700')"></div>
            <div class="color-opt" style="background:#8A2BE2" onclick="ui.setPlayerColor('#8A2BE2')"></div>
            <div class="color-opt" style="background:#FF4500" onclick="ui.setPlayerColor('#FF4500')"></div>
        </div>
    </div>
    <div class="menu-buttons">
        <button class="neon-btn" onmousedown="ui.ripple(event, () => ui.showModeSelect())" id="btnPlay" data-lang-key="play">–ò–ì–†–ê–¢–¨</button>
        <button class="neon-btn" onmousedown="ui.ripple(event, () => ui.openShop())" id="btnShop" data-lang-key="shop">–ú–ê–ì–ê–ó–ò–ù</button>
        <button class="neon-btn" onmousedown="ui.ripple(event, () => ui.showModifier())" id="btnMod" data-lang-key="modifier">–ú–û–î–ò–§–ò–ö–ê–¢–û–†</button>
        <button class="neon-btn" onmousedown="ui.ripple(event, () => ui.toggleSettings())" id="btnSettings" data-lang-key="settings">–ù–ê–°–¢–†–û–ô–ö–ò</button>
        <button class="neon-btn free-coins-btn" id="btnFreeCoins" onclick="ui.claimFreeCoins()" data-lang-key="freeCoins">–ë–ï–°–ü–õ–ê–¢–ù–´–ï –ú–û–ù–ï–¢–´</button>
    </div>
    <button class="lang-btn" onclick="ui.toggleLanguage()">–†–£–°–°–ö–ò–ô</button>
    <div id="quoteDisplay"></div>
    <div class="version-label" style="position: absolute; bottom: 10px; right: 10px; text-align: right; color: #444; font-size: 12px; font-weight: bold;">Release v2.7<br><span>Fixed & AI+</span></div>
    <div id="settings-panel" style="display:none; position:absolute; background:#111; padding:20px; border:2px solid #555; border-radius:10px; z-index:20;">
        <h3 style="margin-top:0; color:#fff;" data-lang-key="settings">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
        <button class="neon-btn" style="font-size:14px; padding:10px; width:100%; margin-bottom:15px;" onclick="ui.toggleHudEditor(true)" data-lang-key="setupControls">–ù–∞—Å—Ç—Ä–æ–∏—Ç—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</button>
        <div style="margin-top:15px; border-top:1px solid #333; paddingTop:10px;">
            <button class="neon-btn" style="font-size:14px; padding:8px;" onclick="ui.toggleFpsSide()"><span data-lang-key="fpsCounter">–°—á–µ—Ç—á–∏–∫ FPS</span>: <span id="fpsSideBtn">Left</span></button>
        </div>
        <button class="neon-btn" style="margin-top:15px; padding:5px; font-size:14px;" onclick="ui.toggleSettings()" data-lang-key="close">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>
</div>
<div id="modeScreen" class="menu-screen interactive">
    <h2 style="color:#fff; margin-bottom:40px; flex-shrink: 0;" id="modeTitle" data-lang-key="chooseDevice">–í–´–ë–ï–†–ò–¢–ï –£–°–¢–†–û–ô–°–¢–í–û</h2>
    <div class="mode-cards">
        <div class="mode-card" onmousedown="ui.ripple(event, () => ui.showDifficulty(false))"><div class="mode-icon">üíª</div><div id="modePC" data-lang-key="pc">–ö–æ–º–ø—å—é—Ç–µ—Ä</div></div>
        <div class="mode-card" onmousedown="ui.ripple(event, () => ui.showDifficulty(true))"><div class="mode-icon">üì±</div><div id="modeMob" data-lang-key="mobile">–¢–µ–ª–µ—Ñ–æ–Ω</div></div>
    </div>
    <button class="neon-btn" style="margin-top:40px; width:150px; padding:10px; flex-shrink: 0;" onclick="ui.showMainMenu()" data-lang-key="back">–ù–ê–ó–ê–î</button>
</div>
<div id="modifierScreen" class="menu-screen interactive">
    <h2 style="color:#fff; margin-bottom:30px; flex-shrink: 0;" data-lang-key="modifier">–ú–û–î–ò–§–ò–ö–ê–¢–û–†</h2>
    <div class="mod-container">
        <div class="mod-row">
            <span data-lang-key="botScoreBonus">–ë–æ–Ω—É—Å –æ—á–∫–æ–≤ (–±–æ—Ç—ã)</span>: x<span id="valBotScore">1.0</span>
            <input type="range" min="50" max="500" value="100" class="mod-slider" oninput="ui.modUpdate('botScore', this.value/100)">
        </div>
        <div class="mod-row">
            <span data-lang-key="bossScoreBonus">–ë–æ–Ω—É—Å –æ—á–∫–æ–≤ (–±–æ—Å—Å—ã)</span>: x<span id="valBossScore">1.0</span>
            <input type="range" min="50" max="10000" value="100" class="mod-slider" oninput="ui.modUpdate('bossScore', this.value/100)">
        </div>
        <div class="mod-row">
            <span data-lang-key="playerScoreBonus">–ë–æ–Ω—É—Å –æ—á–∫–æ–≤ (–∏–≥—Ä–æ–∫)</span>: x<span id="valPlayerScore">1.0</span>
            <input type="range" min="50" max="500" value="100" class="mod-slider" oninput="ui.modUpdate('playerScore', this.value/100)">
        </div>
        <div class="mod-row">
            <span data-lang-key="playerDmg">–£—Ä–æ–Ω (–∏–≥—Ä–æ–∫)</span>: x<span id="valPlayerDmg">1.0</span>
            <input type="range" min="50" max="500" value="100" class="mod-slider" oninput="ui.modUpdate('playerDmg', this.value/100)">
        </div>
        <!-- New Modifiers -->
        <div class="mod-row">
            <span data-lang-key="weaponDmg">–£—Ä–æ–Ω –æ—Ä—É–∂–∏—è</span>: x<span id="valWeaponDmg">1.0</span>
            <input type="range" min="20" max="2500" value="100" class="mod-slider" oninput="ui.modUpdate('weaponDmg', this.value/100)">
        </div>
        <div class="mod-row">
            <span data-lang-key="passiveScorePlayer">–û—á–∫–∏/—Å–µ–∫ (–ò–≥—Ä–æ–∫)</span>: <span id="valPassiveScorePlayer">0</span>
            <input type="range" min="0" max="100" value="0" class="mod-slider" oninput="ui.modUpdate('passiveScorePlayer', this.value)">
        </div>
        <div class="mod-row">
            <span data-lang-key="passiveScoreBot">–û—á–∫–∏/—Å–µ–∫ (–ë–æ—Ç—ã)</span>: <span id="valPassiveScoreBot">0</span>
            <input type="range" min="0" max="100" value="0" class="mod-slider" oninput="ui.modUpdate('passiveScoreBot', this.value)">
        </div>
        <div class="mod-row">
            <span data-lang-key="vacuumRadius">–†–∞–¥–∏—É—Å –ø—ã–ª–µ—Å–æ—Å–∏–Ω–≥–∞</span>: x<span id="valVacuum">1.0</span>
            <input type="range" min="100" max="300" value="100" class="mod-slider" oninput="ui.modUpdate('vacuumMult', this.value/100)">
        </div>
        <div class="mod-row">
            <span data-lang-key="ruleImmunity">–ò–º–º—É–Ω–∏—Ç–µ—Ç –∫ –ø—Ä–∞–≤–∏–ª–∞–º</span>: <span id="valRuleImmunity">Off</span>
            <div class="mode-checkbox" id="chkRuleImmunity" onclick="ui.toggleModRuleImmunity()"></div>
        </div>
        <!-- End New -->
        <div class="mod-row">
            <span data-lang-key="botCount">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–æ—Ç–æ–≤</span>: <span id="valBotCount">40</span>
            <input type="range" min="3" max="100" value="40" class="mod-slider" oninput="ui.modUpdate('botCount', this.value)">
        </div>
        <div class="mod-row">
            <span data-lang-key="mapSize">–†–∞–∑–º–µ—Ä –∫–∞—Ä—Ç—ã</span>: <span id="valMapSize">–ù–æ—Ä–º</span>
            <input type="range" min="500" max="10000" step="500" value="5700" class="mod-slider" oninput="ui.modUpdate('customMapSize', this.value)">
        </div>
        <div class="mod-row">
            <span data-lang-key="immunity">–ò–º–º—É–Ω–∏—Ç–µ—Ç –∏–≥—Ä–æ–∫–∞</span>: <span id="valImmunity">0%</span>
            <input type="range" min="0" max="100" value="0" class="mod-slider" oninput="ui.modUpdate('immunity', this.value)">
        </div>
    </div>
    <button class="neon-btn" style="margin-top:20px; padding:10px; flex-shrink: 0;" onclick="ui.showMainMenu()" data-lang-key="back">–ù–ê–ó–ê–î</button>
</div>
<div id="difficultyScreen" class="menu-screen interactive">
    <h2 style="color:#fff; margin-bottom:30px; flex-shrink: 0;" data-lang-key="difficulty">–°–õ–û–ñ–ù–û–°–¢–¨</h2>
    <div class="mode-cards" style="gap:10px;">
        <div class="diff-card" id="diff0" onclick="game.start(ui.tempMobile, 0)" style="border-color:#0ff">
            <div class="diff-title" style="color:#0ff; font-size:14px" data-lang-key="diffAll">–Ø —Ö–æ—á—É –≤—Å—ë —Å—Ä–∞–∑—É</div>
            <div class="diff-desc" data-lang-key="descAll">–ë–æ—Å—Å x0.33 HP<br>–ó–≤—ë–∑–¥—ã x1.75</div>
        </div>
        <div class="diff-card" id="diff1" onclick="game.start(ui.tempMobile, 1)">
            <div class="diff-title" style="color:#0f0; font-size:16px" data-lang-key="diffEasy">–õ–µ–≥—á–∞–π—à–∞—è</div>
            <div class="diff-desc" data-lang-key="descEasy">–ë–æ—Å—Å x0.5 HP<br>–ó–≤—ë–∑–¥—ã x1.5</div>
        </div>
        <div class="diff-card" id="diff2" onclick="game.start(ui.tempMobile, 2)">
            <div class="diff-title" style="color:#ff0; font-size:16px" data-lang-key="diffNormal">–ù–æ—Ä–º–∞–ª—å–Ω–∞—è</div>
            <div class="diff-desc" data-lang-key="descNormal">–ë–∞–ª–∞–Ω—Å</div>
        </div>
        <div class="diff-card" id="diff3" onclick="game.start(ui.tempMobile, 3)">
            <div class="diff-title" style="color:#f00; font-size:16px" data-lang-key="diffHard">–°–ª–æ–∂–Ω–∞—è</div>
            <div class="diff-desc" data-lang-key="descHard">–ë–æ—Å—Å x2.0 HP<br>–£—Ä–æ–Ω x2</div>
        </div>
        <div class="diff-card" id="diff4" onclick="game.start(ui.tempMobile, 4)" style="border-color:#f0f">
            <div class="diff-title" style="color:#f0f; font-size:14px" data-lang-key="diffSigma">–°–∏–≥–º–∞</div>
            <div class="diff-desc" data-lang-key="descSigma">–ë–æ—Å—Å x3.0 HP<br>–ó–≤—ë–∑–¥—ã x0.85</div>
        </div>
    </div>
    <div class="arena-section">
        <div class="arena-title" data-lang-key="arenaGames">–ò–≥—Ä—ã –ê—Ä–µ–Ω—ã</div>
        <div class="arena-cards">
            <div class="arena-card" style="color:#FFA500; border-color:#FFA500" onclick="ui.setArenaMode('mini')">
                <div class="arena-card-title" data-lang-key="modeMini">–ú–∏–Ω–∏-—Ä–∞—à</div>
                <div class="arena-card-desc" data-lang-key="descMini">1 –Ω–∞ 1 —Å –ë–æ—Å—Å–æ–º.</div>
            </div>
            <div class="arena-card" style="color:#00FFFF; border-color:#00FFFF" onclick="ui.setArenaMode('duel')">
                <div class="arena-card-title" data-lang-key="modeDuel">–î—É—ç–ª–∏</div>
                <div class="arena-card-desc" data-lang-key="descDuel">1 vs 1. –ß–µ—Å—Ç–Ω–∞—è –±–∏—Ç–≤–∞.</div>
            </div>
            <div class="arena-card" style="color:#32CD32; border-color:#32CD32" onclick="ui.setArenaMode('arena')">
                <div class="arena-card-title" data-lang-key="modeArena">–ê—Ä–µ–Ω–∞</div>
                <div class="arena-card-desc" data-lang-key="descArena">10 –∏–≥—Ä–æ–∫–æ–≤.</div>
            </div>
            <div class="arena-card" style="color:#FF00FF; border-color:#FF00FF" onclick="ui.setArenaMode('royal')">
                <div class="arena-card-title" data-lang-key="modeRoyal">–ö–æ—Ä–æ–ª–µ–≤—Å–∫–∞—è –±–∏—Ç–≤–∞</div>
                <div class="arena-card-desc" data-lang-key="descRoyal">100 –∏–≥—Ä–æ–∫–æ–≤.</div>
            </div>
            <div class="arena-card" style="color:#1E90FF; border-color:#1E90FF" onclick="ui.setArenaMode('team')">
                <div class="arena-card-title" data-lang-key="modeTeam">–ö–æ–º–∞–Ω–¥–Ω–∞—è –±–∏—Ç–≤–∞</div>
                <div class="arena-card-desc" data-lang-key="descTeam">–ö—Ä–∞—Å–Ω—ã–µ vs –°–∏–Ω–∏–µ.</div>
            </div>
             <div class="arena-card" style="color:#FFFF00; border-color:#FFFF00" onclick="ui.setArenaMode('survival_random')">
                <div class="arena-card-title" data-lang-key="modeSurvivalRandom">–í—ã–∂–∏–≤–∞–Ω–∏–µ –Ω–∞ —Ä–∞–Ω–¥–æ–º</div>
                <div class="arena-card-desc" data-lang-key="descSurvivalRandom">–°–º–µ–Ω–∞ –∫–∞—Ä—Ç—ã –∏ –ø–ª–∞–Ω–µ—Ç.</div>
            </div>
            <div class="arena-card" style="color:#FF69B4; border-color:#FF69B4" onclick="ui.setArenaMode('random_start')">
                <div class="arena-card-title" data-lang-key="modeRandom">–†–∞–Ω–¥–æ–º</div>
                <div class="arena-card-desc" data-lang-key="descRandom">–°–ª—É—á–∞–π–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã.</div>
            </div>
            <div class="arena-card" style="color:#FFFFFF; border-color:#FFFFFF" onclick="ui.setArenaMode('agility')">
                <div class="arena-card-title" data-lang-key="modeAgility">–õ–æ–≤–∫–æ—Å—Ç—å</div>
                <div class="arena-card-desc" data-lang-key="descAgility">–í—ã –ø—Ä–æ—Ç–∏–≤ –æ–¥–Ω–æ–π –ø–ª–∞–Ω–µ—Ç—ã.</div>
            </div>
            <div class="arena-card" style="color:#8A2BE2; border-color:#8A2BE2" onclick="ui.setArenaMode('5vs1')">
                <div class="arena-card-title" data-lang-key="mode5v1">5 –Ω–∞ 1</div>
                <div class="arena-card-desc" data-lang-key="desc5v1">–ê—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–∞—è –±–∏—Ç–≤–∞.</div>
            </div>
             <div class="arena-card" style="color:#00FF00; border-color:#00FF00" onclick="ui.setArenaMode('zombie')">
                <div class="arena-card-title" data-lang-key="modeZombie">–ó–æ–º–±–∏-–∞–ø–æ–∫–∞–ª–∏–ø—Å–∏—Å</div>
                <div class="arena-card-desc" data-lang-key="descZombie">–í—ã–∂–∏–≤–∞–Ω–∏–µ –ø—Ä–æ—Ç–∏–≤ –∏–Ω—Ñ–µ–∫—Ü–∏–∏.</div>
            </div>
            <div class="arena-card" style="color:#FF4500; border-color:#FF4500" onclick="ui.setArenaMode('all_vs_one')">
                <div class="arena-card-title" data-lang-key="modeAllVsOne">–í—Å–µ –ø—Ä–æ—Ç–∏–≤ –æ–¥–Ω–æ–≥–æ</div>
                <div class="arena-card-desc" data-lang-key="descAllVsOne">–í–µ—Å—å –º–∏—Ä –ø—Ä–æ—Ç–∏–≤ –≤–∞—Å.</div>
            </div>
            <div class="arena-card" style="color:#F0F8FF; border-color:#F0F8FF" onclick="ui.setArenaMode('countryballs')">
                <div class="arena-card-title" data-lang-key="modeCountry">–ö–∞–Ω—Ç—Ä–∏ –±–æ–ª–ª—Å</div>
                <div class="arena-card-desc" data-lang-key="descCountry">–ü–ª–∞–Ω–µ—Ç—ã-—Å—Ç—Ä–∞–Ω—ã.</div>
            </div>
            <div class="arena-card" style="color:#00BFFF; border-color:#00BFFF" onclick="ui.setArenaMode('save_life')">
                <div class="arena-card-title" data-lang-key="modeSaveLife">–°–æ—Ö—Ä–∞–Ω–∏ –∂–∏–∑–Ω—å</div>
                <div class="arena-card-desc" data-lang-key="descSaveLife">–ó–∞—â–∏—Ç–∞ –ó–µ–º–ª–∏ –æ—Ç –≤–æ–ª–Ω.</div>
            </div>
        </div>
    </div>
    <div id="modeToggles">
        <div class="mode-toggle-row" onclick="ui.toggleGameMode('secondChance')">
            <div class="mode-checkbox" id="chkSecondChance"></div> <span data-lang-key="secondChance">–í—Ç–æ—Ä–∞—è –ø–æ–ø—ã—Ç–∫–∞</span>
        </div>
        <div class="mode-toggle-row" onclick="ui.toggleGameMode('bossRush')">
            <div class="mode-checkbox" id="chkBossRush"></div> <span data-lang-key="bossRush">–ë–æ—Å—Å-—Ä–∞—à</span>
        </div>
        <div class="mode-toggle-row" onclick="ui.toggleGameMode('pseudoMulti')">
            <div class="mode-checkbox" id="chkPseudoMulti"></div> <span data-lang-key="pseudoMulti">–ü—Å–µ–≤–¥–æ –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä</span>
        </div>
         <div class="mode-toggle-row" onclick="ui.toggleGameMode('disableEvents')">
            <div class="mode-checkbox" id="chkDisableEvents"></div> <span data-lang-key="disableEvents">–û—Ç–∫–ª. —Å–æ–±—ã—Ç–∏—è –ê—Ä–µ–Ω—ã</span>
        </div>
    </div>
    <button class="neon-btn" style="margin-top:40px; width:150px; padding:10px; flex-shrink: 0;" onclick="ui.showModeSelect()" data-lang-key="back">–ù–ê–ó–ê–î</button>
</div>
<div id="shopScreen" class="menu-screen interactive" style="display: none;">
    <div class="shop-header">
        <div class="money-display">ü™ô <span id="shopCoins">0</span></div>
        <div style="font-size: min(24px, 4vw); font-weight: bold; color:#aaa; letter-spacing: 3px;" id="shopTitle" data-lang-key="shop">–ú–ê–ì–ê–ó–ò–ù</div>
        <div class="close-btn" onmousedown="ui.ripple(event, () => ui.closeShop())">‚úï</div>
    </div>
    <div class="shop-tabs">
        <button class="tab-btn active" onclick="ui.switchTab('planets')" id="tabPlanets" data-lang-key="tabPlanets">–ü–õ–ê–ù–ï–¢–´</button>
        <button class="tab-btn" onclick="ui.switchTab('upgrades')" id="tabUpgrades" data-lang-key="tabItems">–ü–†–ï–î–ú–ï–¢–´</button>
        <button class="tab-btn" onclick="ui.switchTab('abilities')" id="tabAbilities" data-lang-key="tabAbilities">–°–ü–û–°–û–ë–ù–û–°–¢–ò</button>
        <button class="tab-btn" onclick="ui.switchTab('misc')" id="tabMisc" data-lang-key="tabMisc">–†–ê–ó–ù–û–ï</button>
    </div>
    <div class="shop-content-area">
        <button class="neon-btn" style="width:200px; padding:10px; margin: 10px 0; border-color:violet; font-size:14px;" onclick="ui.selectRandomPlanet()" data-lang-key="randomPlanet">üé≤ –°–õ–£–ß–ê–ô–ù–ê–Ø –ü–õ–ê–ù–ï–¢–ê</button>
        <div class="shop-row-container">
             <div class="nav-arrow" onclick="ui.scrollShop(-1)">‚óÑ</div>
             <div id="cards-container" class="cards-scroll-area"></div>
             <div class="nav-arrow" onclick="ui.scrollShop(1)">‚ñ∫</div>
        </div>
    </div>
    <div class="shop-footer-desc" id="fullDescArea" data-lang-key="hoverDesc">–ù–∞–≤–µ–¥–∏—Ç–µ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è</div>
</div>
<script>
const CONFIG = { mapSize: 5700, baseSize: 20, maxStars: 3500, itemCount: 40, botCount: 40 }; 
const QUOTES = ["–ê–¥–¥–∏—Å-–ê–±–µ–±–∞ —Ç–æ–ø!", "–î–µ–π–º–∏–∫—Å —Ç–æ–ø", "–ù–µ –∫—Ä–∏–Ω–≥–µ", "–ó–∏–º–∞ 2025", "–°–Ω–µ–∂–∫–∏ –ª–µ—Ç—è—Ç!", "–ë–µ—Ä–µ–≥–∏—Å—å –±–æ—Å—Å–æ–≤!", "–¢–û–ù 618 –∂–¥—ë—Ç...", "–§–µ–Ω–∏–∫—Å –ê –Ω–∞–±–ª—é–¥–∞–µ—Ç..."];

const LANG_DATA = {
    ru: {
        play: "–ò–ì–†–ê–¢–¨", shop: "–ú–ê–ì–ê–ó–ò–ù", modifier: "–ú–û–î–ò–§–ò–ö–ê–¢–û–†", settings: "–ù–ê–°–¢–†–û–ô–ö–ò", freeCoins: "–ë–ï–°–ü–õ–ê–¢–ù–´–ï –ú–û–ù–ï–¢–´",
        pc: "–ö–æ–º–ø—å—é—Ç–µ—Ä", mobile: "–¢–µ–ª–µ—Ñ–æ–Ω", back: "–ù–ê–ó–ê–î", chooseDevice: "–í–´–ë–ï–†–ò–¢–ï –£–°–¢–†–û–ô–°–¢–í–û",
        difficulty: "–°–õ–û–ñ–ù–û–°–¢–¨", diffAll: "–Ø —Ö–æ—á—É –≤—Å—ë —Å—Ä–∞–∑—É", descAll: "–ë–æ—Å—Å x0.33 HP<br>–ó–≤—ë–∑–¥—ã x1.75",
        diffEasy: "–õ–µ–≥—á–∞–π—à–∞—è", descEasy: "–ë–æ—Å—Å x0.5 HP<br>–ó–≤—ë–∑–¥—ã x1.5", diffNormal: "–ù–æ—Ä–º–∞–ª—å–Ω–∞—è", descNormal: "–ë–∞–ª–∞–Ω—Å",
        diffHard: "–°–ª–æ–∂–Ω–∞—è", descHard: "–ë–æ—Å—Å x2.0 HP<br>–£—Ä–æ–Ω x2", diffSigma: "–°–∏–≥–º–∞", descSigma: "–ë–æ—Å—Å x3.0 HP<br>–ó–≤—ë–∑–¥—ã x0.85",
        arenaGames: "–ò–≥—Ä—ã –ê—Ä–µ–Ω—ã", modeMini: "–ú–∏–Ω–∏-—Ä–∞—à", descMini: "1 –Ω–∞ 1 —Å –ë–æ—Å—Å–æ–º.",
        modeDuel: "–î—É—ç–ª–∏", descDuel: "1 vs 1. –ß–µ—Å—Ç–Ω–∞—è –±–∏—Ç–≤–∞.", modeArena: "–ê—Ä–µ–Ω–∞", descArena: "10 –∏–≥—Ä–æ–∫–æ–≤.",
        modeRoyal: "–ö–æ—Ä–æ–ª–µ–≤—Å–∫–∞—è –±–∏—Ç–≤–∞", descRoyal: "100 –∏–≥—Ä–æ–∫–æ–≤.", modeTeam: "–ö–æ–º–∞–Ω–¥–Ω–∞—è –±–∏—Ç–≤–∞", descTeam: "–ö—Ä–∞—Å–Ω—ã–µ vs –°–∏–Ω–∏–µ.",
        modeSurvivalRandom: "–í—ã–∂–∏–≤–∞–Ω–∏–µ –Ω–∞ —Ä–∞–Ω–¥–æ–º", descSurvivalRandom: "–°–º–µ–Ω–∞ –∫–∞—Ä—Ç—ã –∏ –ø–ª–∞–Ω–µ—Ç.",
        modeRandom: "–†–∞–Ω–¥–æ–º", descRandom: "–°–ª—É—á–∞–π–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã.", modeAgility: "–õ–æ–≤–∫–æ—Å—Ç—å", descAgility: "–í—ã –ø—Ä–æ—Ç–∏–≤ –æ–¥–Ω–æ–π –ø–ª–∞–Ω–µ—Ç—ã.",
        mode5v1: "5 –Ω–∞ 1", desc5v1: "–ê—Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–∞—è –±–∏—Ç–≤–∞.", modeZombie: "–ó–æ–º–±–∏-–∞–ø–æ–∫–∞–ª–∏–ø—Å–∏—Å", descZombie: "–í—ã–∂–∏–≤–∞–Ω–∏–µ –ø—Ä–æ—Ç–∏–≤ –∏–Ω—Ñ–µ–∫—Ü–∏–∏.",
        modeAllVsOne: "–í—Å–µ –ø—Ä–æ—Ç–∏–≤ –æ–¥–Ω–æ–≥–æ", descAllVsOne: "–í–µ—Å—å –º–∏—Ä –ø—Ä–æ—Ç–∏–≤ –≤–∞—Å.", modeCountry: "–ö–∞–Ω—Ç—Ä–∏ –±–æ–ª–ª—Å", descCountry: "–ü–ª–∞–Ω–µ—Ç—ã-—Å—Ç—Ä–∞–Ω—ã.",
        modeSaveLife: "–°–æ—Ö—Ä–∞–Ω–∏ –∂–∏–∑–Ω—å", descSaveLife: "–ó–∞—â–∏—Ç–∞ –ó–µ–º–ª–∏ –æ—Ç –≤–æ–ª–Ω.",
        secondChance: "–í—Ç–æ—Ä–∞—è –ø–æ–ø—ã—Ç–∫–∞", bossRush: "–ë–æ—Å—Å-—Ä–∞—à", pseudoMulti: "–ü—Å–µ–≤–¥–æ –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä", disableEvents: "–û—Ç–∫–ª. —Å–æ–±—ã—Ç–∏—è –ê—Ä–µ–Ω—ã",
        tabPlanets: "–ü–õ–ê–ù–ï–¢–´", tabItems: "–ü–†–ï–î–ú–ï–¢–´", tabAbilities: "–°–ü–û–°–û–ë–ù–û–°–¢–ò", tabMisc: "–†–ê–ó–ù–û–ï",
        randomPlanet: "üé≤ –°–õ–£–ß–ê–ô–ù–ê–Ø –ü–õ–ê–ù–ï–¢–ê", hoverDesc: "–ù–∞–≤–µ–¥–∏—Ç–µ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è",
        pause: "–ü–ê–£–ó–ê", continue: "–ü–†–û–î–û–õ–ñ–ò–¢–¨", menu: "–ú–ï–ù–Æ", gameOver: "–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê", score: "–°—á–µ—Ç", coins: "–ú–æ–Ω–µ—Ç", mainMenu: "–ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ",
        items: "–ü–†–ï–î–ú–ï–¢–´", rayAttack: "–†–ï–ñ–ò–ú –õ–£–ß–ï–í–û–ô –ê–¢–ê–ö–ò", blueAttack: "–†–ï–ñ–ò–ú –ì–û–õ–£–ë–û–ô –ê–¢–ê–ö–ò",
        frozen: "‚ùÑÔ∏è –ó–ê–ú–û–†–û–ó–ö–ê ‚ùÑÔ∏è", move: "–î–í–ò–ñ–ï–ù–ò–ï", aim: "–ü–†–ò–¶–ï–õ", size: "–†–∞–∑–º–µ—Ä", save: "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å", cancel: "–û—Ç–º–µ–Ω–∞",
        setupControls: "–ù–∞—Å—Ç—Ä–æ–∏—Ç—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ", fpsCounter: "–°—á–µ—Ç—á–∏–∫ FPS", close: "–ó–∞–∫—Ä—ã—Ç—å",
        botScoreBonus: "–ë–æ–Ω—É—Å –æ—á–∫–æ–≤ (–±–æ—Ç—ã)", bossScoreBonus: "–ë–æ–Ω—É—Å –æ—á–∫–æ–≤ (–±–æ—Å—Å—ã)", playerScoreBonus: "–ë–æ–Ω—É—Å –æ—á–∫–æ–≤ (–∏–≥—Ä–æ–∫)",
        playerDmg: "–£—Ä–æ–Ω (–∏–≥—Ä–æ–∫)", weaponDmg: "–£—Ä–æ–Ω –æ—Ä—É–∂–∏—è", passiveScorePlayer: "–û—á–∫–∏/—Å–µ–∫ (–ò–≥—Ä–æ–∫)", passiveScoreBot: "–û—á–∫–∏/—Å–µ–∫ (–ë–æ—Ç—ã)",
        vacuumRadius: "–†–∞–¥–∏—É—Å –ø—ã–ª–µ—Å–æ—Å–∏–Ω–≥–∞", ruleImmunity: "–ò–º–º—É–Ω–∏—Ç–µ—Ç –∫ –ø—Ä–∞–≤–∏–ª–∞–º",
        botCount: "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–æ—Ç–æ–≤", mapSize: "–†–∞–∑–º–µ—Ä –∫–∞—Ä—Ç—ã", immunity: "–ò–º–º—É–Ω–∏—Ç–µ—Ç –∏–≥—Ä–æ–∫–∞"
    },
    en: {
        play: "PLAY", shop: "SHOP", modifier: "MODIFIER", settings: "SETTINGS", freeCoins: "FREE COINS",
        pc: "Computer", mobile: "Phone", back: "BACK", chooseDevice: "CHOOSE DEVICE",
        difficulty: "DIFFICULTY", diffAll: "I want it all", descAll: "Boss x0.33 HP<br>Stars x1.75",
        diffEasy: "Easiest", descEasy: "Boss x0.5 HP<br>Stars x1.5", diffNormal: "Normal", descNormal: "Balanced",
        diffHard: "Hard", descHard: "Boss x2.0 HP<br>Dmg x2", diffSigma: "Sigma", descSigma: "Boss x3.0 HP<br>Stars x0.85",
        arenaGames: "Arena Games", modeMini: "Mini-Rush", descMini: "1 vs 1 with Boss.",
        modeDuel: "Duels", descDuel: "1 vs 1. Fair fight.", modeArena: "Arena", descArena: "10 players.",
        modeRoyal: "Battle Royale", descRoyal: "100 players.", modeTeam: "Team Battle", descTeam: "Red vs Blue.",
        modeSurvivalRandom: "Survival Random", descSurvivalRandom: "Map & planet swap.",
        modeRandom: "Random", descRandom: "Random params.", modeAgility: "Agility", descAgility: "You vs One Planet.",
        mode5v1: "5 vs 1", desc5v1: "Asymmetric battle.", modeZombie: "Zombie Apocalypse", descZombie: "Survive infection.",
        modeAllVsOne: "All vs One", descAllVsOne: "World vs You.", modeCountry: "Countryballs", descCountry: "Country planets.",
        modeSaveLife: "Save Life", descSaveLife: "Defend Earth.",
        secondChance: "Second Chance", bossRush: "Boss Rush", pseudoMulti: "Pseudo Multiplayer", disableEvents: "Disable Arena Events",
        tabPlanets: "PLANETS", tabItems: "ITEMS", tabAbilities: "ABILITIES", tabMisc: "MISC",
        randomPlanet: "üé≤ RANDOM PLANET", hoverDesc: "Hover for description",
        pause: "PAUSE", continue: "CONTINUE", menu: "MENU", gameOver: "GAME OVER", score: "Score", coins: "Coins", mainMenu: "MAIN MENU",
        items: "ITEMS", rayAttack: "RAY ATTACK MODE", blueAttack: "BLUE ATTACK MODE",
        frozen: "‚ùÑÔ∏è FROZEN ‚ùÑÔ∏è", move: "MOVE", aim: "AIM", size: "Size", save: "Save", cancel: "Cancel",
        setupControls: "Setup Controls", fpsCounter: "FPS Counter", close: "Close",
        botScoreBonus: "Score Bonus (Bots)", bossScoreBonus: "Score Bonus (Bosses)", playerScoreBonus: "Score Bonus (Player)",
        playerDmg: "Damage (Player)", weaponDmg: "Weapon Damage", passiveScorePlayer: "Score/sec (Player)", passiveScoreBot: "Score/sec (Bots)",
        vacuumRadius: "Vacuum Radius", ruleImmunity: "Rule Immunity",
        botCount: "Bot Count", mapSize: "Map Size", immunity: "Player Immunity"
    }
};

const ITEMS_TYPES = {
    speed: { icon: '‚ö°', name: "–°–∫–æ—Ä–æ—Å—Ç—å", color: '#FFD700', duration: 10, cooldown: 10 },
    magnet: { icon: 'üß≤', name: "–ú–∞–≥–Ω–∏—Ç", color: '#FF4500', duration: 10, cooldown: 10 },
    grow: { icon: 'üí™', name: "–°–∏–ª–∞", color: '#00BFFF', duration: 10, cooldown: 10 },
    bonus: { icon: '‚≠ê', name: "–ë–æ–Ω—É—Å", color: '#FF00FF', duration: 10, cooldown: 10 }
};

const PLANETS = [
    { id: 'mercury', category: 'rocky', name: '–ú–µ—Ä–∫—É—Ä–∏–π', price: 250, color: '#A9A9A9', detail: '#696969', type: 4, desc: "–°–∞–º–∞—è –±—ã—Å—Ç—Ä–∞—è", fullDesc: "–°–∫–æ—Ä–æ—Å—Ç—å x1.2. –ù–µ—Ç —Å–ø—É—Ç–Ω–∏–∫–∞ (+30 –æ—á–∫–æ–≤). –£—Ä–æ–Ω –ª—É—á–∞ x1.2. –¢—Ä–æ–π–Ω–æ–π –≤—ã—Å—Ç—Ä–µ–ª –ø–æ–ª–æ—Å–∫–∞–º–∏. –°–µ—Ä—ã–π —Å–Ω–µ–∂–æ–∫." },
    { id: 'venus', category: 'gas', name: '–í–µ–Ω–µ—Ä–∞', price: 350, color: '#F4A460', detail: '#D2691E', type: 1, desc: "–ì–æ—Ä—è—á–∞—è –∞—Ç–º–æ—Å—Ñ–µ—Ä–∞", fullDesc: "–ñ–µ–ª—Ç–∞—è –∞—Ç–º–æ—Å—Ñ–µ—Ä–∞/—â–∏—Ç/—Å–Ω–µ–∂–æ–∫. –ü–æ–ª–æ—Å–∫–∏: –Ω–µ—Ç–æ—á–Ω—ã–µ, —É—Ä–æ–Ω x0.35, –¥–µ—à–µ–≤—ã–µ, –±—ã—Å—Ç—Ä–∞—è —Å—Ç—Ä–µ–ª—å–±–∞. –õ—É—á x1.5 —É—Ä–æ–Ω. –°–ø—É—Ç–Ω–∏–∫ —Å—Ç—Ä–µ–ª—è–µ—Ç." },
    { id: 'earth', category: 'rocky', name: '–ó–µ–º–ª—è', price: 0, color: '#1E90FF', detail: '#2E8B57', type: 2, desc: "–†–æ–¥–Ω–æ–π –¥–æ–º", fullDesc: "–®–∞–Ω—Å 15% –ø–æ–ª—É—á–∏—Ç—å x1.5 –æ—á–∫–æ–≤ —Å–æ –∑–≤–µ–∑–¥. –°–Ω–µ–∂–æ–∫ –±–µ–ª—ã–π –∏ –Ω–∞–≤–æ–¥–∏—Ç—Å—è. –õ—É—á x1.15 –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å." },
    { id: 'mars', category: 'rocky', name: '–ú–∞—Ä—Å', price: 450, color: '#CD5C5C', detail: '#8B0000', type: 2, desc: "–ö—Ä–∞—Å–Ω–∞—è –ø–ª–∞–Ω–µ—Ç–∞", fullDesc: "–°–∫–æ—Ä–æ—Å—Ç—å +3%. –õ—É—á –±—ã—Å—Ç—Ä–µ–µ (-30% –∑–∞–¥–µ—Ä–∂–∫–∞). 2 —Å–ø—É—Ç–Ω–∏–∫–∞. –í–∞–º–ø–∏—Ä-—à–∞—Ä –Ω–∞–≤–æ–¥–∏—Ç—Å—è." },
    { id: 'jupiter', category: 'gas', name: '–Æ–ø–∏—Ç–µ—Ä', price: 550, color: '#DEB887', detail: '#8B4513', type: 1, desc: "–ì–∞–∑–æ–≤—ã–π –≥–∏–≥–∞–Ω—Ç", fullDesc: "–°–∫–æ—Ä–æ—Å—Ç—å -15%. –õ—É—á: –¥–æ–ª–≥–∏–π, –º–æ—â–Ω—ã–π (x1.45), –Ω–∞–≤–æ–¥–∏—Ç—Å—è. –©–∏—Ç –ø—Ä–æ—á–Ω–µ–µ. –õ–µ–¥. –ø—É–ª—è: –º–µ–¥–ª–µ–Ω–Ω–µ–µ, –∑–∞–º–æ—Ä–æ–∑–∫–∞ 90%." },
    { id: 'saturn', category: 'gas', name: '–°–∞—Ç—É—Ä–Ω', price: 650, color: '#F4A460', detail: '#A0522D', hasRing: true, type: 1, desc: "–ö–æ–ª—å—Ü–∞", fullDesc: "–°–∫–æ—Ä–æ—Å—Ç—å -10%. –ö–æ–ª—å—Ü–∞ –Ω–∞–Ω–æ—Å—è—Ç —É—Ä–æ–Ω 1%. –°–ø—É—Ç–Ω–∏–∫ –ø–æ–ª–æ—Å–∞—Ç—ã–π (—É—Ä–æ–Ω +30%)." },
    { id: 'uranus', category: 'gas', name: '–£—Ä–∞–Ω', price: 700, color: '#AFEEEE', detail: '#40E0D0', hasRing: true, type: 3, desc: "–õ–µ–¥—è–Ω–æ–π –≥–∏–≥–∞–Ω—Ç", fullDesc: "–°–∫–æ—Ä–æ—Å—Ç—å -5%. –•–æ–ª–æ–¥–Ω—ã–π." },
    { id: 'neptune', category: 'gas', name: '–ù–µ–ø—Ç—É–Ω', price: 750, color: '#4169E1', detail: '#000080', type: 1, desc: "–ë–æ–≥ –º–æ—Ä–µ–π", fullDesc: "–°–∫–æ—Ä–æ—Å—Ç—å -3%. –ì–ª—É–±–æ–∫–∏–π —Å–∏–Ω–∏–π." },
    { id: 'sun', category: 'star', name: '–°–æ–ª–Ω—Ü–µ', price: 1000, color: '#FFD700', detail: '#FF8C00', type: 3, glow: true, desc: "–ó–≤–µ–∑–¥–∞", fullDesc: "–¶–µ–Ω—Ç—Ä —Å–∏—Å—Ç–µ–º—ã. 8 –õ—É–Ω. –û—Å–æ–±—ã–π –ª—É—á." },
    { id: 'proximab', category: 'rocky', name: 'Proxima b', price: 400, color: '#d96', detail: '#953', type: 2, desc: "–°–æ—Å–µ–¥", fullDesc: "–ë–ª–∏–∂–∞–π—à–∞—è —ç–∫–∑–æ–ø–ª–∞–Ω–µ—Ç–∞." },
    { id: 'kepler186f', category: 'rocky', name: 'Kepler-186f', price: 450, color: '#d2691e', detail: '#8b4513', type: 2, desc: "–ó–µ–º–ª—è 2.0?", fullDesc: "–ê—Ç–º–æ—Å—Ñ–µ—Ä–Ω–∞—è." },
    { id: 'trappist1e', category: 'rocky', name: 'Trappist-1e', price: 500, color: '#20b2aa', detail: '#008b8b', type: 1, desc: "–í–æ–¥–Ω—ã–π –º–∏—Ä", fullDesc: "–í –∑–æ–Ω–µ –æ–±–∏—Ç–∞–µ–º–æ—Å—Ç–∏." },
    { id: 'gliese581g', category: 'rocky', name: 'Gliese 581g', price: 550, color: '#778899', detail: '#2f4f4f', type: 2, desc: "–°–µ—Ä—ã–π –º–∏—Ä", fullDesc: "–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –æ–±–∏—Ç–∞–µ–º–∞." },
    { id: 'teegardenb', category: 'rocky', name: 'Teegarden b', price: 575, color: '#cd853f', detail: '#a0522d', type: 2, desc: "–¢–µ–ø–ª–∞—è", fullDesc: "–£ –∫—Ä–∞—Å–Ω–æ–≥–æ –∫–∞—Ä–ª–∏–∫–∞." },
    { id: 'toi700d', category: 'rocky', name: 'TOI-700 d', price: 600, color: '#deb887', detail: '#cd5c5c', type: 1, desc: "–≠–∫–∑–æ–ø–ª–∞–Ω–µ—Ç–∞", fullDesc: "–ö–∞–º–µ–Ω–∏—Å—Ç–∞—è." },
    { id: 'sirius', category: 'star', name: '–°–∏—Ä–∏—É—Å', price: 1200, color: '#A0D2FF', detail: '#fff', type: 3, glow: true, desc: "–Ø—Ä—á–∞–π—à–∞—è", fullDesc: "–°–∏—è–µ—Ç –±–µ–ª–æ-–≥–æ–ª—É–±—ã–º. –õ—É—á –∏ –ø–æ–ª–æ—Å–∫–∏ - –≥–æ–ª—É–±—ã–µ. –õ—É–Ω–∞ —É—Å–∏–ª–µ–Ω–∞." },
    { id: 'rigel', category: 'star', name: '–†–∏–≥–µ–ª—å', price: 1350, color: '#4455ff', detail: '#ccddee', type: 3, glow: true, desc: "–ì–æ–ª—É–±–æ–π —Å–≤–µ—Ä—Ö–≥–∏–≥–∞–Ω—Ç", fullDesc: "–•–æ–ª–æ–¥–Ω–∞—è —è—Ä–æ—Å—Ç—å." },
    { id: 'aldebaran', category: 'star', name: '–ê–ª—å–¥–µ–±–∞—Ä–∞–Ω', price: 1450, color: '#ff8800', detail: '#ffaa44', type: 3, glow: true, desc: "–ì–ª–∞–∑ –¢–µ–ª—å—Ü–∞", fullDesc: "–û—Ä–∞–Ω–∂–µ–≤—ã–π –≥–∏–≥–∞–Ω—Ç." },
    { id: 'proximac', category: 'star', name: 'Proxima Centauri', price: 1600, color: '#FF4500', detail: '#FF6347', type: 3, glow: true, desc: "–ö–µ–Ω—Ç–∞–≤—Ä :/", fullDesc: "–ü–æ—á—Ç–∏ –¶–µ–Ω—Ç–∞–≤—Ä–∞, –Ω–æ –ö–µ–Ω—Ç–∞–≤—Ä :/" },
    { id: 'betelgeuse', category: 'star', name: '–ë–µ—Ç–µ–ª—å–≥–µ–π–∑–µ', price: 1750, color: '#ff4500', detail: '#8b0000', type: 3, glow: true, desc: "–ö—Ä–∞—Å–Ω—ã–π –≥–∏–≥–∞–Ω—Ç", fullDesc: "–û–≥—Ä–æ–º–Ω–∞—è –∏ –º–æ—â–Ω–∞—è. –ö—Ä–∞—Å–Ω—ã–π –ª—É—á –∏ –ø–æ–ª–æ—Å–∫–∏. –õ—É–Ω–∞ —É—Å–∏–ª–µ–Ω–∞." },
    { id: 'ceres', category: 'rocky', name: '–¶–µ—Ä–µ—Ä–∞', price: 750, color: '#888888', detail: '#aaaaaa', type: 4, desc: "–ö–∞—Ä–ª–∏–∫", fullDesc: "–ú–∞–ª–µ–Ω—å–∫–∞—è –∏ —É–¥–∞–ª–µ–Ω—å–∫–∞—è. –°–µ—Ä—ã–π —Ü–≤–µ—Ç." },
    { id: 'kepler22b', category: 'rocky', name: 'Kepler-22b', price: 800, color: '#2a9', detail: '#165', type: 1, desc: "–í–æ–¥–Ω—ã–π –º–∏—Ä", fullDesc: "–û–∫–µ–∞–Ω –±–µ–∑ –∫–æ–Ω—Ü–∞." },
    { id: 'tts16a', category: 'rocky', name: 'TTS-16a Proxima', price: 2500, color: '#FF0000', detail: '#00FF00', type: 5, desc: "–û—Å–æ–±–∞—è", fullDesc: "–ö—Ä–∞—Å–Ω–æ-–∑–µ–ª–µ–Ω–∞—è –ø–ª–∞–Ω–µ—Ç–∞. –õ—É—á –≤ —Ü–≤–µ—Ç–∞—Ö –¢–∞—Ç–∞—Ä—Å—Ç–∞–Ω–∞. –û—Å–æ–±–∞—è –≤–æ–ª–Ω–∞ –∏ —Å–Ω–µ–∂–æ–∫." },
    { id: 'kepler452b', category: 'rocky', name: 'Kepler-452b', price: 650, color: '#228B22', detail: '#006400', type: 2, desc: "–°—Ç–∞—Ä—à–∏–π –±—Ä–∞—Ç –ó–µ–º–ª–∏", fullDesc: "–ú–∞—Å—Å–∏–≤–Ω–∞—è, –Ω–æ –∂–∏–∑–Ω–µ–ø—Ä–∏–≥–æ–¥–Ω–∞—è." },
    { id: 'hd189733b', category: 'gas', name: 'HD 189733 b', price: 900, color: '#00008B', detail: '#191970', type: 1, desc: "–°—Ç–µ–∫–ª—è–Ω–Ω—ã–π –¥–æ–∂–¥—å", fullDesc: "–ì–ª—É–±–æ–∫–∏–π —Å–∏–Ω–∏–π —Ü–≤–µ—Ç, —Å–∏–ª—å–Ω—ã–µ –≤–µ—Ç—Ä–∞." },
    { id: '55cancrie', category: 'rocky', name: '55 Cancri e', price: 1200, color: '#FFC0CB', detail: '#FF69B4', type: 4, desc: "–ê–ª–º–∞–∑–Ω–∞—è –ø–ª–∞–Ω–µ—Ç–∞", fullDesc: "–û—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è –∏ –¥–æ—Ä–æ–≥–∞—è." },
    { id: 'wasp12b', category: 'gas', name: 'WASP-12b', price: 1100, color: '#4B0082', detail: '#000', type: 1, desc: "–ü–æ–≥–ª–æ—â–∞–µ–º–∞—è", fullDesc: "–î–µ—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–µ–π." },
    { id: 'gj504b', category: 'gas', name: 'GJ 504 b', price: 950, color: '#FF69B4', detail: '#C71585', type: 3, desc: "–†–æ–∑–æ–≤–∞—è –ø–ª–∞–Ω–µ—Ç–∞", fullDesc: "–ú–æ–ª–æ–¥–æ–π –≥–∞–∑–æ–≤—ã–π –≥–∏–≥–∞–Ω—Ç." },
    { id: 'uyscuti', category: 'star', name: 'UY Scuti', price: 2800, color: '#8B0000', detail: '#000', type: 3, glow: true, desc: "–ì–∏–ø–µ—Ä–≥–∏–≥–∞–Ω—Ç", fullDesc: "–ö–æ–ª–æ—Å—Å–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä." },
    { id: 'stephenson218', category: 'star', name: 'Stephenson 2-18', price: 3000, color: '#FF4500', detail: '#A52A2A', type: 3, glow: true, desc: "–ö–æ—Ä–æ–ª—å —Ä–∞–∑–º–µ—Ä–æ–≤", fullDesc: "–°–∞–º–∞—è –±–æ–ª—å—à–∞—è –∏–∑–≤–µ—Å—Ç–Ω–∞—è –∑–≤–µ–∑–¥–∞." },
    { id: 'vycanis', category: 'star', name: 'VY Canis Majoris', price: 2600, color: '#DC143C', detail: '#800000', type: 3, glow: true, desc: "–ö—Ä–∞—Å–Ω—ã–π –≥–∏–ø–µ—Ä–≥–∏–≥–∞–Ω—Ç", fullDesc: "–ù–µ—Å—Ç–∞–±–∏–ª—å–Ω–∞—è –∏ –æ–≥—Ä–æ–º–Ω–∞—è." }
];

const BOSS_DATA = [
    { stage: 1, color: '#FFD700', name: "–ñ—ë–ª—Ç—ã–π –∫–∞—Ä–ª–∏–∫", atkColor: '#FFD700' },
    { stage: 2, color: '#FFFFFF', name: "–ì–ª–∞–≤–Ω–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å", atkColor: '#FFFFFF' },
    { stage: 3, color: '#00FFFF', name: "–õ—É—á–µ–≤–∞—è '–≥–∞—Ä–º–æ–Ω–∏—è'", atkColor: '#00FFFF' },
    { stage: 4, color: '#1a1a1a', name: "–ß–µ—Ä–≤–æ—Ç–æ—á–∏–Ω–∞", atkColor: '#8A2BE2' }, 
    { stage: 5, color: '#FF0000', name: "–ö—Ä–∞—Å–Ω—ã–π –ì–∏–≥–∞–Ω—Ç", atkColor: '#FF0000' },
    { stage: 6, color: '#FFFFFF', name: "–°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–∞—è –ö—É–ª—å–º–∏–Ω–∞—Ü–∏—è", atkColor: '#000000', type: 'spectral' },
    { stage: 7, color: '#000000', name: "–ì—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–∞—è –ê–Ω–æ–º–∞–ª–∏—è", atkColor: '#111111', type: 'anomaly' },
    { stage: 8, color: '#F4A460', name: "–¢–û–ù 618", atkColor: '#F5DEB3', type: 'ton618' },
    { stage: 9, color: '#00BFFF', name: "–§–µ–Ω–∏–∫—Å –ê", atkColor: '#87CEEB', type: 'phoenix' },
    { stage: 10, color: '#D2B48C', name: "–°—Ç—Ä–∞–Ω–Ω—ã–π –∑–æ–Ω–¥", atkColor: '#FF0000', type: 'probe' },
    { stage: 11, color: '#FFD700', name: "–ö–æ—Ä–æ–ª—å –ó–≤—ë–∑–¥", atkColor: '#FFFFFF', type: 'starKing' },
    { stage: 12, color: '#32CD32', name: "–§–ª–æ—Ä–∞–Ω—Ç –ì–∏–≥–∞–Ω—Ç—Ä–∏—É—Å", atkColor: '#00FF00', type: 'florant' },
    { stage: 13, color: '#888888', name: "–û—Ö–æ—Ç–Ω–∏–∫ –ú–∏—Ä–æ–≤", atkColor: '#800080', type: 'hunter' }
];

const COUNTRIES = [
    { name: "Russia", score: 17125, type: 'stripes_h', colors: ['#fff', '#00f', '#f00'] },
    { name: "Canada", score: 9984, type: 'canada', colors: ['#f00', '#fff', '#f00'] },
    { name: "China", score: 9598, type: 'china', colors: ['#f00', '#ff0'] },
    { name: "USA", score: 9525, type: 'usa', colors: ['#b22234', '#fff', '#3c3b6e'] },
    { name: "Brazil", score: 8515, type: 'brazil', colors: ['#009c3b', '#ffdf00', '#002776'] },
    { name: "Australia", score: 7692, type: 'usa', colors: ['#00008b', '#fff', '#f00'] }, 
    { name: "India", score: 3287, type: 'stripes_h', colors: ['#ff9933', '#fff', '#138808'] },
    { name: "Argentina", score: 2780, type: 'stripes_h', colors: ['#75aadb', '#fff', '#75aadb'] },
    { name: "Kazakhstan", score: 2724, type: 'kazakh', colors: ['#00aec7', '#ffdf00'] },
    { name: "Algeria", score: 2381, type: 'bicolor_v', colors: ['#006633', '#fff'] },
    { name: "DR Congo", score: 2344, type: 'diag', colors: ['#007fff', '#fce300', '#ce1126'] },
    { name: "Saudi Arabia", score: 2149, type: 'bicolor_h', colors: ['#006C35', '#006C35'] },
    { name: "Mexico", score: 1964, type: 'stripes_v', colors: ['#006847', '#fff', '#ce1126'] },
    { name: "Indonesia", score: 1904, type: 'bicolor_h', colors: ['#f00', '#fff'] },
    { name: "Sudan", score: 1886, type: 'stripes_h', colors: ['#ce1126', '#fff', '#000'] },
    { name: "Libya", score: 1759, type: 'stripes_h', colors: ['#ce1126', '#000', '#007a3d'] },
    { name: "Iran", score: 1648, type: 'stripes_h', colors: ['#239f40', '#fff', '#da0000'] },
    { name: "Mongolia", score: 1564, type: 'stripes_v', colors: ['#da2032', '#0066ff', '#da2032'] },
    { name: "Peru", score: 1285, type: 'stripes_v', colors: ['#d91023', '#fff', '#d91023'] },
    { name: "Chad", score: 1284, type: 'stripes_v', colors: ['#002664', '#fecb00', '#c60c30'] },
    { name: "Niger", score: 1267, type: 'stripes_h', colors: ['#e05206', '#fff', '#0db02b'] },
    { name: "Angola", score: 1246, type: 'bicolor_h', colors: ['#ce1126', '#000'] },
    { name: "Mali", score: 1240, type: 'stripes_v', colors: ['#14b53a', '#fcd116', '#ce1126'] },
    { name: "South Africa", score: 1221, type: 'rsa', colors: ['#007749', '#000', '#fff', '#e03c31', '#001489', '#ffb81c'] },
    { name: "Colombia", score: 1141, type: 'stripes_h', colors: ['#fcd116', '#003893', '#ce1126'] },
    { name: "Ethiopia", score: 1104, type: 'stripes_h', colors: ['#009a44', '#fcd116', '#ef2b2d'] },
    { name: "Bolivia", score: 1098, type: 'stripes_h', colors: ['#ce1126', '#fcd116', '#007934'] },
    { name: "Mauritania", score: 1030, type: 'bicolor_h', colors: ['#006233', '#ce1126'] },
    { name: "Egypt", score: 1002, type: 'stripes_h', colors: ['#ce1126', '#fff', '#000'] },
    { name: "Tanzania", score: 947, type: 'diag', colors: ['#1eb53a', '#fcd116', '#000', '#00a3dd'] },
    { name: "Nigeria", score: 923, type: 'stripes_v', colors: ['#008751', '#fff', '#008751'] },
    { name: "Venezuela", score: 916, type: 'stripes_h', colors: ['#fce300', '#003da5', '#cf142b'] },
    { name: "Pakistan", score: 881, type: 'pakistan', colors: ['#fff', '#00401a'] },
    { name: "Turkey", score: 783, type: 'turkey', colors: ['#e30a17', '#fff'] },
    { name: "Chile", score: 756, type: 'chile', colors: ['#fff', '#d52b1e', '#0039a6'] },
    { name: "Zambia", score: 752, type: 'zambia', colors: ['#198a00', '#de2010', '#000', '#ef7d00'] },
    { name: "France", score: 640, type: 'stripes_v', colors: ['#0055a4', '#fff', '#ef4135'] },
    { name: "Ukraine", score: 603, type: 'bicolor_h', colors: ['#0057b7', '#ffd700'] },
    { name: "Spain", score: 505, type: 'stripes_h', colors: ['#aa151b', '#f1bf00', '#aa151b'] },
    { name: "Sweden", score: 450, type: 'nordic', colors: ['#006aa7', '#fecc00'] },
    { name: "Germany", score: 357, type: 'stripes_h', colors: ['#000', '#d00', '#ffce00'] },
    { name: "Finland", score: 338, type: 'nordic', colors: ['#fff', '#003580'] },
    { name: "Vietnam", score: 331, type: 'vietnam', colors: ['#da251d', '#ff0'] },
    { name: "Poland", score: 312, type: 'bicolor_h', colors: ['#fff', '#dc143c'] },
    { name: "Italy", score: 301, type: 'stripes_v', colors: ['#009246', '#fff', '#ce2b37'] },
    { name: "UK", score: 242, type: 'uk', colors: ['#012169', '#fff', '#c8102e'] },
    { name: "Belarus", score: 207, type: 'belarus', colors: ['#d22730', '#009739'] },
    { name: "Greece", score: 131, type: 'greece', colors: ['#0d5eaf', '#fff'] },
    { name: "Iceland", score: 103, type: 'nordic', colors: ['#02529c', '#dc1e35'] },
    { name: "South Korea", score: 100, type: 'skorea', colors: ['#fff', '#cd2e3a', '#0047a0', '#000'] }
];

const ABILITY_UPGRADES = {
    snowball: { name: '–°–Ω–µ–∂–æ–∫', desc: '–£—Ä–æ–Ω +1%, –†–∞–∑–º–µ—Ä +7.5%' },
    wave: { name: '–í–æ–ª–Ω–∞', desc: '–†–∞–∑–º–µ—Ä +7.5%, –°–∫–æ—Ä–æ—Å—Ç—å +5%' },
    moon: { name: '–°–ø—É—Ç–Ω–∏–∫', desc: '–£—Ä–æ–Ω +1%' }
};

const UPGRADES_DATA = { speed: { icon: '‚ö°' }, magnet: { icon: 'üß≤' }, grow: { icon: 'üí™' }, bonus: { icon: '‚≠ê' } };
const BOT_NAMES = ["Star", "Pro_Gamer", "NoobSlayer", "CosmoCat", "Void", "Nebula", "Quasar", "BlackHole", "Comet", "Orbit", "NASA", "SpaceX", "Alien", "Galaxy", "Solaris", "Astro", "Nova", "Phoenix", "Vortex", "Quantum", "Horizon", "Titan", "Daymix", "Sherlock Holmes", "Sherlock", "Holmes", "Pseudo Boss", "Ai", "Gemini", "Pulsar", "Magnetar", "EventHorizon", "Singularity", "Photon", "Graviton", "DarkMatter", "Antimatter", "Neutron", "Electron", "Proton", "Ion", "Plasma"];
const STARS_TYPES = [
    { color: '#FF0000', score: 1, chance: 0.35, scale: 0.5 },            
    { color: '#FFA500', score: 2, chance: 0.25, scale: 0.6 },     
    { color: '#FFFF00', score: 3, chance: 0.15, scale: 0.75 },     
    { color: '#FFFFE0', score: 4, chance: 0.10, scale: 1.0, glow: true }, 
    { color: '#FFFFFF', score: 5, chance: 0.07, scale: 1.2, glow: true }, 
    { color: '#E0FFFF', score: 7, chance: 0.05, scale: 1.5, glow: true }, 
    { color: '#00BFFF', score: 10, chance: 0.025, scale: 1.9, glow: true }, 
    { color: '#0000FF', score: 15, chance: 0.004, scale: 2.3, glow: true }, 
    { color: '#8A2BE2', score: 20, chance: 0.001, scale: 3.0, glow: true }  
];

const Top5Colors = ['#FFFF00', '#C0C0C0', '#B87333', '#50C878', '#40E0D0'];
const PastelColors = ['#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF', '#E6E6FA', '#F0E68C'];

function hexToRgb(hex) { let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : {r:0,g:0,b:0}; }
function rgbToHex(r, g, b) { r = Math.max(0, Math.min(255, Math.round(r))); g = Math.max(0, Math.min(255, Math.round(g))); b = Math.max(0, Math.min(255, Math.round(b))); return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1); }
function hexToRgbaStr(hex, alpha) { let c = hexToRgb(hex); return `rgba(${c.r},${c.g},${c.b},${alpha})`; }
function lerpColor(c1, c2, t) { return rgbToHex(c1.r + (c2.r - c1.r) * t, c1.g + (c2.g - c1.g) * t, c1.b + (c2.b - c1.b) * t); }
function adjustColor(hex, amount) { let usePound = false; if (hex[0] === "#") { hex = hex.slice(1); usePound = true; } let num = parseInt(hex, 16); let r = (num >> 16) + amount; if (r > 255) r = 255; else if (r < 0) r = 0; let b = ((num >> 8) & 0x00FF) + amount; if (b > 255) b = 255; else if (b < 0) b = 0; let g = (num & 0x0000FF) + amount; if (g > 255) g = 255; else if (g < 0) g = 0; return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0'); }
function interpolateColor(color1, color2, factor) { let c1 = hexToRgb(color1); let c2 = hexToRgb(color2); return rgbToHex(c1.r + factor * (c2.r - c1.r), c1.g + factor * (c2.g - c1.g), c1.b + factor * (c2.b - c1.b)); }
function randomColor() { return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'); }
function noise(x, y, seed) { let s = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453; return s - Math.floor(s); }
function smoothNoise(x, y, seed) { let xi = Math.floor(x), yi = Math.floor(y), xf = x - xi, yf = y - yi, u = xf * xf * (3 - 2 * xf), v = yf * yf * (3 - 2 * yf), n00 = noise(xi, yi, seed), n10 = noise(xi+1, yi, seed), n01 = noise(xi, yi+1, seed), n11 = noise(xi+1, yi+1, seed), x1 = n00 + (n10 - n00) * u, x2 = n01 + (n11 - n01) * u; return x1 + (x2 - x1) * v; }

const AssetManager = {
    starCanvases: {},
    noiseCanvases: [],
    rainbowPattern: null,
    moonTexture: null,
    init() { 
        STARS_TYPES.forEach((t, i) => { this.starCanvases[i] = this.createStarTexture(t); }); 
        for(let i=0; i<3; i++) this.noiseCanvases.push(this.createNoiseTexture(100, i));
        this.createRainbowTexture();
        this.createMoonTexture();
    },
    createRainbowTexture() {
        const c = document.createElement('canvas'); c.width = 256; c.height = 256;
        const ctx = c.getContext('2d');
        for(let i=0; i<5000; i++) {
            ctx.fillStyle = `hsl(${Math.random()*360}, 100%, 50%)`;
            ctx.fillRect(Math.random()*256, Math.random()*256, 4, 4);
        }
        this.rainbowPattern = c;
    },
    createMoonTexture() {
        const s = 32; const c = document.createElement('canvas'); c.width=s; c.height=s;
        const ctx = c.getContext('2d');
        ctx.fillStyle = "#888888"; ctx.beginPath(); ctx.arc(s/2, s/2, s/2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#555555"; 
        for(let i=0; i<5; i++) {
            let r = 2+Math.random()*3;
            ctx.beginPath(); ctx.arc(Math.random()*s, Math.random()*s, r, 0, Math.PI*2); ctx.fill();
        }
        ctx.beginPath(); ctx.arc(s/2, s/2, s/2, 0, Math.PI*2); ctx.lineWidth=2; ctx.strokeStyle="rgba(0,0,0,0.3)"; ctx.stroke();
        this.moonTexture = c;
    },
    createStarTexture(type) {
        const size = Math.max(8, 16 * type.scale); const c = document.createElement('canvas'); c.width = size; c.height = size;
        const ctx = c.getContext('2d'); const cx = size/2, cy = size/2, r = size/2;
        ctx.fillStyle = type.color; if(type.glow) { ctx.shadowBlur = 5; ctx.shadowColor = type.color; }
        ctx.beginPath(); ctx.moveTo(cx, cy - r); ctx.quadraticCurveTo(cx, cy, cx + r, cy); ctx.quadraticCurveTo(cx, cy, cx, cy + r); ctx.quadraticCurveTo(cx, cy, cx - r, cy); ctx.quadraticCurveTo(cx, cy, cx, cy - r); ctx.fill();
        return c;
    },
    createNoiseTexture(size, seed) {
        const c = document.createElement('canvas'); c.width = size; c.height = size; const ctx = c.getContext('2d');
        const id = ctx.createImageData(size, size);
        for (let i=0; i<id.data.length; i+=4) {
            if (Math.random() < 0.5) { id.data[i] = 255; id.data[i+1] = 255; id.data[i+2] = 255; id.data[i+3] = 150; } else { id.data[i+3] = 0; }
        }
        ctx.putImageData(id, 0, 0); return c;
    },
    getPlanetTexture(conf, radius, seed) {
        if (!Number.isFinite(radius) || radius < 1) radius = 10;
        const size = Math.ceil(radius * 2); const c = document.createElement('canvas'); c.width = size; c.height = size; const ctx = c.getContext('2d'); const cx = size/2, cy = size/2;
        
        if (conf.type === 'probe') { 
            const pixelSize = Math.max(2, Math.floor(radius / 15)); const rSq = radius * radius;
            for(let y = 0; y < size; y += pixelSize) {
                for(let x = 0; x < size; x += pixelSize) {
                    let dx = x - cx + pixelSize/2, dy = y - cy + pixelSize/2;
                    let d = Math.sqrt(dx*dx + dy*dy);
                    if(d > radius) continue;
                    let col = "#D2B48C"; // Tan center
                    if (d > radius * 0.6 && d < radius * 0.75) col = "#00BFFF"; // Blue ring
                    if (d < radius * 0.15) col = "#00BFFF"; // Blue eye center
                    
                    let noiseVal = Math.floor(Math.random() * 20) - 10; 
                    try { ctx.fillStyle = adjustColor(col, noiseVal); } catch(e) { ctx.fillStyle = col; }
                    ctx.fillRect(x, y, pixelSize, pixelSize);
                }
            }
            ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.lineWidth = 3; ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.stroke();
            return c;
        }
        if (conf.countryType) {
             const colors = conf.colors || ['#fff'];
             ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.clip();
             if (conf.countryType === 'stripes_h') {
                 const h = size / colors.length;
                 colors.forEach((col, i) => { ctx.fillStyle = col; ctx.fillRect(0, i*h, size, h); });
             } else if (conf.countryType === 'stripes_v') {
                 const w = size / colors.length;
                 colors.forEach((col, i) => { ctx.fillStyle = col; ctx.fillRect(i*w, 0, w, size); });
             } else if (conf.countryType === 'bicolor_h') {
                 ctx.fillStyle = colors[0]; ctx.fillRect(0,0,size,size/2);
                 ctx.fillStyle = colors[1]; ctx.fillRect(0,size/2,size,size/2);
             } else if (conf.countryType === 'bicolor_v') {
                 ctx.fillStyle = colors[0]; ctx.fillRect(0,0,size/2,size);
                 ctx.fillStyle = colors[1]; ctx.fillRect(size/2,0,size/2,size);
             } else if (conf.countryType === 'canada') {
                 ctx.fillStyle = colors[0]; ctx.fillRect(0,0,size/4,size); ctx.fillRect(size*0.75,0,size/4,size);
                 ctx.fillStyle = colors[1]; ctx.fillRect(size/4,0,size/2,size);
                 ctx.fillStyle = colors[2]; ctx.beginPath(); ctx.arc(cx, cy, radius*0.3, 0, Math.PI*2); ctx.fill();
             } else if (conf.countryType === 'china') {
                 ctx.fillStyle = colors[0]; ctx.fillRect(0,0,size,size);
                 ctx.fillStyle = colors[1]; ctx.beginPath(); ctx.arc(cx - radius*0.4, cy - radius*0.4, radius*0.15, 0, Math.PI*2); ctx.fill();
             } else if (conf.countryType === 'usa') {
                 for(let i=0; i<13; i++) { ctx.fillStyle = (i%2===0)?colors[1]:colors[0]; ctx.fillRect(0, i*(size/13), size, size/13); }
                 ctx.fillStyle = colors[2]; ctx.beginPath(); ctx.arc(cx, cy, radius*0.4, 0, Math.PI*2); ctx.fill();
             } else if (conf.countryType === 'brazil') {
                 ctx.fillStyle = colors[0]; ctx.fillRect(0,0,size,size);
                 ctx.fillStyle = colors[1]; ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(size, cy); ctx.lineTo(cx, size); ctx.lineTo(0, cy); ctx.fill();
                 ctx.fillStyle = colors[2]; ctx.beginPath(); ctx.arc(cx, cy, radius*0.35, 0, Math.PI*2); ctx.fill();
             } else if (conf.countryType === 'spanish_empire') {
                 ctx.fillStyle = '#fff'; ctx.fillRect(0,0,size,size);
                 ctx.strokeStyle = '#f00'; ctx.lineWidth = radius*0.3;
                 ctx.beginPath(); ctx.moveTo(radius*0.4, radius*0.4); ctx.lineTo(size-radius*0.4, size-radius*0.4); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(size-radius*0.4, radius*0.4); ctx.lineTo(radius*0.4, size-radius*0.4); ctx.stroke();
             } else if (conf.countryType === 'ussr') {
                 ctx.fillStyle = '#f00'; ctx.fillRect(0,0,size,size);
                 ctx.fillStyle = '#ff0'; ctx.font = `bold ${radius}px serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('‚ò≠', cx, cy);
             } else if (conf.countryType === 'russian_empire') {
                 const curCols = conf.reState ? ['#fff', '#00f', '#f00'] : ['#000', '#ff0', '#fff'];
                 const h = size / 3;
                 curCols.forEach((col, i) => { ctx.fillStyle = col; ctx.fillRect(0, i*h, size, h); });
             } else if (conf.countryType === 'mongol_empire') {
                 ctx.fillStyle = '#1a237e'; ctx.fillRect(0,0,size,size);
                 ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.arc(cx, cy, radius*0.5, 0, Math.PI*2); ctx.fill();
             } else if (conf.countryType === 'british_empire') {
                 ctx.fillStyle = '#012169'; ctx.fillRect(0,0,size,size);
                 ctx.strokeStyle = '#fff'; ctx.lineWidth = radius*0.3; 
                 ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(size,size); ctx.moveTo(size,0); ctx.lineTo(0,size); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(cx,0); ctx.lineTo(cx,size); ctx.moveTo(0,cy); ctx.lineTo(size,cy); ctx.stroke();
                 ctx.strokeStyle = '#c8102e'; ctx.lineWidth = radius*0.15;
                 ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(size,size); ctx.moveTo(size,0); ctx.lineTo(0,size); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(cx,0); ctx.lineTo(cx,size); ctx.moveTo(0,cy); ctx.lineTo(size,cy); ctx.stroke();
             } else {
                                  ctx.fillStyle = colors[0]; ctx.fillRect(0,0,size,size);
             }
             ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.lineWidth = 3; ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.stroke();
             return c;
        }

        const pixelSize = Math.max(2, Math.floor(radius / 15)); const rSq = radius * radius;
        const c1 = hexToRgb(conf.color); const c2 = hexToRgb(conf.detail);
        
        if (conf.id === 'tts16a') {
            ctx.fillStyle = "#FF0000"; ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.fill();
            for(let y = 0; y < size; y += pixelSize) {
                for(let x = 0; x < size; x += pixelSize) {
                    let dx = x - cx + pixelSize/2, dy = y - cy + pixelSize/2;
                    if(dx*dx + dy*dy > rSq) continue;
                    let n = smoothNoise(x/size * 4, y/size * 4, seed);
                    if (n > 0.5) { ctx.fillStyle = "#00FF00"; ctx.fillRect(x, y, pixelSize, pixelSize); }
                }
            }
            const stripH = radius * 0.4;
            ctx.fillStyle = "#FFFFFF"; ctx.fillRect(0, cy - stripH/6, size, stripH/3);
            ctx.fillStyle = "#00FF00"; ctx.fillRect(0, cy - stripH/2, size, stripH/3);
            ctx.fillStyle = "#FF0000"; ctx.fillRect(0, cy + stripH/6, size, stripH/3);
            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
            ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.lineWidth = 3; ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.stroke();
            return c;
        }

        for(let y = 0; y < size; y += pixelSize) {
            for(let x = 0; x < size; x += pixelSize) {
                let dx = x - cx + pixelSize/2, dy = y - cy + pixelSize/2;
                if(dx*dx + dy*dy > rSq) continue;
                let col = conf.color; 
                if (conf.type === 1) { 
                    let ny = (y / size) * 10 + seed; 
                    if(Math.sin(ny) > 0.2) col = conf.detail; 
                    else if (Math.sin(ny * 2.5) > 0.8) col = lerpColor(c1, c2, 0.5); 
                } 
                else if (conf.type === 2) { let n = smoothNoise(x/size * 5, y/size * 5, seed); if(n > 0.55) col = conf.detail; }
                else if (conf.type === 3 || conf.type === 'ton618' || conf.type === 'phoenix' || conf.type === 'starKing' || conf.type === 'florant' || conf.type === 'hunter') { let n = noise(x/10, y/10, seed); let f = 0.8 + n * 0.4; col = rgbToHex(c1.r*f, c1.g*f, c1.b*f); }
                let noiseVal = Math.floor(Math.random() * 30) - 15; try { ctx.fillStyle = adjustColor(col, noiseVal); } catch(e) { ctx.fillStyle = col; }
                ctx.fillRect(x, y, pixelSize, pixelSize);
            }
        }
        if (conf.type === 1) {
             const stripeColor = (conf.id === 'jupiter') ? '#FFFFFF' : adjustColor(conf.color, 40);
             const secondaryAlpha = (conf.id === 'jupiter') ? 0.4 : (0.5 + Math.random()*0.5);
             const thinPixelSize = Math.max(1, pixelSize/2);
             for(let y = 0; y < size; y += pixelSize) {
                  let ny = (y / size) * 20 + seed + 2.5; 
                  if(Math.sin(ny) > 0.9) {
                       for(let x = 0; x < size; x += thinPixelSize) {
                           let dx = x - cx + thinPixelSize/2, dy = y - cy + thinPixelSize/2;
                           if(dx*dx + dy*dy > rSq) continue;
                           ctx.fillStyle = hexToRgbaStr(stripeColor, secondaryAlpha);
                           ctx.fillRect(x, y, thinPixelSize, thinPixelSize);
                       }
                  }
             }
        }
        ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.lineWidth = 3; ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.stroke(); return c;
    },
    getProjectileTexture(color, radius, seed, typeStr) {
        const size = Math.ceil(radius * 2); const c = document.createElement('canvas'); c.width = size; c.height = size; const ctx = c.getContext('2d'); const cx = size/2, cy = size/2, rSq = radius * radius;
        if (typeStr === 'tts16a') {
            ctx.fillStyle = "#FF0000"; ctx.beginPath(); ctx.arc(cx, cy, radius, Math.PI, 0); ctx.fill();
            ctx.fillStyle = "#00FF00"; ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI); ctx.fill();
            ctx.fillStyle = "#FFFFFF"; ctx.fillRect(0, cy - radius*0.1, size, radius*0.2);
            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.fill();
            return c;
        }
        if (typeStr === 'star') {
             ctx.fillStyle = color;
             ctx.shadowBlur = 5; ctx.shadowColor = color;
             ctx.beginPath();
             for(let i=0; i<5; i++) {
                 ctx.lineTo(cx + Math.cos((18+i*72)/180*Math.PI)*radius, cy + Math.sin((18+i*72)/180*Math.PI)*radius);
                 ctx.lineTo(cx + Math.cos((54+i*72)/180*Math.PI)*(radius/2), cy + Math.sin((54+i*72)/180*Math.PI)*(radius/2));
             }
             ctx.closePath(); ctx.fill();
             return c;
        }
        const pixelSize = Math.max(2, Math.floor(radius / 6)); 
        for(let y = 0; y < size; y += pixelSize) {
            for(let x = 0; x < size; x += pixelSize) {
                let dx = x - cx + pixelSize/2, dy = y - cy + pixelSize/2;
                if(dx*dx + dy*dy > rSq) continue;
                let noiseVal = Math.floor(Math.random() * 40) - 20; try { ctx.fillStyle = adjustColor(color, noiseVal); } catch(e) { ctx.fillStyle = color; }
                ctx.fillRect(x, y, pixelSize, pixelSize);
            }
        }
        return c;
    },
    getShieldTexture(radius) {
        const size = Math.ceil(radius * 2.3); const c = document.createElement('canvas'); c.width = size; c.height = size; const ctx = c.getContext('2d');
        const cx=size/2, cy=size/2, rSq=radius*radius;
        ctx.fillStyle = "rgba(0, 191, 255, 0.45)"; 
        const pixelSize = Math.max(2, Math.floor(radius/10)); 
        for(let y = 0; y < size; y += pixelSize) {
            for(let x = 0; x < size; x += pixelSize) {
                let dx=x-cx, dy=y-cy; if(dx*dx+dy*dy>rSq) continue;
                if(Math.random()<0.3) ctx.fillStyle="rgba(0,191,255,0.6)"; else ctx.fillStyle="rgba(0,150,255,0.3)";
                ctx.fillRect(x,y,pixelSize,pixelSize);
            }
        }
        return c;
    },
    getShadingOverlay(radius) {
        const size = Math.ceil(radius * 2); const c = document.createElement('canvas'); c.width = size; c.height = size; const ctx = c.getContext('2d');
        let grd = ctx.createLinearGradient(size, 0, 0, size); grd.addColorStop(0, "rgba(255,255,255,0.2)"); grd.addColorStop(0.4, "rgba(0,0,0,0)"); grd.addColorStop(1, "rgba(0,0,0,0.6)");       
        ctx.beginPath(); ctx.arc(size/2, size/2, radius, 0, Math.PI*2); ctx.fillStyle = grd; ctx.fill(); return c;
    }
};

class FloatingText {
    constructor(x, y, text, color) { this.x = x; this.y = y; this.text = text; this.color = color; this.life = 1.0; this.vy = -50; }
    update(dt) { this.x += this.vy * dt * 0.2; this.y += this.vy * dt; this.life -= dt; }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas'); this.ctx = this.canvas.getContext('2d');
        this.miniCanvas = document.getElementById('minimapCanvas'); this.miniCtx = this.miniCanvas.getContext('2d');
        AssetManager.init();
        this.active = false; this.paused = false; this.isMobile = false; this.difficulty = 1; 
        this.cam = { x: 0, y: 0, z: 2.25 };
        this.entities = []; this.stars = []; this.items = []; this.snowballs = []; this.floatingTexts = []; this.player = null;
        this.mouse = { x: 0, y: 0, down: false };
        this.joystick = { dx: 0, dy: 0, active: false };
        this.aimJoy = { dx: 0, dy: 0, active: false };
        this.isSprinting = false; 
        this.zoneRadius = CONFIG.mapSize;
        this.lastTime = 0; this.starSpawnTimer = 0; this.fpsTimer = 0; this.bossStage = 1; this.bossTimer = 0;
        this.gameTime = 0; this.botRespawnTimer = 0; 
        this.gameOverSequence = false; this.gameOverTimer = 0;
        // Added: passiveScorePlayer, passiveScoreBot, vacuumMult, ruleImmunity, weaponDmg
        this.mod = { botScore: 1, bossScore: 1, botCount: 40, mapSize: true, immunity: 0, playerScore: 1.0, playerDmg: 1.0, customMapSize: 5700, passiveScorePlayer: 0, passiveScoreBot: 0, vacuumMult: 1.0, ruleImmunity: false, weaponDmg: 1.0 };
        this.modeSettings = { secondChance: true, bossRush: false, pseudoMulti: false, disableEvents: false };
        this.arenaMode = null; 
        this.arenaEventTimer = 0;
        this.currentArenaEvent = "";
        this.zoneDamageMultiplier = 1.0;
        this.pseudoMultiTimer = 0;
        this.nextBossPos = { x: 0, y: 0 };
        this.survivalTimer = 0;
        this.randomIntroTimer = 0;
        this.zombieSplitTimer = 0;
        this.waveCount = 0;
        this.waveTimer = 0;
        this.resize(); window.addEventListener('resize', () => this.resize());
        window.addEventListener('mousemove', e => { if(!this.isMobile) { this.mouse.x = e.clientX - window.innerWidth / 2; this.mouse.y = e.clientY - window.innerHeight / 2; } });
        window.addEventListener('mousedown', (e) => { 
            if(!this.isMobile && e.button === 0) {
                this.mouse.down = true;
                if(this.player && !this.paused) {
                    if (this.player.lightStripActive) {
                        this.player.fireLightStrip();
                    } else if (this.player.blueStripActive) {
                        this.player.fireBlueStrip();
                    } else {
                        this.setSprinting(true); 
                    }
                }
            }
        });
        window.addEventListener('mouseup', (e) => { if(!this.isMobile && e.button === 0) { this.mouse.down = false; this.setSprinting(false); } });
        window.addEventListener('contextmenu', e => e.preventDefault());
        window.addEventListener('keydown', e => { if(e.code === 'Space') this.activateItem(); });
        this.initJoystick('joystick', 'knob', this.joystick);
        this.initJoystick('aimJoystick', 'aimKnob', this.aimJoy, true);
        this.menuLoop();
    }
    setSprinting(val) { this.isSprinting = val; }
    initJoystick(areaId, knobId, joyObj, isAim = false) {
        const area = document.getElementById(areaId), knob = document.getElementById(knobId);
        const handleMove = (cx, cy) => {
            const rect = area.getBoundingClientRect();
            let dx = cx - (rect.left + rect.width/2), dy = cy - (rect.top + rect.height/2);
            const dist = Math.hypot(dx, dy), max = rect.width/2; 
            if (dist > max) { dx *= max/dist; dy *= max/dist; }
            knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            joyObj.dx = dx/max; joyObj.dy = dy/max;
        };
        const reset = () => { 
            if (isAim && joyObj.active && (Math.abs(joyObj.dx) > 0.2 || Math.abs(joyObj.dy) > 0.2)) {
                if (this.player) this.player.fireSnowball(joyObj.dx * 1000, joyObj.dy * 1000);
            }
            knob.style.transform = `translate(-50%, -50%)`; joyObj.dx=0; joyObj.dy=0; joyObj.active=false; 
            if(isAim) knob.classList.remove('auto-aim');
        };
        area.addEventListener('touchstart', e => { joyObj.active=true; handleMove(e.touches[0].clientX, e.touches[0].clientY); e.preventDefault(); }, {passive:false});
        area.addEventListener('touchmove', e => { if(joyObj.active) handleMove(e.touches[0].clientX, e.touches[0].clientY); e.preventDefault(); }, {passive:false});
        area.addEventListener('touchend', e => { reset(); e.preventDefault(); });
        area.addEventListener('mousedown', e => { joyObj.active=true; handleMove(e.clientX, e.clientY); e.preventDefault(); });
        window.addEventListener('mousemove', e => { if(joyObj.active) handleMove(e.clientX, e.clientY); });
        window.addEventListener('mouseup', e => { if(joyObj.active) { reset(); } });
    }
    resize() { 
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = window.innerWidth * dpr; 
        this.canvas.height = window.innerHeight * dpr; 
        this.canvas.style.width = window.innerWidth + 'px';
        this.canvas.style.height = window.innerHeight + 'px';
        this.ctx.resetTransform();
        this.ctx.scale(dpr, dpr);
        this.miniCanvas.width = 150; 
        this.miniCanvas.height = 150; 
    }

    start(isMobile, difficulty) {
        this.isMobile = isMobile;
        this.difficulty = difficulty;
        this.arenaMode = ui.tempArenaMode || null; 
        ui.tempArenaMode = null;
        this.paused = false;

        ui.loadHudSettings(); 
        document.getElementById('modeScreen').style.display = 'none';
        document.getElementById('difficultyScreen').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('modifierScreen').style.display = 'none';
        document.getElementById('ui-layer').style.display = 'block';
        document.getElementById('bossHud').style.display = 'block';
        document.getElementById('gameOverScreen').className = ''; 
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('frozenHud').style.display = 'none';
        document.getElementById('pauseMenu').style.display = 'none';
        document.getElementById('survivalTimer').style.display = 'none';

        if (this.isMobile) { 
            document.body.classList.add('mobile-layout');
            document.getElementById('mobile-controls').style.display = 'block'; 
            document.getElementById('pc-inventory').style.display = 'none';
            document.getElementById('invToggle').style.display = 'none';
            document.getElementById('joystick').style.display = 'block';
            document.querySelector('.mob-wep-toggle').style.display = 'flex';
            document.getElementById('abilityGroup').classList.add('hidden-mobile'); 
                        document.getElementById('aimJoystick').style.display = 'block';
        } else { 
            document.body.classList.remove('mobile-layout');
            document.getElementById('mobile-controls').style.display = 'none'; 
            document.getElementById('invToggle').style.display = 'flex';
            document.getElementById('pc-inventory').style.display = 'none'; 
            document.getElementById('joystick').style.display = 'none'; 
            document.querySelector('.mob-wep-toggle').style.display = 'none';
            document.getElementById('abilityGroup').classList.remove('hidden-mobile');
                        document.getElementById('aimJoystick').style.display = 'block';
        }
        
        this.active = true; this.gameOverSequence = false;
        this.entities = []; this.stars = []; this.items = []; this.snowballs = []; this.floatingTexts = [];
        this.zoneRadius = this.mod.mapSize ? CONFIG.mapSize : this.mod.customMapSize; 
        
        if (this.arenaMode === 'duel' || this.arenaMode === 'mini' || this.arenaMode === 'arena' || this.arenaMode === '5vs1') {
             this.zoneRadius = CONFIG.mapSize * 1.5;
        }
        if (this.arenaMode === 'team') {
             this.zoneRadius = CONFIG.mapSize / 3;
        }
        if (this.arenaMode === 'survival_random') {
             this.survivalTimer = 15;
             this.zoneRadius = 3000;
             document.getElementById('survivalTimer').style.display = 'block';
        }
        if (this.arenaMode === 'random_start') {
             this.randomIntroTimer = 5.0;
             this.zoneRadius = 500 + Math.random() * 9500;
             this.currentMaxBots = 3 + Math.floor(Math.random()*97);
             this.mod.botScore = 1.0; 
             this.mod.bossScore = 0.33 + Math.random() * 2.67;
        }
        if (this.arenaMode === 'agility') {
             this.zoneRadius = 2000;
        }
        if (this.arenaMode === '5vs1') {
             this.zoneRadius = CONFIG.mapSize / 2;
             this.survivalTimer = 180;              document.getElementById('survivalTimer').style.display = 'block';
        }
        if (this.arenaMode === 'save_life') {
             this.zoneRadius = CONFIG.mapSize;
             this.waveCount = 0;
             this.waveTimer = 10; 
             this.survivalTimer = 180; 
             document.getElementById('survivalTimer').style.display = 'block';
        }

        this.bossStage = 1; 
        this.zoneDamageMultiplier = 1.0;
        this.zoneTimer = (this.arenaMode === 'team') ? 30 : 10; 
        this.arenaEventTimer = 15 + Math.random()*15;
        this.currentArenaEvent = "";
        document.getElementById('arenaEventDisplay').style.display = 'none';

        let bossTimeBase = 30;
        if(this.difficulty===0) bossTimeBase /= 3; 
        else if (this.difficulty===1) bossTimeBase /= 2;
        else if (this.difficulty===3) bossTimeBase *= 1.25;
        else if (this.difficulty===4) bossTimeBase *= 1.75;
        if(this.modeSettings.bossRush) bossTimeBase = 10;
        
        if(this.arenaMode) {
            if(this.arenaMode === 'royal') this.zoneRadius = CONFIG.mapSize * 1.4;
            if(this.arenaMode === 'mini') { this.currentMaxBots = 0; bossTimeBase = 0; }
            else if(this.arenaMode === 'duel') { this.currentMaxBots = 1; bossTimeBase = 30; }
            else if(this.arenaMode === 'arena') { this.currentMaxBots = 9; }
            else if(this.arenaMode === 'royal') { this.currentMaxBots = 99; bossTimeBase = 30; }
            else if(this.arenaMode === 'team') { this.currentMaxBots = 19; bossTimeBase = 60; }
            else if(this.arenaMode === 'survival_random') { this.currentMaxBots = 40; bossTimeBase = 45; }
            else if(this.arenaMode === 'agility') { this.currentMaxBots = 1; bossTimeBase = 999999; }
            else if(this.arenaMode === '5vs1') { this.currentMaxBots = 5; bossTimeBase = 999999; }
            else if(this.arenaMode === 'zombie') { this.currentMaxBots = 24; bossTimeBase = 999999; this.zombieSplitTimer = 60; }
            else if(this.arenaMode === 'all_vs_one') { this.currentMaxBots = 40; bossTimeBase = 40; }
            else if(this.arenaMode === 'countryballs') { this.currentMaxBots = 39; bossTimeBase = 30; }
            else if(this.arenaMode === 'save_life') { this.currentMaxBots = 9; bossTimeBase = 999999; }
        } else if (this.arenaMode !== 'random_start') {
            this.currentMaxBots = Math.floor(this.mod.botCount);
        }
        
        this.bossTimer = bossTimeBase;
        this.nextBossPos = (this.arenaMode === 'team' || this.arenaMode === '5vs1') ? {x:0, y:0} : {x: (Math.random()-0.5)*this.zoneRadius, y: (Math.random()-0.5)*this.zoneRadius};
        
        this.activeBoss = null; 
        this.spinCooldown = 0; this.starSpawnTimer = 0; this.matchSpeedFactor = 0.95 + Math.random() * 0.1; 
        this.gameTime = 0; this.botRespawnTimer = 0;

        let pData = PLANETS.find(p => p.id === ui.data.planet);
        if(this.arenaMode === 'countryballs') {
            const c = COUNTRIES[Math.floor(Math.random()*COUNTRIES.length)];
                        pData = { ...pData, id: 'custom', name: c.name, score: Math.max(49, c.score), countryType: c.type, colors: c.colors };
        }
        this.player = new Entity(0, 0, pData, true, ui.data.name || "Player", ui.data.color);
        if (this.arenaMode === 'countryballs') this.player.score = pData.score;

        if (this.arenaMode === 'team') {
            const isRed = Math.random() < 0.5;
            this.player.team = isRed ? 'red' : 'blue';
            this.player.nameColorOverride = isRed ? '#ff4444' : '#4444ff';
            this.player.x = isRed ? -this.zoneRadius/2 : this.zoneRadius/2; 
        }
        if (this.arenaMode === 'agility') {
             this.player.x = 0; this.player.y = 0;
             const enemy = new Entity(500, 500, PLANETS[Math.floor(Math.random()*PLANETS.length)], false, "The Wall");
             enemy.score = 20000; enemy.radius *= 1.5; enemy.isAgilityBoss = true;
             enemy.activeEffects.magnet = 99999; enemy.magnetRadiusMult = 1.2;
             this.entities.push(enemy);
             this.currentMaxBots = 1; 
        }
        if (this.arenaMode === '5vs1') {
             const isPlayerBig = Math.random() < 0.3;
             if (isPlayerBig) {
                 this.player.score = 2000; this.player.isBigBoss = true; ui.notify("–í–´ –ë–û–°–°!");
             }
        }
        if (this.arenaMode === 'zombie') {
             this.player.isSurvivor = true;
             this.player.nameColorOverride = '#0f0';
        }
        if (this.arenaMode === 'save_life') {
             this.player.team = 'blue';
             this.player.isSurvivor = true;
             this.player.x = 200; 
                          const core = new Entity(0,0, PLANETS.find(x=>x.id==='earth'), false, "CORE");
             core.score = 10000; core.isCentralCore = true; core.team = 'blue'; core.radius *= 1.5;
             this.entities.push(core);
        }

        this.entities.push(this.player);
        
        if (this.arenaMode !== 'agility' && this.arenaMode !== '5vs1' && this.arenaMode !== 'save_life') {
             for(let i=0; i<this.currentMaxBots; i++) this.spawnBot();
        } else if (this.arenaMode === '5vs1') {
             for(let i=0; i<5; i++) this.spawnBot();
        } else if (this.arenaMode === 'save_life') {
             for(let i=0; i<9; i++) this.spawnBot();         }
        
        let sCount = CONFIG.maxStars;
        if (this.arenaMode === 'random_start') sCount = 500 + Math.random()*19500;
        if(this.arenaMode && this.arenaMode !== 'royal' && this.arenaMode !== 'random_start') sCount = Math.floor(CONFIG.maxStars / 1.5);
        if(this.arenaMode === 'team') sCount = Math.floor(CONFIG.maxStars * 1.2);
        if(this.arenaMode === 'agility') sCount = 200;
        if(this.arenaMode === '5vs1') sCount = 500;
        
        for(let i=0; i<sCount; i++) this.spawnStarGlobal(); 
        for(let i=0; i<CONFIG.itemCount; i++) this.spawnItem();
        
        this.lastTime = performance.now();
        requestAnimationFrame(t => this.loop(t));
        ui.updateInventoryDisplay();
    }
    useWave() { if(this.active && this.player && !this.paused) this.player.useWave(); }
    useMoon() { if(this.active && this.player && !this.paused) this.player.spawnMoon(); }
    useGreatImpact() { if(this.active && this.player && !this.paused) this.player.useGreatImpact(); }
    useRay() { if(this.active && this.player && !this.paused) this.player.useRay(); }
    useGravityManeuver() { if(this.active && this.player && !this.paused) this.player.useGravityManeuver(); }
    useShield() { if(this.active && this.player && !this.paused) this.player.activateShield(); }
    useIceSword() { if(this.active && this.player && !this.paused) this.player.activateIceSword(); }
    useBlueBullet() { if(this.active && this.player && !this.paused) this.player.fireBlueBullet(); }
    useVampire() { if(this.active && this.player && !this.paused) this.player.fireVampire(); }
    toggleLightStrip() { if(this.active && this.player && !this.paused) this.player.toggleLightStrip(); }
    toggleBlueStrip() { if(this.active && this.player && !this.paused) this.player.toggleBlueStrip(); }
    
    spawnBot() {
        if (this.arenaMode === 'agility') return;
        if (this.arenaMode === '5vs1' && this.entities.length > 6) return;

                if (this.arenaMode === 'save_life' && this.entities.filter(e=>e.team==='blue').length >= 11) return;

        const isAnomaly = (!this.arenaMode || ['arena','royal','team'].includes(this.arenaMode)) && Math.random() < 0.05; 
        
        const isRocky = Math.random() < 0.6;
        let type = isRocky ? (Math.random()<0.2?1:(Math.random()<0.7?2:4)) : (Math.random()<0.5?1:3);
        let c1, c2, name;
        
        if (isAnomaly) {
            const ac = ['#FFA500', '#FF69B4', '#8A2BE2'][Math.floor(Math.random()*3)];
            c1 = ac; c2 = '#fff'; name = "–ê–Ω–æ–º–∞–ª–∏—è";
        } else {
            c1 = randomColor(); c2 = randomColor(); name = BOT_NAMES[Math.floor(Math.random()*BOT_NAMES.length)];
        }
        
        let conf = { color: c1, detail: c2, type: type, hasRing: (Math.random() < 0.33) };
        
        if (this.arenaMode === 'countryballs') {
            let usedNames = this.entities.map(e => e.name);
            let avail = COUNTRIES.filter(c => !usedNames.includes(c.name));
            if (avail.length === 0) avail = COUNTRIES; 
            const c = avail[Math.floor(Math.random() * avail.length)];
            conf = { ...conf, countryType: c.type, colors: c.colors, id: 'custom' };
            name = c.name;
        }

        const e = new Entity((Math.random()-0.5)*this.zoneRadius*1.5, (Math.random()-0.5)*this.zoneRadius*1.5, conf, false, name);
        if(!this.arenaMode) e.score *= this.mod.botScore;

        if (this.arenaMode === 'countryballs') {
            const cData = COUNTRIES.find(c => c.name === name);
                        if(cData) e.score = Math.max(49, cData.score);
        }
        
        if (isAnomaly) {
            e.isAnomalyBot = true;
            // Anomaly Overhaul: 15x Score Bonus
            e.score = (50 + Math.random()*100) * 15;
            e.nameColorOverride = '#EE82EE'; // Violet/Lilac
            // Anomaly Overhaul: x3 Vacuum
            e.magnetRadiusMult = 3.0; 
        }

        if(this.arenaMode === 'team') {
            const isRed = Math.random() < 0.5;
            e.team = isRed ? 'red' : 'blue';
            e.nameColorOverride = isRed ? '#ff4444' : '#4444ff';
            if (this.zoneTimer > 0) {
                e.x = isRed ? -(Math.random()*this.zoneRadius/2 + 100) : (Math.random()*this.zoneRadius/2 + 100);
            }
        }

        if (this.arenaMode === '5vs1') {
            const existingBig = this.entities.find(ent => ent.isBigBoss);
            if (!this.player.isBigBoss && !existingBig) {
                 e.isBigBoss = true; e.score = 2000; e.name = "BOSS"; e.activeEffects.speed = 9999;
                 e.x = 0; e.y = 0;             } else {
                                const big = this.entities.find(ent => ent.isBigBoss) || this.player;
                let ang = Math.random() * Math.PI * 2;
                e.x = big.x + Math.cos(ang) * (big.radius + 600); 
                e.y = big.y + Math.sin(ang) * (big.radius + 600);
            }
        }

        if (this.arenaMode === 'zombie') {
             const zombies = this.entities.filter(z => z.isZombie).length;
             if (zombies < 5) {
                 e.makeZombie();
             } else {
                 e.isSurvivor = true;
                 e.nameColorOverride = '#0f0';
             }
        }

        if (this.arenaMode === 'save_life') {
            e.team = 'blue'; e.nameColorOverride = '#00f'; e.isSurvivor = true;
        }

        if (Math.hypot(e.x, e.y) > this.zoneRadius) {
             let ang = Math.atan2(e.y, e.x);
             e.x = Math.cos(ang)*this.zoneRadius*0.9;
             e.y = Math.sin(ang)*this.zoneRadius*0.9;
        }
        this.entities.push(e);
    }

    spawnSaveLifeWave() {
        this.waveCount++;
        ui.notify("–í–û–õ–ù–ê " + this.waveCount + "!");
        const count = Math.floor(5 * Math.pow(1.25, this.waveCount-1));
        const hp = 300 * Math.pow(1.25, this.waveCount-1);
        for(let i=0; i<count; i++) {
            let angle = Math.random() * Math.PI * 2;
            let dist = this.zoneRadius * 0.9;
            let e = new Entity(Math.cos(angle)*dist, Math.sin(angle)*dist, {color:'#111', detail:'#333', type:1}, false, "Invader");
            e.score = hp;
            e.team = 'red'; e.isInvader = true; e.nameColorOverride = '#f00';
            this.entities.push(e);
        }
    }

    spawnBoss() {
        if (this.arenaMode === 'agility' || this.arenaMode === '5vs1' || this.arenaMode === 'zombie' || this.arenaMode === 'save_life') return;

        let stage = Math.min(this.bossStage, 13);
        
                if (this.arenaMode === 'countryballs') {
            const cbBosses = [
                 {name:"Spanish Empire", score:20000, type:'spanish_empire'},
                 {name:"Soviet Union", score:22300, type:'ussr'},
                 {name:"Russian Empire", score:22800, type:'russian_empire'},
                 {name:"Mongol Empire", score:33000, type:'mongol_empire'},
                 {name:"British Empire", score:36000, type:'british_empire'}
            ];
            const bossIdx = (this.bossStage - 1) % cbBosses.length;
            const bInfo = cbBosses[bossIdx];
            
            const boss = new Entity(this.nextBossPos.x, this.nextBossPos.y, {id:'custom', countryType:bInfo.type, color:'#fff', detail:'#fff', type:1}, false, bInfo.name);
            boss.score = bInfo.score; boss.isBoss = true; 
            boss.bossAtkColor = '#f00'; 
            boss.atmosphereColor = 'rgba(255,0,0,0.5)';
            if(bInfo.type === 'russian_empire') boss.isRussianEmpire = true;
            this.entities.push(boss); this.activeBoss = boss; ui.notify("‚ö†Ô∏è " + bInfo.name + " –ü–û–Ø–í–ò–õ–°–Ø! ‚ö†Ô∏è");
            return;
        }

        let bData = BOSS_DATA[stage - 1];
        
        const bossBaseHP = [365, 500, 750, 1000, 1350, 1650, 1800, 15250, 19500, 25000, 30000, 35000, 40000];
        let baseScore = bossBaseHP[stage-1] || 2500;

        if (this.difficulty === 0) baseScore *= 0.33; 
        if (this.difficulty === 1) baseScore *= 0.5; 
        if (this.difficulty === 3) baseScore *= 2.0; 
        if (this.difficulty === 4) baseScore *= 3.0; 
        if (this.arenaMode === 'random_start') baseScore *= this.mod.bossScore;
        else if(!this.arenaMode) baseScore *= this.mod.bossScore;

        if (bData.type === 'hunter' && this.player) {
            baseScore = Math.max(baseScore, this.player.score * 1.0);
        }

        const boss = new Entity(this.nextBossPos.x, this.nextBossPos.y, PLANETS.find(x=>x.id==='sun')||PLANETS[8], false, bData.name);
        boss.score = baseScore; boss.isBoss = true;
        boss.atmosphereColor = hexToRgbaStr(bData.color, 0.6); boss.conf = { ...boss.conf, color: bData.color, type: bData.type === 'ton618' || bData.type === 'phoenix' || bData.type === 'starKing' || bData.type === 'florant' || bData.type === 'hunter' ? bData.type : 3 }; 
        if(bData.type === 'probe') boss.conf.type = 'probe';
        
        boss.texture = null; 
        boss.bossAtkColor = bData.atkColor;
        
        if(stage === 6) boss.isSpectral = true;
        if(stage === 7) boss.isAnomaly = true;
        if(stage === 8) boss.isTON618 = true;
        if(stage === 9) boss.isPhoenix = true;
        if(stage === 10) boss.isProbe = true;
        if(stage === 11) boss.isStarKing = true;
        if(stage === 12) boss.isFlorant = true;
        if(stage === 13) boss.isHunter = true;

        boss.waveCD = 10; 
        boss.bossState = 0; 
        
        this.entities.push(boss); this.activeBoss = boss; ui.notify("‚ö†Ô∏è " + bData.name + " –ü–û–Ø–í–ò–õ–°–Ø! ‚ö†Ô∏è");
    }
    spawnStarGlobal() {
        const r = Math.sqrt(Math.random()) * this.zoneRadius * 0.95, th = Math.random()*2*Math.PI;
        this.createStarAt(r*Math.cos(th), r*Math.sin(th));
    }
    spawnStarsAroundPlanets() {
        let sCount = CONFIG.maxStars;
        if (this.arenaMode === 'random_start') return; 
        if(this.arenaMode && this.arenaMode !== 'royal') sCount = Math.floor(CONFIG.maxStars / 1.5);
        if(this.stars.length >= sCount) return;
        this.entities.forEach(e => {
            if(!e.alive) return;
            let count = 5 + Math.floor(Math.random() * 10); 
            for(let i=0; i<count; i++) {
                let dist = e.radius * 2 + Math.random() * e.radius * 10; 
                let ang = Math.random() * Math.PI * 2;
                this.createStarAt(e.x + Math.cos(ang) * dist, e.y + Math.sin(ang) * dist);
            }
        });
    }
    createStarAt(x, y) {
        if(Math.hypot(x,y) > this.zoneRadius) return;
        let ti=0, rnd=Math.random(), acc=0;
        for(let i=0; i<STARS_TYPES.length; i++) { acc += STARS_TYPES[i].chance; if(rnd<=acc) { ti=i; break; } }
        this.stars.push({ x: x, y: y, tIdx: ti });
    }
    explodeEntity(e) {
                let count = 10 + Math.floor(Math.random() * 16);         let totalValue = e.score * 0.8;
        let valuePerStar = totalValue / count;
        
                                        
                        
        for (let i = 0; i < count; i++) {
            let r = Math.random() * e.radius * 1.2;
            let ang = Math.random() * Math.PI * 2;
            let sx = e.x + Math.cos(ang) * r;
            let sy = e.y + Math.sin(ang) * r;
            
                        let typeIdx = 0;
            if (valuePerStar > 15) typeIdx = 8;
            else if (valuePerStar > 10) typeIdx = 7;
            else if (valuePerStar > 7) typeIdx = 6;
            else if (valuePerStar > 5) typeIdx = 5;
            else if (valuePerStar > 3) typeIdx = 3;
            else if (valuePerStar > 1) typeIdx = 1;
            
                        if (Math.random() < 0.3) typeIdx = Math.max(0, Math.min(8, typeIdx + (Math.random() > 0.5 ? 1 : -1)));
            
            this.stars.push({ x: sx, y: sy, tIdx: typeIdx });
        }

        if (this.stars.length > 35000) this.stars.splice(0, this.stars.length - 35000);
    }
    spawnItem() {
        const types = Object.keys(ITEMS_TYPES);
        this.items.push({ 
            x: (Math.random()-0.5)*this.zoneRadius*0.9, 
            y: (Math.random()-0.5)*this.zoneRadius*0.9, 
            type: types[Math.floor(Math.random()*types.length)],
            vx: 0, vy: 0 
        });
    }
    activateItem() { 
        if(this.active && this.player) {
        } 
    }
    handleMobileBtn() {
        if(!this.player || this.paused) return;
        if(this.player.lightStripActive || this.player.blueStripActive) { return; }
                if(this.player.inventory.count > 0 && this.player.inventory.type) { 
            this.player.useItem(this.player.inventory.type); 
        } else {
            ui.notify("–ù–µ—Ç –ø—Ä–µ–¥–º–µ—Ç–æ–≤!");
        }
    }
    applySpinResult(type) { if(this.player) { this.player.pickupItem(type); this.spinCooldown = 30; } }
    
    showFloatingText(x, y, msg, color) {
        this.floatingTexts.push(new FloatingText(x, y, msg, color));
    }

    loop(timestamp) {
        if(!this.active) return;
        if (this.paused) {
             this.lastTime = timestamp; 
             requestAnimationFrame(t => this.loop(t));
             return;
        }
        const delta = timestamp - this.lastTime;
        const dt = Math.min(delta / 1000, 0.1); 
        this.lastTime = timestamp;
        this.fpsTimer += dt; if (this.fpsTimer >= 0.3) { ui.updateFPS(Math.round(1000 / delta)); this.fpsTimer = 0; }
        this.update(dt);
        this.draw();
        this.drawMinimap();
        requestAnimationFrame(t => this.loop(t));
    }

    update(dt) {
        if (this.gameOverSequence) {
            this.gameOverTimer += dt;
            this.cam.z *= 0.995; 
            const goScr = document.getElementById('gameOverScreen');
            goScr.style.display = 'flex';
            if (this.gameOverTimer > 2.0) { goScr.classList.add('active'); }
            if (this.gameOverTimer > 4.0 && !this.paused) { this.gameOver(); }
            this.entities.forEach(e => e.update(this, dt));
            return;
        }

        this.gameTime += dt;
        if (Math.floor(this.gameTime) % 30 === 0 && Math.floor(this.gameTime - dt) % 30 !== 0) {
            this.zoneDamageMultiplier *= 1.25;
        }

        this.starSpawnTimer += dt;
        if (this.starSpawnTimer >= 40.0) {
             this.spawnStarsAroundPlanets();
             this.starSpawnTimer = 0;
        }

        const currentBotCount = this.entities.filter(e => !e.isPlayer && !e.isBoss).length;
        if (currentBotCount < this.currentMaxBots && this.arenaMode !== 'zombie' && this.arenaMode !== 'save_life') {
            if(this.botRespawnTimer <= 0) this.botRespawnTimer = 2 + Math.random() * 3;
            this.botRespawnTimer -= dt;
            if(this.botRespawnTimer <= 0) { this.spawnBot(); }
        }

        if (this.modeSettings.pseudoMulti && !this.arenaMode) {
            this.pseudoMultiTimer += dt;
            if(this.pseudoMultiTimer > 3 + Math.random()*12) {
                this.spawnBot(); this.pseudoMultiTimer = 0;
            }
        }

        if (this.arenaMode === 'survival_random') {
            this.survivalTimer -= dt;
            const timerDiv = document.getElementById('survivalTimer');
            if(timerDiv) timerDiv.innerText = "–°–º–µ–Ω–∞: " + Math.ceil(this.survivalTimer);
            if (this.survivalTimer <= 0) {
                this.zoneRadius = 500 + Math.random() * 9500;
                ui.notify("–¢–ï–õ–ï–ü–û–†–¢–ê–¶–ò–Ø –ö–ê–†–¢–´!");
                if (Math.hypot(this.player.x, this.player.y) > this.zoneRadius) {
                    let ang = Math.atan2(this.player.y, this.player.x);
                    this.player.x = Math.cos(ang) * (this.zoneRadius - 100);
                    this.player.y = Math.sin(ang) * (this.zoneRadius - 100);
                }
                this.stars = [];
                let sCount = 500 + Math.random() * 3000;
                for(let i=0; i<sCount; i++) this.spawnStarGlobal();
                this.entities.forEach(e => {
                    if (!e.isPlayer && !e.isBoss) {
                        e.score = 50 + Math.random() * 2000;
                    }
                });
                this.survivalTimer = 10 + Math.random() * 15;
            }
        }

        if (this.arenaMode === '5vs1') {
            this.survivalTimer -= dt;
            const timerDiv = document.getElementById('survivalTimer');
            if(timerDiv) timerDiv.innerText = "–í—ã–∂–∏—Ç—å: " + Math.ceil(this.survivalTimer);
            if (this.survivalTimer <= 0) { ui.notify("–í–´ –í–´–ò–ì–†–ê–õ–ò!"); this.gameOver(); }
            
            const bigBoss = this.entities.find(e => e.isBigBoss);
            if(!bigBoss) { ui.notify("–ë–û–°–° –ü–û–í–ï–†–ñ–ï–ù!"); this.gameOver(); }
            
                        this.entities.forEach(e => {
                 if (e.respawnPending && e.respawnTimer > 0) {
                      e.respawnTimer -= dt;
                      if(e.respawnTimer <= 0) {
                          e.alive = true; e.score = 50; e.respawnPending = false;
                          let big = this.entities.find(ent=>ent.isBigBoss) || this.player;
                          let ang = Math.random()*Math.PI*2;
                          e.x = big.x + Math.cos(ang)*600; e.y = big.y + Math.sin(ang)*600;
                          ui.notify("–ë–æ—Ç –≤–æ–∑—Ä–æ–¥–∏–ª—Å—è!");
                      }
                 }
            });
        }

        if (this.arenaMode === 'zombie') {
             this.zombieSplitTimer -= dt;
             if (this.zombieSplitTimer <= 0) {
                 this.zombieSplitTimer = 60;
                 let newZombies = [];
                 this.entities.forEach(e => {
                      if (e.isZombie && e.alive) {
                          let clone = new Entity(e.x + 10, e.y + 10, e.conf, false, e.name);
                          clone.makeZombie(); clone.score = e.score;
                          newZombies.push(clone);
                      }
                 });
                 newZombies.forEach(z => this.entities.push(z));
                 ui.notify("–ó–û–ú–ë–ò –†–ê–ó–ú–ù–û–ñ–ê–Æ–¢–°–Ø!");
             }
        }

        if (this.arenaMode === 'save_life') {
             this.survivalTimer -= dt;
             const timerDiv = document.getElementById('survivalTimer');
             if(timerDiv) timerDiv.innerText = "–ó–∞—â–∏—Ç–∞: " + Math.ceil(this.survivalTimer);
             if (this.survivalTimer <= 0) { ui.notify("–ó–ï–ú–õ–Ø –°–ü–ê–°–ï–ù–ê!"); this.gameOver(); }
             
             this.waveTimer -= dt;
             if(this.waveTimer <= 0) {
                 this.spawnSaveLifeWave();
                 this.waveTimer = 10 + this.waveCount * 5; 
             }
             
             const core = this.entities.find(e => e.isCentralCore);
             if (!core) { ui.notify("–Ø–î–†–û –£–ù–ò–ß–¢–û–ñ–ï–ù–û!"); this.gameOverSequence = true; }
        }

        if (this.arenaMode === 'random_start' && this.randomIntroTimer > 0) {
            this.randomIntroTimer -= dt;
            if (this.randomIntroTimer <= 0) {
                ui.notify("–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–∫—Ä—ã—Ç—ã!");
            }
        }

                if(this.arenaMode && !this.modeSettings.disableEvents && this.arenaMode !== '5vs1' && this.arenaMode !== 'zombie' && this.arenaMode !== 'save_life') {
            this.arenaEventTimer -= dt;
            if(this.arenaEventTimer <= 0) {
                this.handleArenaEvents();
                this.arenaEventTimer = 15 + Math.random()*15;
            } else {
                if(this.arenaEventTimer <= 5) {
                    const disp = document.getElementById('arenaEventDisplay');
                    disp.style.display = 'block';
                    disp.innerText = `–î–æ –Ω–æ–≤–æ–≥–æ —Å–æ–±—ã—Ç–∏—è: ${Math.ceil(this.arenaEventTimer)}`;
                } else {
                    document.getElementById('arenaEventDisplay').style.display = 'none';
                }
            }
            if(this.arenaMode === 'duel') {
                if(Math.floor(this.gameTime) > Math.floor(this.gameTime-dt)) {
                    let add = 50 + Math.floor(this.gameTime)*5; 
                    this.entities.forEach(e => { if(!e.isBoss) e.addScore(add); });
                }
            }
        }

        if (this.zoneTimer > 0) {
            this.zoneTimer -= dt;
                        if (this.arenaMode === 'team') {
                this.entities.forEach(e => {
                    if (e.x > -50 && e.x < 50) {
                        if (e.x < 0) e.x = -60; else e.x = 60;
                        e.vx = 0;
                    }
                });
            }
        } else if(!this.activeBoss) { 
            this.bossTimer -= dt; 
            if (this.bossTimer <= 10 && this.bossTimer + dt > 10) {
                 this.nextBossPos = (this.arenaMode === 'team' || this.arenaMode === '5vs1') ? {x:0, y:0} : { x: (Math.random()-0.5)*this.zoneRadius*0.8, y: (Math.random()-0.5)*this.zoneRadius*0.8 };
            }
            if(this.bossTimer <= 0) this.spawnBoss();
        } else if(!this.activeBoss.alive) { 
            this.activeBoss = null; this.bossStage++;
            let bossTimeBase = 30 * this.bossStage;
            if (this.difficulty===0) bossTimeBase /= 3; 
            else if (this.difficulty===1) bossTimeBase /= 2;
            else if (this.difficulty===3) bossTimeBase *= 1.25;
            else if (this.difficulty===4) bossTimeBase *= 1.75;
            
            if (this.modeSettings.bossRush) {
                let interval = 15 + (this.bossStage - 2) * 5;
                bossTimeBase = interval;
            }
            if(this.arenaMode === 'mini') bossTimeBase = 10;
            if(this.arenaMode === 'royal') bossTimeBase = 30;
            if(this.arenaMode === 'team') bossTimeBase = 60;
            if(this.arenaMode === 'agility') bossTimeBase = 999999;
            if(this.arenaMode === '5vs1') bossTimeBase = 999999;
            if(this.arenaMode === 'zombie') bossTimeBase = 999999;
            if(this.arenaMode === 'save_life') bossTimeBase = 999999;
            if(this.arenaMode === 'all_vs_one') bossTimeBase = 40;
            if(this.arenaMode === 'countryballs') bossTimeBase = 30;

            this.bossTimer = (this.bossStage > 13 ? 99999 : bossTimeBase); 
        }

        if(this.zoneRadius > 500 && this.arenaMode !== 'survival_random' && this.arenaMode !== 'random_start' && this.arenaMode !== '5vs1' && this.arenaMode !== 'team') this.zoneRadius -= (CONFIG.mapSize / 600) * dt; 
        
        this.entities.sort((a,b) => a.radius - b.radius);
        this.entities.forEach(e => { e.inRing = false; e.update(this, dt); });

        for(let i=0; i<this.entities.length; i++) {
             let e = this.entities[i];
             if (!e.isPlayer && Math.abs(e.vx) < 0.1 && Math.abs(e.vy) < 0.1) {
                 e.vx = (Math.random()-0.5); e.vy = (Math.random()-0.5); 
             }
        }

        for(let i = this.snowballs.length - 1; i >= 0; i--) {
            let s = this.snowballs[i];
            s.life -= dt;
            if(s.life <= 0) { this.snowballs.splice(i, 1); continue; }
            
            if (s.owner && Math.hypot(s.x - s.owner.x, s.y - s.owner.y) > this.zoneRadius * 1.5) { this.snowballs.splice(i, 1); continue; }

            if(s.type === 'homing' || s.type === 'blueBullet' || s.type === 'vampire') {
                if(s.target && s.target.alive) {
                    let angle = Math.atan2(s.target.y - s.y, s.target.x - s.x);
                    let curAngle = Math.atan2(s.vy, s.vx);
                    let diff = angle - curAngle;
                    while (diff > Math.PI) diff -= Math.PI*2; while (diff < -Math.PI) diff += Math.PI*2;
                    let turnRate = (s.type === 'blueBullet') ? (20*Math.PI/180)/5 : (s.owner && ['earth','mars','venus','jupiter'].includes(s.owner.conf.id) ? (10*Math.PI/180)/5 : (5*Math.PI/180)/5);
                    if(s.type === 'jupiter') turnRate = (15*Math.PI/180)/5;
                    curAngle += Math.sign(diff) * Math.min(Math.abs(diff), turnRate * dt * 20); 
                    let spd = Math.hypot(s.vx, s.vy);
                    s.vx = Math.cos(curAngle) * spd; s.vy = Math.sin(curAngle) * spd;
                }
            }
            s.x += s.vx * dt; s.y += s.vy * dt;
            
            if(Math.hypot(s.x, s.y) > this.zoneRadius) { this.snowballs.splice(i, 1); continue; }
            for(let e of this.entities) {
                if(e === s.owner || !e.alive) continue;
                if(this.arenaMode === 'team' && s.owner && s.owner.team === e.team) continue; 
                
                // SAVE LIFE MODE FIX: FRIENDLY FIRE CHECK FOR PROJECTILES
                if (this.arenaMode === 'save_life') {
                    if ((s.owner && s.owner.isPlayer && e.isCentralCore) || (e.isPlayer && s.owner && s.owner.isCentralCore)) continue;
                }

                if (this.arenaMode === 'zombie' && s.owner && s.owner.isSurvivor && e.isSurvivor) {
                                          if(Math.hypot(e.x - s.x, e.y - s.y) < e.radius + s.radius) {
                         let heal = s.damage * 0.6;
                         e.addScore(heal);
                         this.snowballs.splice(i, 1);
                         break;
                     }
                     continue;
                }
                
                if(this.arenaMode === '5vs1') {
                    if (s.owner.isBigBoss && e.isBigBoss) continue; 
                    if (!s.owner.isBigBoss && !e.isBigBoss) continue; 
                }

                if(Math.hypot(e.x - s.x, e.y - s.y) < e.radius + s.radius) {
                    let hit = true;
                    if(e.shieldActive) {
                        let attackerScore = s.owner ? s.owner.score : 100;
                        e.shieldHp -= (attackerScore * 0.01) * (dt / 0.3);                         if(s.life > 0.4) {
                             s.vx *= -0.5; s.vy *= -0.5; hit = false; 
                             let penetrate = s.life > 2.6 ? 0.1 : 0.2;
                             e.takeDamage(s.damage * penetrate);
                        }
                    }
                    if(hit) {
                        if (s.type === 'starProjectile') {
                             e.takeDamage(s.damage); 
                        } else if (s.isBossShot) {
                             let dmg = e.score * (this.difficulty===0 ? 0.05 : 0.15); 
                             e.takeDamage(dmg);
                             if(e.isPlayer) game.showFloatingText(e.x, e.y - e.radius, "-" + Math.floor(dmg), "red");
                        } else {
                             let lvl = (s.owner.isPlayer ? (ui.data.abilityLevels?.snowball || 0) : 0);
                             let dmgPerc = 0.05 + (lvl * 0.01);
                             if (s.owner.activeEffects && s.owner.activeEffects.grow > 0) dmgPerc *= 1.2; 
                             
                             let dmg = e.score * dmgPerc;
                             if(s.type === 'strip') {
                                dmg = s.damage;                              }

                             if (s.owner.isPlayer) dmg *= game.mod.playerDmg;
                             
                             // Weapon Damage Mod
                             if(s.owner.isPlayer || s.owner.isBot) {
                                 dmg *= game.mod.weaponDmg;
                             }

                             // Dynamic damage for Ice Bullet
                             if (s.type === 'blueBullet') {
                                 let baseDmg = dmg;
                                 let bonus = 0;
                                 if (s.owner && s.owner.score > 2000) {
                                     bonus = Math.min(50, (s.owner.score - 2000) / 60);
                                 }
                                 dmg = baseDmg + bonus;
                             }

                             if (e.isBoss && s.owner.isPlayer) {
                                 if (this.difficulty === 0) dmg *= 2.0; 
                                 else if (this.difficulty === 1) dmg *= 1.5; 
                             }
                             
                             if(s.type === 'vampire') {
                                 // New Vampire Logic
                                 e.vampireDot = {
                                     total: s.damageSnapshot, // Snapshot of 9% damage
                                     timer: 3.0,
                                     tickAccumulator: 0,
                                     owner: s.owner
                                 };
                             } else {
                                 e.takeDamage(dmg);
                             }

                             if (s.type === 'blueBullet') {
                                 e.applyFrozenEffect(s.color, true); 
                                 if (s.owner && s.owner.alive) {
                                     let dx = e.x - s.owner.x, dy = e.y - s.owner.y; let dist = Math.hypot(dx,dy);
                                     if (dist > 1) {
                                         e.x += (dx/dist) * s.owner.radius * 2; e.y += (dy/dist) * s.owner.radius * 2;
                                     }
                                 }
                             } else {
                                 if (['uranus', 'neptune', 'jupiter'].includes(s.owner.conf.id)) e.applyFrozenEffect(s.color);
                             }
                        }
                        this.snowballs.splice(i, 1);
                        break;
                    }
                }
            }
        }
        
        for(let i=this.floatingTexts.length-1; i>=0; i--) {
            this.floatingTexts[i].update(dt);
            if(this.floatingTexts[i].life <= 0) this.floatingTexts.splice(i, 1);
        }

        this.entities.forEach(e => {
            if(Math.hypot(e.x, e.y) > this.zoneRadius + 200) {
                let dmg = (e.score * 0.2 * this.zoneDamageMultiplier) * dt;
                e.takeDamage(dmg, true); 
                if(e.isPlayer && Math.random() < 0.05) ui.notify("–£–†–û–ù –û–¢ –ó–û–ù–´!");
                if(e.score < 20) e.kill();
            }
        });

        if(this.spinCooldown > 0) { this.spinCooldown -= dt; ui.updateSpinCooldown(this.spinCooldown, 30); }
        if(!this.player.alive && !this.gameOverSequence) this.player.kill(); 
        
        this.entities = this.entities.filter(e => e.alive);

        for(let i=0; i<this.entities.length; i++) {
            let a = this.entities[i]; a.isEating = false;
            for(let j=i+1; j<this.entities.length; j++) {
                let b = this.entities[j];
                let dist = Math.hypot(a.x - b.x, a.y - b.y);
                
                if (this.arenaMode === 'team' && a.team === b.team) continue;
                if (this.arenaMode === 'zombie' && a.isSurvivor && b.isSurvivor) continue;
                if (this.arenaMode === 'save_life' && a.team === b.team) continue;

                // SAVE LIFE MODE FIX: PLAYER AND CORE CANNOT DAMAGE EACH OTHER
                if (this.arenaMode === 'save_life') {
                    if ((a.isPlayer && b.isCentralCore) || (b.isPlayer && a.isCentralCore)) continue;
                }
                
                if (this.arenaMode === 'zombie' && a.isZombie !== b.isZombie && dist < a.radius + b.radius) {
                     let zombie = a.isZombie ? a : b;
                     let survivor = a.isZombie ? b : a;
                     survivor.makeZombie();
                     continue;
                }

                if (this.arenaMode === '5vs1') {
                    if (a.isBigBoss && b.isBigBoss) continue; 
                    if (!a.isBigBoss && !b.isBigBoss) continue;
                }

                if(a.conf.hasRing && dist < a.radius*2.5 && dist > a.radius) { let dmg = b.score*0.01*dt; b.takeDamage(dmg); b.inRing = true; }
                if(b.conf.hasRing && dist < b.radius*2.5 && dist > b.radius) { let dmg = a.score*0.01*dt; a.takeDamage(dmg); a.inRing = true; }
                
                // Anomaly Logic Overhaul
                if(a.isAnomalyBot && dist < a.radius * 3) {
                     let factor = dist < a.radius + b.radius ? 0.02 : 0; // 2% per 0.2s roughly if touching
                     if (dist < a.radius + b.radius) {
                         // Touching
                         // Logic: 2% of b.score every 0.2s => 10% per second.
                         b.takeDamage(b.score * 0.1 * dt);
                     }
                }
                if(b.isAnomalyBot && dist < b.radius * 3) {
                     if (dist < a.radius + b.radius) {
                         a.takeDamage(a.score * 0.1 * dt);
                     }
                }

                if((a.isSpectral || a.isAnomaly || a.isTON618 || a.isPhoenix) && dist < a.radius * 3) { 
                    let factor = 0.04;
                    // Anomaly Boss x25 damage
                    if (a.isAnomaly) factor = 0.04 * 25; 

                    if (a.isTON618) { factor = 0.20; b.slowTimer = 0.5 * 0.75; } // Debuff reduction global
                    if (a.isPhoenix) { factor = 0.30; b.slowTimer = 0.5 * 0.75; }
                    let dmg = b.score * factor * dt; 
                    if (a.isTON618 && b.isPlayer && b.score < a.score) {
                         b.takeDamage(b.score * 0.5 * dt); 
                    } else {
                         b.takeDamage(dmg);
                    }
                } 
                if((b.isSpectral || b.isAnomaly || b.isTON618 || b.isPhoenix) && dist < b.radius * 3) { 
                    let factor = 0.04;
                    // Anomaly Boss x25 damage
                    if (b.isAnomaly) factor = 0.04 * 25;

                    if (b.isTON618) { factor = 0.20; a.slowTimer = 0.5 * 0.75; }
                    if (b.isPhoenix) { factor = 0.30; a.slowTimer = 0.5 * 0.75; }
                    let dmg = a.score * factor * dt; 
                    if (b.isTON618 && a.isPlayer && a.score < b.score) {
                         a.takeDamage(a.score * 0.5 * dt);
                    } else {
                         a.takeDamage(dmg); 
                    }
                }

                if (a.isProbe && dist < a.radius + b.radius) { b.takeDamage(b.score * 0.15 * dt); }
                if (b.isProbe && dist < a.radius + b.radius) { a.takeDamage(a.score * 0.15 * dt); }
                
                // Florant shield damage
                if (a.isFlorant && a.florantShields) {
                    a.florantShields.forEach(sh => {
                        let sx = a.x + Math.cos(sh.angle)*sh.dist;
                        let sy = a.y + Math.sin(sh.angle)*sh.dist;
                        if(Math.hypot(b.x-sx, b.y-sy) < sh.radius + b.radius) {
                             b.takeDamage(b.score * 0.05 * dt);
                        }
                    });
                }
                if (b.isFlorant && b.florantShields) {
                    b.florantShields.forEach(sh => {
                        let sx = b.x + Math.cos(sh.angle)*sh.dist;
                        let sy = b.y + Math.sin(sh.angle)*sh.dist;
                        if(Math.hypot(a.x-sx, a.y-sy) < sh.radius + a.radius) {
                             a.takeDamage(a.score * 0.05 * dt);
                        }
                    });
                }

                                if(a.shieldActive && dist < a.radius*1.15 + b.radius) {
                    let nx = (b.x-a.x)/dist, ny = (b.y-a.y)/dist;
                    b.x += nx * 5; b.y += ny * 5; b.takeDamage(b.score*0.01*dt); 
                    a.shieldHp -= (b.score * 0.01) * (dt / 0.3);                 }
                if(b.shieldActive && dist < b.radius*1.15 + a.radius) {
                    let nx = (a.x-b.x)/dist, ny = (a.y-b.y)/dist;
                    a.x += nx * 5; a.y += ny * 5; a.takeDamage(a.score*0.01*dt); 
                    b.shieldHp -= (a.score * 0.01) * (dt / 0.3);                 }

                if(dist < a.radius + b.radius && !a.isProbe && !b.isProbe && !a.isStarKing && !b.isStarKing && !a.isFlorant && !b.isFlorant && !a.isHunter && !b.isHunter) {
                    if (this.gameTime < 10.0) {
                        let nx = (a.x - b.x)/dist, ny = (a.y - b.y)/dist, pen = (a.radius+b.radius)-dist;
                        a.x += nx*pen*0.5; a.y += ny*pen*0.5; b.x -= nx*pen*0.5; b.y -= ny*pen*0.5;
                        continue; 
                    }
                    if(Math.abs(a.score - b.score) < 1) { 
                        let nx = (a.x - b.x)/dist, ny = (a.y - b.y)/dist, pen = (a.radius+b.radius)-dist;
                        a.x += nx*pen*0.5; a.y += ny*pen*0.5; b.x -= nx*pen*0.5; b.y -= ny*pen*0.5;
                    } else { 
                        let predator = a.mass > b.mass ? a : b;
                        let prey = a.mass > b.mass ? b : a;
                        
                        // Probe logic: Probe cannot eat, but can be eaten
                        if (predator.isProbe) {
                            // Only damage, no eating logic here, let them separate or overlap damage
                             let nx = (a.x - b.x)/dist, ny = (a.y - b.y)/dist, pen = (a.radius+b.radius)-dist;
                             prey.x -= nx*pen*0.1; prey.y -= ny*pen*0.1;
                             continue;
                        }

                        if (predator.isTON618 && prey.isPlayer) {
                             let nx = (a.x - b.x)/dist, ny = (a.y - b.y)/dist, pen = (a.radius+b.radius)-dist;
                             prey.x -= nx*pen*0.1; prey.y -= ny*pen*0.1;
                             continue;
                        }

                        // Anomaly logic: cannot eat player
                        if (predator.isAnomalyBot && prey.isPlayer) {
                             let nx = (a.x - b.x)/dist, ny = (a.y - b.y)/dist, pen = (a.radius+b.radius)-dist;
                             prey.x -= nx*pen*0.1; prey.y -= ny*pen*0.1;
                             continue;
                        }

                        if (game.mod.immunity >= 100 && prey.isPlayer) {
                        } else {
                            predator.isEating = true;
                            let eatRate = (dist < predator.radius) ? 4 : 1;
                            let timeToEat = (prey.conf.type === 2 || prey.conf.type === 4) ? 1.25 : (prey.conf.id === 'sun' ? 2.0 : 1.75);
                            
                            // Anomaly eats slower if prey is smaller (1% per 2s logic -> implemented as eat time?)
                            // Simplified: Anomaly just does default eating if not player.
                            
                            predator.eatingProgress += dt * eatRate;
                            prey.showBar = true; prey.barValue = predator.eatingProgress / timeToEat;
                            if(predator.eatingProgress >= timeToEat) {
                                prey.kill(); predator.eatingProgress = 0; this.explodeEntity(prey); 
                                if(predator.isPlayer) ui.notify("–£–ë–ò–¢ " + prey.name + "!");
                            }
                        }
                    }
                }
            }
        }

        let starMod = 1;
        if (this.player && this.player.isPlayer) {
             if (this.difficulty === 0) starMod = 2.5;      
             else if (this.difficulty === 1) starMod = 1.75; 
             else if (this.difficulty === 4) starMod = 0.85; 
             if (this.arenaMode === 'mini') starMod *= 2.5; 
             starMod *= game.mod.playerScore;
        }

        for(let i=this.stars.length-1; i>=0; i--) {
            const s = this.stars[i];
            let eaten = false;
            for(let e of this.entities) {
                if (e.isProbe || e.isStarKing || e.isFlorant || e.isHunter) continue;
                if (e.isCentralCore) continue;                 if (Math.abs(e.x - s.x) > e.radius + 200) continue;
                let d = Math.hypot(e.x - s.x, e.y - s.y);
                
                let pullRad = (e.radius * 3 * 0.8) * (e.activeEffects && e.activeEffects.magnet > 0 ? 2.0 : 1.0); 
                
                // Vacuum Modifier
                pullRad *= game.mod.vacuumMult;
                
                if (e.isAnomalyBot) pullRad = e.radius * 3.0; // Anomaly x3
                if (e.magnetRadiusMult) pullRad *= e.magnetRadiusMult;

                if (game.arenaMode === 'mini' || game.arenaMode === 'duel') {
                    // Rule Immunity Check
                    if (e.isPlayer && game.mod.ruleImmunity) {
                        // Ignore shrink
                    } else {
                        pullRad = e.radius * 1.1; 
                    }
                } else if(e.isBoss && e.isAnomaly) pullRad *= 4; 
                else if(e.isBoss) {
                     if (game.arenaMode === 'mini' || game.arenaMode === 'duel') pullRad = e.radius * 1.1;
                     else pullRad *= 2; 
                }

                if(d < pullRad) {
                     let pullSpeed = 0.15;
                     if(!e.isPlayer && !e.isBoss) pullSpeed /= 1.5; 

                     s.x += (e.x - s.x) * pullSpeed; s.y += (e.y - s.y) * pullSpeed;
                     if(d < e.radius) { 
                         let typeVal = STARS_TYPES[s.tIdx].score;
                         if (e.isPlayer) {
                             typeVal *= starMod;
                             if (e.conf.id === 'earth' && Math.random()<0.15) typeVal *= 1.5;
                         }
                         if (e.activeEffects && e.activeEffects.bonus > 0) typeVal *= 1.3; 
                         if (e.isAnomalyBot) typeVal *= 15; // Anomaly Score x15
                         if (e.isAgilityBoss) typeVal *= 0.1;

                         e.addScore(typeVal); 
                         eaten = true; break; 
                     }
                }
            }
            if(eaten) { this.stars.splice(i,1); }
        }

                for(let i=this.items.length-1; i>=0; i--) {
            let it = this.items[i];
            let picked = false;
            for(let e of this.entities) {
                if(!e.alive) continue;
                if(e.isBoss) continue;
                let d = Math.hypot(e.x - it.x, e.y - it.y);
                if (d < e.radius + 300) {
                     it.vx = (e.x - it.x) * 0.05;
                     it.vy = (e.y - it.y) * 0.05;
                     it.x += it.vx; it.y += it.vy;
                     if (d < e.radius + 10) {
                         if(e.pickupItem(it.type)) { picked = true; break; }
                     }
                }
            }
            if(picked) this.items.splice(i,1);
        }

        this.cam.x = this.player.x;
        this.cam.y = this.player.y;
        
                let baseZoom = 2.25;
        if(this.isMobile) { baseZoom = 0.8; } 
        
        let safeScoreCam = Math.max(0, this.player.score);
        let tz = baseZoom / (1 + Math.pow(safeScoreCam, 0.45) * 0.08);
        this.cam.z += (tz - this.cam.z) * 0.1;
        
        if (this.activeBoss) {
            const arrow = document.getElementById('bossArrow'); arrow.style.display = 'block';
            const dx = this.activeBoss.x - this.player.x, dy = this.activeBoss.y - this.player.y;
            const angle = Math.atan2(dy, dx);
            const dist = Math.hypot(dx, dy);
            if (dist > (window.innerHeight / this.cam.z)/2) {
                const edgeDist = Math.min(window.innerWidth, window.innerHeight) * 0.4;
                arrow.style.left = (window.innerWidth/2 + Math.cos(angle)*edgeDist) + 'px';
                arrow.style.top = (window.innerHeight/2 + Math.sin(angle)*edgeDist) + 'px';
                arrow.style.transform = `translate(-50%, -50%) rotate(${angle}rad)`; 
            } else arrow.style.display = 'none';
        } else if (this.bossTimer < 10) {
            const arrow = document.getElementById('bossArrow'); arrow.style.display = 'block';
            const dx = this.nextBossPos.x - this.player.x, dy = this.nextBossPos.y - this.player.y;
            const angle = Math.atan2(dy, dx);
            const dist = Math.hypot(dx, dy);
            if (dist > (window.innerHeight / this.cam.z)/2) {
                const edgeDist = Math.min(window.innerWidth, window.innerHeight) * 0.4;
                arrow.style.left = (window.innerWidth/2 + Math.cos(angle)*edgeDist) + 'px';
                arrow.style.top = (window.innerHeight/2 + Math.sin(angle)*edgeDist) + 'px';
                arrow.style.transform = `translate(-50%, -50%) rotate(${angle}rad)`; 
            } else arrow.style.display = 'none';
        } else document.getElementById('bossArrow').style.display = 'none';

        if (this.player && this.aimJoy.active) {
            let knob = document.getElementById('aimKnob');
            let mag = Math.hypot(this.aimJoy.dx, this.aimJoy.dy);
            if (mag > 0.05 && mag < 0.25) { 
                 knob.classList.add('auto-aim');
                 if(Math.random() < 0.1) this.player.autoFire(game); 
            } else {
                 knob.classList.remove('auto-aim');
            }
        }
        
        // Hover Check for Score
        if(!this.isMobile && this.active) {
             let mx = this.mouse.x + this.cam.x;
             let my = this.mouse.y + this.cam.y;
             this.hoverEntity = null;
             for(let e of this.entities) {
                 if(!e.alive) continue;
                 if(Math.hypot(e.x - mx, e.y - my) < e.radius) {
                     this.hoverEntity = e;
                     break;
                 }
             }
        }

        ui.updateHUD(this.player, this.entities, this.bossTimer, this.activeBoss, this.zoneTimer);
    }

        handleArenaEvents() {
        const events = [
            { t: "–°–º–µ—Ä—Ç—å 50% –ø–ª–∞–Ω–µ—Ç", f: () => { 
                let bots = this.entities.filter(e => !e.isPlayer && !e.isBoss); 
                for(let i=0; i<Math.floor(bots.length/2); i++) bots[i].kill(); 
            }},
            { t: "x2 –û—á–∫–æ–≤ –¢–û–ü-5", f: () => {
                let top = [...this.entities].sort((a,b)=>b.score-a.score).slice(0,5);
                top.forEach(e => e.score *= 2);
            }},
            { t: "–°–º–µ—Ä—Ç—å —Å–ª—É—á–∞–π–Ω–æ–π –ø–ª–∞–Ω–µ—Ç—ã", f: () => {
                let bots = this.entities.filter(e => !e.isPlayer && !e.isBoss);
                if(bots.length>0) bots[Math.floor(Math.random()*bots.length)].kill();
            }},
            { t: "–ë–æ–Ω—É—Å 1500 –æ—á–∫–æ–≤", f: () => {
                if(this.entities.length>0) this.entities[Math.floor(Math.random()*this.entities.length)].addScore(1500);
            }},
            { t: "–ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞!", f: () => {
                this.entities.forEach(e => { e.waveCD = 0; e.shieldCD = 0; e.rayCD = 0; e.gravityManeuverCD = 0; e.blueStripCD = 0; });
            }},
            { t: "–ë–æ—Å—Å —Ç–µ—Ä—è–µ—Ç 30% HP", f: () => {
                if(this.activeBoss) this.activeBoss.score *= 0.7;
            }},
            { t: "–°–º–µ—Ä—Ç—å —Ä–∞–Ω–¥–æ–º–Ω–æ–≥–æ", f: () => {
                let bots = this.entities.filter(e => !e.isBoss && !e.isPlayer);
                if(bots.length > 0) bots[Math.floor(Math.random()*bots.length)].kill();
            }}
        ];

        if (this.arenaMode === 'mini' || this.arenaMode === '5vs1') {
                     }

        if(this.arenaMode === 'royal') {
            events.push({t: "+10% –û—á–∫–æ–≤ 50% –∏–≥—Ä–æ–∫–æ–≤", f: () => {
                this.entities.forEach(e => { if(Math.random()<0.5) e.score *= 1.1; });
            }});
        }
        
        const ev = events[Math.floor(Math.random()*events.length)];
        this.currentArenaEvent = ev.t;
        ev.f();
        ui.notify("–°–û–ë–´–¢–ò–ï: " + ev.t);
        
        const disp = document.getElementById('arenaEventDisplay');
        disp.style.display = 'block';
        disp.innerText = "–°–û–ë–´–¢–ò–ï: " + ev.t;
        setTimeout(() => { disp.style.display = 'none'; }, 5000);
    }

    draw() {
        this.ctx.fillStyle = '#050a10'; this.ctx.fillRect(0,0,this.canvas.width/window.devicePixelRatio,this.canvas.height/window.devicePixelRatio);
        this.ctx.save();
        this.ctx.translate(window.innerWidth/2, window.innerHeight/2);
        this.ctx.scale(this.cam.z, this.cam.z);
        this.ctx.translate(-this.cam.x, -this.cam.y);
        
        this.ctx.beginPath(); this.ctx.arc(0,0,this.zoneRadius,0,Math.PI*2);
        this.ctx.lineWidth=100; this.ctx.strokeStyle="rgba(173,216,230,0.1)"; this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.arc(0,0,this.zoneRadius,0,Math.PI*2);
        this.ctx.lineWidth=5; this.ctx.strokeStyle="rgba(173,216,230,0.8)"; this.ctx.stroke();

        if (this.arenaMode === 'team' && this.zoneTimer > 0) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, -this.zoneRadius);
            this.ctx.lineTo(0, this.zoneRadius);
            this.ctx.strokeStyle = "white";
            this.ctx.lineWidth = 10;
            this.ctx.setLineDash([20, 20]);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }

        const vw = window.innerWidth/this.cam.z, vh = window.innerHeight/this.cam.z;
        const vl=this.cam.x-vw/2-100, vr=this.cam.x+vw/2+100, vt=this.cam.y-vh/2-100, vb=this.cam.y+vh/2+100;

        for(let s of this.stars) { if(s.x>vl && s.x<vr && s.y>vt && s.y<vb) this.ctx.drawImage(AssetManager.starCanvases[s.tIdx], s.x-10, s.y-10); }
        for(let it of this.items) {
            if(it.x>vl && it.x<vr && it.y>vt && it.y<vb) {
                const c = ITEMS_TYPES[it.type];
                this.ctx.fillStyle=c.color; this.ctx.shadowBlur=10; this.ctx.shadowColor=c.color;
                this.ctx.beginPath(); this.ctx.arc(it.x, it.y, 15, 0, Math.PI*2); this.ctx.fill();
                this.ctx.shadowBlur=0; this.ctx.fillStyle="#000"; this.ctx.font="16px sans-serif";
                this.ctx.textAlign="center"; this.ctx.fillText(c.icon, it.x, it.y+6);
            }
        }
        
        if (!this.activeBoss && this.bossTimer <= 7 && this.bossTimer > 0) {
            let nextBossR = CONFIG.baseSize * 10; 
            let waveR = (this.bossTimer / 7) * (nextBossR * 10);
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.arc(this.nextBossPos.x, this.nextBossPos.y, waveR, 0, Math.PI*2);
            this.ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
            this.ctx.lineWidth = 20;
            this.ctx.stroke();
            this.ctx.restore();
        }

        for(let s of this.snowballs) {
            this.ctx.save();
            this.ctx.translate(s.x, s.y);
            this.ctx.rotate(Math.atan2(s.vy, s.vx));
            
            let pulse = 0.1 + Math.abs(Math.sin(Date.now()/200))*0.1;
            this.ctx.fillStyle = `rgba(255,255,255,${pulse})`;
            this.ctx.beginPath(); this.ctx.arc(0,0, s.radius * 1.1, 0, Math.PI*2); this.ctx.fill();

            if(s.type === 'strip' || s.type === 'sword') {
                 if (s.type === 'strip' && s.isTTS) {
                      let grad = this.ctx.createLinearGradient(0, -s.wid/2, 0, s.wid/2);
                      grad.addColorStop(0, '#00FF00');
                      grad.addColorStop(0.5, '#FFFFFF');
                      grad.addColorStop(1, '#FF0000');
                      this.ctx.fillStyle = grad;
                 } else {
                      this.ctx.fillStyle = s.color;
                 }
                 this.ctx.fillRect(-s.len/2, -s.wid/2, s.len, s.wid);
            } else {
                 let tName = 'normal';
                 if (s.isTTS) tName = 'tts16a';
                 if (s.type === 'starProjectile') tName = 'star';
                 if(!s.texture) s.texture = AssetManager.getProjectileTexture(s.color, s.radius, 0, tName);
                 this.ctx.drawImage(s.texture, -s.radius, -s.radius);
            }
            this.ctx.restore();
        }

        if (this.activeBoss && this.activeBoss.isSpectral) {
            if (this.activeBoss.bossState === 2 && this.activeBoss.bossAttackType === 10) {
                 if(this.activeBoss.spectralRays) {
                    this.activeBoss.spectralRays.forEach(ray => {
                        let ex = this.activeBoss.x + Math.cos(this.activeBoss.angle + ray.angle) * ray.len;
                        let ey = this.activeBoss.y + Math.sin(this.activeBoss.angle + ray.angle) * ray.len;
                        this.ctx.save();
                        this.ctx.translate(ex, ey);
                        let t = Date.now()/100;
                        this.ctx.fillStyle = `hsl(${(t * 50)%360}, 100%, 50%)`;
                        this.ctx.beginPath(); this.ctx.arc(0,0,this.activeBoss.radius, 0, Math.PI*2); this.ctx.fill();
                        this.ctx.restore();
                    });
                 }
            }
        }

        if (this.activeBoss && (this.activeBoss.bossState === 1 || this.activeBoss.bossState === 2) && this.activeBoss.bossAttackType === 2) {
            const b = this.activeBoss;
            const rayLen = b.radius * 20; 
            const ex = b.x + Math.cos(b.bossTargetAngle) * rayLen; 
            const ey = b.y + Math.sin(b.bossTargetAngle) * rayLen;
            this.ctx.save();
            this.ctx.beginPath(); this.ctx.moveTo(b.x, b.y); this.ctx.lineTo(ex, ey); 
            if(b.bossState === 1) { 
                 this.ctx.lineWidth = b.radius/4; this.ctx.strokeStyle = hexToRgbaStr(b.bossAtkColor, 0.5); this.ctx.setLineDash([20, 20]); this.ctx.stroke();
            } else { 
                 this.ctx.lineWidth = b.radius/2; 
                 this.ctx.strokeStyle = b.bossAtkColor; 
                 this.ctx.setLineDash([]); this.ctx.stroke();
                 this.ctx.beginPath(); this.ctx.moveTo(b.x, b.y); this.ctx.lineTo(ex, ey);
                 this.ctx.lineWidth = b.radius/8; 
                 this.ctx.strokeStyle = "white"; this.ctx.stroke();
            }
            this.ctx.restore();
        }
        
        this.entities.forEach(e => {
            if(e.rayState > 0) {
                const rayLen = e.radius * (e.conf.id === 'mercury' ? 15 : 15); 
                const ex = e.x + Math.cos(e.rayAngle) * rayLen;
                const ey = e.y + Math.sin(e.rayAngle) * rayLen;
                let mainColor = "yellow";
                if(e.conf.id === 'sirius' || e.isPhoenix) mainColor = '#00BFFF';
                if(e.conf.id === 'betelgeuse') mainColor = '#ff0000';
                if(e.isTON618) mainColor = '#F5DEB3';
                if(e.isProbe) mainColor = '#FF0000';
                
                let widthMult = (e.conf.id === 'betelgeuse' || e.isTON618) ? 2.0 : (e.isPhoenix || e.isProbe ? 0.5 : 1);
                this.ctx.save();
                this.ctx.beginPath(); this.ctx.moveTo(e.x, e.y); this.ctx.lineTo(ex, ey);
                if(e.rayState === 1) { 
                    this.ctx.lineWidth = (e.radius/4) * widthMult;
                    this.ctx.strokeStyle = (e.rayTimer < 1 && Math.floor(Date.now()/100)%2===0) ? "white" : mainColor; 
                    this.ctx.setLineDash([15, 15]); this.ctx.stroke();
                } else { 
                    if (e.conf.id === 'tts16a') {
                        let width = (e.radius/4);
                        this.ctx.lineWidth = width;
                        this.ctx.strokeStyle = "#FFFFFF"; 
                        this.ctx.setLineDash([]); this.ctx.stroke();
                        this.ctx.beginPath(); this.ctx.moveTo(e.x, e.y); this.ctx.lineTo(ex, ey);
                        this.ctx.lineWidth = width; 
                        let gradSt = this.ctx.createLinearGradient(e.x, e.y - width/2, e.x, e.y + width/2); 
                        gradSt.addColorStop(0, '#00FF00'); gradSt.addColorStop(0.5, '#FFFFFF'); gradSt.addColorStop(1, '#FF0000');
                        this.ctx.strokeStyle = gradSt;
                        this.ctx.stroke();
                    } else {
                        this.ctx.lineWidth = ((e.conf.id === 'venus') ? e.radius/6 : e.radius/4) * widthMult;
                        this.ctx.strokeStyle = mainColor;
                        this.ctx.setLineDash([]); this.ctx.stroke();
                        this.ctx.beginPath(); this.ctx.moveTo(e.x, e.y); this.ctx.lineTo(ex, ey);
                        this.ctx.lineWidth = (e.radius/10) * widthMult;
                        this.ctx.strokeStyle = "white"; this.ctx.stroke();
                    }
                }
                this.ctx.restore();
            }
        });

        if (this.activeBoss && this.activeBoss.bossState === 2 && this.activeBoss.bossAttackType === 3) {
             const b = this.activeBoss;
             const dist = b.radius * 3;
             for(let i=0; i<2; i++) {
                 let ang = b.bossOrbitAngle + (i * Math.PI);
                 let ox = b.x + Math.cos(ang) * dist; let oy = b.y + Math.sin(ang) * dist;
                 this.ctx.save(); this.ctx.translate(ox, oy); this.ctx.fillStyle = b.bossAtkColor; this.ctx.shadowBlur = 10; this.ctx.shadowColor = b.bossAtkColor;
                 this.ctx.beginPath(); this.ctx.arc(0,0,b.radius*0.8, 0, Math.PI*2); this.ctx.fill(); this.ctx.restore();
             }
        }
        
        // Spectral Rotating Cross
        if (this.activeBoss && this.activeBoss.bossState === 2 && this.activeBoss.bossAttackType === 11) {
            const b = this.activeBoss;
            const rays = 4;
            const len = b.radius * 20;
            for(let i=0; i<rays; i++) {
                let ang = b.angle + i * (Math.PI/2);
                let ex = b.x + Math.cos(ang) * len;
                let ey = b.y + Math.sin(ang) * len;
                this.ctx.save();
                this.ctx.beginPath(); this.ctx.moveTo(b.x, b.y); this.ctx.lineTo(ex, ey);
                this.ctx.lineWidth = b.radius/2;
                this.ctx.strokeStyle = `hsl(${(Date.now()/5 + i*90)%360}, 100%, 50%)`;
                this.ctx.stroke();
                this.ctx.restore();
            }
        }

        if (this.player && this.player.alive) {
            let showLine = false;
            let dx=0, dy=0;
            if (this.aimJoy.active) {
                dx = this.aimJoy.dx; dy = this.aimJoy.dy; showLine = true;
            } else if ((this.player.lightStripActive || this.player.blueStripActive) && !this.isMobile) {
                dx = this.mouse.x; dy = this.mouse.y;
                showLine = true;
            }

            if (showLine && Math.hypot(dx,dy) > 0.1) {
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x, this.player.y);
                const angle = Math.atan2(dy, dx);
                this.ctx.lineTo(this.player.x + Math.cos(angle) * 800, this.player.y + Math.sin(angle) * 800);
                this.ctx.strokeStyle = "rgba(255,255,255,0.6)"; this.ctx.lineWidth = 3; this.ctx.setLineDash([]); this.ctx.stroke();
                this.ctx.restore();
            }
            
            // Draw Arrows for Anomalies
            this.entities.forEach(e => {
                if(e.isAnomalyBot && e !== this.player) {
                     const dist = Math.hypot(e.x - this.player.x, e.y - this.player.y);
                     if (dist < this.player.radius * 40 && dist > (window.innerHeight/this.cam.z)/2) {
                         const angle = Math.atan2(e.y - this.player.y, e.x - this.player.x);
                         const edgeDist = Math.min(window.innerWidth, window.innerHeight) * 0.35 / this.cam.z;
                         const ax = this.player.x + Math.cos(angle) * edgeDist;
                         const ay = this.player.y + Math.sin(angle) * edgeDist;
                         
                         this.ctx.save();
                         this.ctx.translate(ax, ay);
                         this.ctx.rotate(angle);
                         this.ctx.fillStyle = e.nameColorOverride || '#FF00FF';
                         this.ctx.beginPath();
                         this.ctx.moveTo(10, 0); this.ctx.lineTo(-10, 10); this.ctx.lineTo(-10, -10);
                         this.ctx.fill();
                         this.ctx.restore();
                     }
                }
            });
        }

        if(this.player && this.player.lightStripActive) {
            this.ctx.save();
            const w = window.innerWidth / this.cam.z;
            const h = window.innerHeight / this.cam.z;
            const cx = this.cam.x, cy = this.cam.y;
            const gSize = 33; 
            
            let gl = this.ctx.createLinearGradient(cx - w/2, 0, cx - w/2 + gSize, 0);
            gl.addColorStop(0, "rgba(255,165,0,0.6)"); gl.addColorStop(1, "rgba(255,165,0,0)");
            this.ctx.fillStyle = gl; this.ctx.fillRect(cx - w/2, cy - h/2, gSize, h);
            
            let gr = this.ctx.createLinearGradient(cx + w/2, 0, cx + w/2 - gSize, 0);
            gr.addColorStop(0, "rgba(255,165,0,0.6)"); gr.addColorStop(1, "rgba(255,165,0,0)");
            this.ctx.fillStyle = gr; this.ctx.fillRect(cx + w/2 - gSize, cy - h/2, gSize, h);
            
            let gt = this.ctx.createLinearGradient(0, cy - h/2, 0, cy - h/2 + gSize);
            gt.addColorStop(0, "rgba(255,165,0,0.6)"); gt.addColorStop(1, "rgba(255,165,0,0)");
            this.ctx.fillStyle = gt; this.ctx.fillRect(cx - w/2, cy - h/2, w, gSize);
            
            let gb = this.ctx.createLinearGradient(0, cy + h/2, 0, cy + h/2 - gSize);
            gb.addColorStop(0, "rgba(255,165,0,0.6)"); gb.addColorStop(1, "rgba(255,165,0,0)");
            this.ctx.fillStyle = gb; this.ctx.fillRect(cx - w/2, cy + h/2 - gSize, w, gSize);
            
            this.ctx.restore();
        }

        if(this.player && this.player.blueStripActive) {
            this.ctx.save();
            const w = window.innerWidth / this.cam.z;
            const h = window.innerHeight / this.cam.z;
            const cx = this.cam.x, cy = this.cam.y;
            const gSize = 33; 
            
            let gl = this.ctx.createLinearGradient(cx - w/2, 0, cx - w/2 + gSize, 0);
            gl.addColorStop(0, "rgba(0, 191, 255, 0.6)"); gl.addColorStop(1, "rgba(0, 191, 255, 0)");
            this.ctx.fillStyle = gl; this.ctx.fillRect(cx - w/2, cy - h/2, gSize, h);
            
            let gr = this.ctx.createLinearGradient(cx + w/2, 0, cx + w/2 - gSize, 0);
            gr.addColorStop(0, "rgba(0, 191, 255, 0.6)"); gr.addColorStop(1, "rgba(0, 191, 255, 0)");
            this.ctx.fillStyle = gr; this.ctx.fillRect(cx + w/2 - gSize, cy - h/2, gSize, h);
            
            let gt = this.ctx.createLinearGradient(0, cy - h/2, 0, cy - h/2 + gSize);
            gt.addColorStop(0, "rgba(0, 191, 255, 0.6)"); gt.addColorStop(1, "rgba(0, 191, 255, 0)");
            this.ctx.fillStyle = gt; this.ctx.fillRect(cx - w/2, cy - h/2, w, gSize);
            
            let gb = this.ctx.createLinearGradient(0, cy + h/2, 0, cy + h/2 - gSize);
            gb.addColorStop(0, "rgba(0, 191, 255, 0.6)"); gb.addColorStop(1, "rgba(0, 191, 255, 0)");
            this.ctx.fillStyle = gb; this.ctx.fillRect(cx - w/2, cy + h/2 - gSize, w, gSize);
            
            this.ctx.restore();
        }

        for(let e of this.entities) {
            if(!e.alive && e.isPlayer) continue; 
            if(e.x+e.radius*3 < vl || e.x-e.radius*3 > vr || e.y+e.radius*3 < vt || e.y-e.radius*3 > vb) continue;
            
            if(e.activeEffects && e.activeEffects.magnet > 0) {
                this.ctx.save();
                this.ctx.translate(e.x, e.y);
                let alpha = 0.2 + Math.abs(Math.sin(Date.now()/500))*0.3;
                this.ctx.globalAlpha = alpha;
                if(e.isSpectral || e.isAnomalyBot) this.ctx.fillStyle = `hsl(${(Date.now()/10)%360},100%,50%)`;
                else this.ctx.fillStyle = "#222";
                this.ctx.beginPath(); this.ctx.arc(0,0,e.radius*(e.magnetRadiusMult || 2.0), 0, Math.PI*2); this.ctx.fill();
                this.ctx.restore();
            }

            if(e.gravityManeuverActive) {
                this.ctx.save();
                this.ctx.translate(e.x, e.y);
                this.ctx.globalAlpha = 0.4;
                this.ctx.fillStyle = e.isSpectral ? `hsl(${(Date.now()/10)%360},100%,50%)` : "#40E0D0";
                this.ctx.beginPath(); this.ctx.arc(0,0,e.radius,0,Math.PI*2); this.ctx.fill();
                let pulse = 1 + Math.sin(Date.now()/100)*0.1;
                this.ctx.globalAlpha = 0.3;
                this.ctx.strokeStyle = "#8A2BE2";
                this.ctx.lineWidth = 5;
                this.ctx.beginPath(); this.ctx.arc(0,0,e.radius*pulse, 0, Math.PI*2); this.ctx.stroke();
                let waveT = (Date.now() % 1000) / 1000; 
                let maxWaveR = e.radius * 6;
                let curWaveR = maxWaveR * (1 - waveT); 
                this.ctx.globalAlpha = 0.5 * waveT; 
                this.ctx.strokeStyle = "#40E0D0";
                this.ctx.lineWidth = 2;
                this.ctx.beginPath(); this.ctx.arc(0,0, curWaveR, 0, Math.PI*2); this.ctx.stroke();
                this.ctx.restore();
            }

            if(e.moons.length > 0) {
                for(let m of e.moons) {
                    this.ctx.save();
                    this.ctx.translate(m.x, m.y);
                    if(m.isStar) {
                        this.ctx.fillStyle = m.color;
                        this.ctx.shadowBlur = 10; this.ctx.shadowColor = m.color;
                        this.ctx.beginPath();
                        const r = m.radius;
                        for(let k=0; k<5; k++) {
                             this.ctx.lineTo(Math.cos((18+k*72)/180*Math.PI)*r, Math.sin((18+k*72)/180*Math.PI)*r);
                             this.ctx.lineTo(Math.cos((54+k*72)/180*Math.PI)*(r/2), Math.sin((54+k*72)/180*Math.PI)*(r/2));
                        }
                        this.ctx.closePath(); this.ctx.fill();
                    } else {
                        if(m.atmosphere) {
                             this.ctx.shadowBlur = m.radius * 0.5;
                             this.ctx.shadowColor = m.atmosphere;
                        }
                        if(!m.texture) {
                            m.texture = AssetManager.getPlanetTexture(m.conf || {color: m.color, detail: m.color, type:1}, m.radius, Math.random()*100);
                        }
                        if(e.conf.id === 'earth' && !m.hasMoonTex && !e.isBoss) {
                            m.texture = AssetManager.moonTexture;
                            m.hasMoonTex = true;
                        }
                        this.ctx.drawImage(m.texture, -m.radius, -m.radius);
                    }
                    this.ctx.shadowBlur = 0;
                    this.ctx.restore();
                }
            }
            
            // Florant shields rendering
            if (e.isFlorant && e.florantShields) {
                e.florantShields.forEach(sh => {
                    this.ctx.save();
                    this.ctx.translate(e.x + Math.cos(sh.angle)*sh.dist, e.y + Math.sin(sh.angle)*sh.dist);
                    this.ctx.fillStyle = '#32CD32';
                    this.ctx.strokeStyle = '#006400';
                    this.ctx.lineWidth = 5;
                    this.ctx.beginPath();
                    this.ctx.arc(0,0, sh.radius, 0, Math.PI*2);
                    this.ctx.fill(); this.ctx.stroke();
                    this.ctx.restore();
                });
            }

            if(e.iceSwordActive) {
                this.ctx.save();
                this.ctx.translate(e.x, e.y);
                this.ctx.rotate(e.iceSwordAngle);
                this.ctx.fillStyle = e.isBoss ? e.bossAtkColor : '#00BFFF'; 
                this.ctx.fillRect(0, -5, e.radius*6, 10);
                this.ctx.restore();
            }

            for(let w of e.waves) {
                this.ctx.save();
                let waveColor = 'rgba(255,50,50,0.5)';
                if (e.isBoss) {
                     let bc = hexToRgb(e.bossAtkColor || '#ff0000');
                     waveColor = `rgba(${bc.r},${bc.g},${bc.b},${w.alpha})`;
                } else if (e.isPlayer && e.conf.id === 'sun') waveColor = `rgba(255,215,0,${w.alpha})`;
                else if (e.conf.category === 'star') waveColor = hexToRgbaStr(e.conf.color, w.alpha); 
                else if (w.isGreat) waveColor = `rgba(138,43,226,${w.alpha})`; 
                
                if (e.conf.id === 'tts16a') {
                     let prog = w.r / w.maxR; 
                     let cHex = '#00FF00';
                     if(prog > 0.33 && prog < 0.66) cHex = '#FFFFFF';
                     if(prog >= 0.66) cHex = '#FF0000';
                     waveColor = hexToRgbaStr(cHex, w.alpha);
                }
                
                if (e.isSpectral && e.isBoss) {
                    waveColor = `hsla(${(Date.now()/5)%360}, 100%, 50%, ${w.alpha})`;
                }

                this.ctx.strokeStyle = waveColor; this.ctx.lineWidth = e.isBoss ? 20 : 10; 
                this.ctx.beginPath(); this.ctx.arc(e.x, e.y, w.r, 0, Math.PI*2); this.ctx.stroke(); 
                this.ctx.restore();
            }

            if(e.conf.hasRing) {
                this.ctx.save();
                this.ctx.translate(e.x, e.y);
                this.ctx.rotate(e.angle); 
                this.ctx.scale(1, e.ringAspect || 0.3); 
                this.ctx.beginPath(); 
                this.ctx.strokeStyle = e.ringColor || 'rgba(200,180,140,0.5)';
                this.ctx.lineWidth = e.ringThick || e.radius*0.4;
                this.ctx.globalAlpha = e.ringAlpha || 1.0;
                this.ctx.arc(0, 0, e.radius*2.2, 0, Math.PI*2); 
                this.ctx.stroke();
                
                if(e.extraRings) {
                    e.extraRings.forEach(er => {
                        this.ctx.beginPath();
                        this.ctx.strokeStyle = er.color;
                        this.ctx.lineWidth = e.radius * er.width;
                        this.ctx.globalAlpha = 0.6;
                        this.ctx.arc(0, 0, e.radius * er.r, 0, Math.PI*2);
                        this.ctx.stroke();
                    });
                }
                
                this.ctx.restore();
            }

            if (e.isTON618 || e.isPhoenix) {
                 this.ctx.save();
                 this.ctx.translate(e.x, e.y);
                 this.ctx.rotate(Date.now() / 1000);
                 let diskColor = e.isTON618 ? 'rgba(245,222,179,0.4)' : 'rgba(135,206,235,0.4)';
                 let diskRadius = e.radius * 3;
                 let innerRadius = e.radius * 1.5;
                 
                 let grad = this.ctx.createRadialGradient(0,0,innerRadius, 0,0,diskRadius);
                 grad.addColorStop(0, diskColor);
                 grad.addColorStop(1, 'rgba(0,0,0,0)');
                 
                 this.ctx.fillStyle = grad;
                 this.ctx.beginPath(); this.ctx.arc(0,0,diskRadius, 0, Math.PI*2); this.ctx.fill();
                 this.ctx.restore();
            }

            if (e.isSpectral || e.isAnomaly) {
                this.ctx.save();
                this.ctx.translate(e.x, e.y);
                this.ctx.beginPath();
                this.ctx.strokeStyle = e.isAnomaly ? `rgba(0,0,0,0.8)` : `hsla(${(Date.now()/5)%360}, 100%, 50%, 0.7)`;
                this.ctx.lineWidth = 10;
                this.ctx.arc(0,0, e.radius * (e.isAnomaly?4:3), 0, Math.PI*2);
                this.ctx.stroke();
                this.ctx.restore();
            }

            this.ctx.save();
            this.ctx.translate(e.x, e.y);
            if (e.slowTimer > 0) this.ctx.globalAlpha = 0.8; 
            
            if(!e.texture || Math.abs(e.textureRadius - e.radius) > 2 || e.isRussianEmpire) {
                e.texture = AssetManager.getPlanetTexture(e.conf, e.radius, e.seed);
                e.shading = AssetManager.getShadingOverlay(e.radius);
                e.textureRadius = e.radius;
            }
            this.ctx.save();
            this.ctx.rotate(e.angle);
            this.ctx.shadowBlur = e.radius * 0.5; this.ctx.shadowColor = e.atmosphereColor; 
            this.ctx.drawImage(e.texture, -e.radius, -e.radius);
            
            if(e.isSpectral) {
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.arc(0,0,e.radius, 0, Math.PI*2);
                this.ctx.clip(); // Fixed clipping

                this.ctx.globalCompositeOperation = 'source-atop';
                this.ctx.globalAlpha = 0.4; 
                let pat = this.ctx.createPattern(AssetManager.rainbowPattern, 'repeat');
                this.ctx.fillStyle = pat;
                this.ctx.fillRect(-e.radius, -e.radius, e.radius*2, e.radius*2);
                this.ctx.globalAlpha = 0.7 + Math.abs(Math.sin(Date.now()/500))*0.3;
                this.ctx.restore();
                
                this.ctx.save();
                this.ctx.globalCompositeOperation = 'overlay';
                let t = (Date.now() * 3) / 1000; 
                let gr = this.ctx.createLinearGradient(-e.radius, -e.radius, e.radius, e.radius);
                gr.addColorStop(0, `hsla(${(t*50)%360},100%,50%,0.4)`);
                gr.addColorStop(1, `hsla(${(t*50+180)%360},100%,50%,0.4)`);
                this.ctx.fillStyle = gr;
                this.ctx.beginPath(); this.ctx.arc(0,0,e.radius*1.2,0,Math.PI*2); this.ctx.fill();
                this.ctx.restore();
            }
            if(e.isStarKing) {
                 let hue = (Date.now()/20) % 360;
                 this.ctx.save();
                 this.ctx.globalCompositeOperation = 'source-atop';
                 this.ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.3)`;
                 this.ctx.fillRect(-e.radius, -e.radius, e.radius*2, e.radius*2);
                 this.ctx.restore();
            }
            
            if(e.isAnomalyBot) {
                 this.ctx.save();
                 this.ctx.globalCompositeOperation = 'overlay';
                 let t = Date.now()/300;
                 let hue = (t * 50) % 360; 
                 this.ctx.fillStyle = `hsla(${hue}, 100%, 60%, 0.5)`;
                 this.ctx.beginPath(); this.ctx.arc(0,0,e.radius,0,Math.PI*2); this.ctx.fill();
                 this.ctx.restore();
            }

            if (e.isEating) {
                this.ctx.save();
                this.ctx.beginPath(); this.ctx.arc(0,0,e.radius,0,Math.PI*2); this.ctx.clip();
                this.ctx.globalCompositeOperation = 'source-atop'; this.ctx.fillStyle = 'rgba(255,100,0,0.5)'; this.ctx.fillRect(-e.radius, -e.radius, e.radius*2, e.radius*2);
                this.ctx.restore();
                e.eatingColorTimer = 3.0;
            }
            if (e.damageTimer > 0 && e.frozenEffectTimer <= 0 && e.slowTimer <= 0) {
                if (Math.floor(Date.now()/50)%2===0) {
                     this.ctx.save();
                     this.ctx.beginPath(); this.ctx.arc(0,0,e.radius,0,Math.PI*2); this.ctx.clip();
                     this.ctx.globalCompositeOperation = 'source-atop'; this.ctx.fillStyle = 'rgba(255,0,0,0.75)'; this.ctx.fillRect(-e.radius, -e.radius, e.radius*2, e.radius*2);
                     this.ctx.restore();
                }
            }
            this.ctx.shadowBlur = 0; this.ctx.restore();

            if (e.isZombie) {
                this.ctx.fillStyle = "rgba(0,0,0,0.7)"; this.ctx.beginPath(); this.ctx.arc(0,0,e.radius,0,Math.PI*2); this.ctx.fill();
            }

            if (e.slowTimer > 0) {
                this.ctx.fillStyle = "rgba(0,0,255,0.3)"; this.ctx.beginPath(); this.ctx.arc(0,0,e.radius,0,Math.PI*2); this.ctx.fill();
            }
            
            if (e.frozenEffectTimer > 0) {
                this.ctx.save();
                this.ctx.beginPath(); this.ctx.arc(0,0,e.radius,0,Math.PI*2); this.ctx.clip();
                let frame = Math.floor(Date.now() / 500) % 3;
                this.ctx.globalAlpha = 0.5;
                this.ctx.fillStyle = e.frozenColor || '#fff';
                this.ctx.globalCompositeOperation = "color";
                this.ctx.fillRect(-e.radius, -e.radius, e.radius*2, e.radius*2);
                this.ctx.globalCompositeOperation = "source-over";
                this.ctx.drawImage(AssetManager.noiseCanvases[frame], -e.radius, -e.radius, e.radius*2, e.radius*2);
                this.ctx.restore();
            }
            
            if(e.isSprinting) {
                this.ctx.save();
                this.ctx.globalCompositeOperation = "lighter";
                this.ctx.fillStyle = "rgba(255,255,255,0.4)"; 
                this.ctx.beginPath(); this.ctx.arc(0,0,e.radius,0,Math.PI*2); this.ctx.fill();
                this.ctx.restore();
            }

            if(e.shieldActive) {
                this.ctx.save();
                this.ctx.globalAlpha = 0.5;
                if(!e.shieldTex) e.shieldTex = AssetManager.getShieldTexture(e.radius*1.15); 
                const sSize = e.radius * 2.5 * 1.3; 
                this.ctx.drawImage(e.shieldTex, -sSize/2, -sSize/2, sSize, sSize);
                this.ctx.restore();
            }
            
            // --- SHIELD HP BAR --- (New Draconic Style)
            if (e.shieldActive && e.shieldHp > 0) {
                 let maxSh = e.maxShieldHp || e.score * 0.2;
                 if(maxSh <= 0) maxSh = 1;
                 let pct = Math.max(0, Math.min(1, e.shieldHp / maxSh));
                 
                 // Color Interpolation: Blue to Purple
                 let r = Math.floor(0 + (128 - 0) * (1-pct));
                 let g = 0;
                 let b = Math.floor(255 + (128 - 255) * (1-pct));
                 let col = `rgb(${r},${g},${b})`;
                 
                 // Bar Background
                 this.ctx.fillStyle = "rgba(0,0,0,0.5)";
                 this.ctx.fillRect(-24, -e.radius - 45, 48, 6);
                 
                 // Bar Fill
                 this.ctx.fillStyle = col;
                 this.ctx.fillRect(-23, -e.radius - 44, 46 * pct, 4);
                 
                 // Text
                 this.ctx.fillStyle = "#fff";
                 this.ctx.font = "bold 10px monospace";
                 this.ctx.textAlign = "center";
                 this.ctx.shadowColor = "#000";
                 this.ctx.shadowBlur = 2;
                 let txt = `–©–∏—Ç: ${Math.floor(e.shieldHp)}/${Math.floor(maxSh)}`;
                 if(ui.lang === 'en') txt = `Shield: ${Math.floor(e.shieldHp)}/${Math.floor(maxSh)}`;
                 this.ctx.fillText(txt, 0, -e.radius - 50);
                 this.ctx.shadowBlur = 0;
            }
            // -------------------------

            this.ctx.drawImage(e.shading, -e.radius, -e.radius);
            
            let nameColor = '#fff';
            if (e.isPlayer) nameColor = e.nameColorOverride || ui.data.color || '#1E90FF';
            else if (e.nameColorOverride) nameColor = e.nameColorOverride;
            else if (!e.isBoss && e.rank <= 5) nameColor = Top5Colors[e.rank - 1]; 
            else nameColor = e.pastelNameColor || '#ffffff'; 

            this.ctx.fillStyle = nameColor; 
            this.ctx.font = `bold ${Math.max(14, e.radius*0.5)}px 'Comic Sans MS'`;
            this.ctx.strokeStyle = "rgba(0,0,0,0.8)";
            this.ctx.lineWidth = 3;
            this.ctx.textAlign = "center"; 
            this.ctx.strokeText(e.name, 0, -e.radius - 15);
            this.ctx.fillText(e.name, 0, -e.radius - 15);

            if (this.hoverEntity === e) {
                this.ctx.fillStyle = "yellow";
                this.ctx.font = "14px monospace";
                this.ctx.fillText(Math.floor(e.score), 0, -e.radius - 35);
            }

            if(e.showBar) {
                this.ctx.fillStyle="black"; this.ctx.fillRect(-20, -e.radius-25, 40, 5);
                this.ctx.fillStyle="red"; this.ctx.fillRect(-19, -e.radius-24, 38*e.barValue, 3);
                e.showBar = false;
            }
            this.ctx.restore();
            this.ctx.globalAlpha = 1.0;
        }
        
        for(let ft of this.floatingTexts) {
            this.ctx.save();
            this.ctx.translate(ft.x, ft.y);
            this.ctx.fillStyle = ft.color;
            this.ctx.font = "bold 20px monospace";
            this.ctx.textAlign = "center";
            this.ctx.shadowColor = "black";
            this.ctx.shadowBlur = 2;
            this.ctx.fillText(ft.text, 0, 0);
            this.ctx.restore();
        }

        if (this.protectionTimer > 0) {
            this.ctx.save();
            this.ctx.translate(this.cam.x, this.cam.y);
            this.ctx.fillStyle = "rgba(0, 255, 255, 0.5)";
            this.ctx.font = "bold 40px 'Comic Sans MS'";
            this.ctx.textAlign = "center";
            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = "black";
            this.ctx.strokeStyle = "black";
            this.ctx.lineWidth = 4;
            let msg = "–ó–ê–©–ò–¢–ê: " + Math.ceil(this.protectionTimer);
            this.ctx.strokeText(msg, 0, -window.innerHeight/2/this.cam.z + 100);
            this.ctx.fillText(msg, 0, -window.innerHeight/2/this.cam.z + 100);
            this.ctx.restore();
        }
        
        this.ctx.restore();
    }
    drawMinimap() {
        const s = 150, sc = s/CONFIG.mapSize, ctx = this.miniCtx;
        ctx.clearRect(0,0,s,s); ctx.strokeStyle="#444"; ctx.strokeRect(0,0,s,s);
        
        ctx.beginPath();
        ctx.strokeStyle = "red";
        ctx.lineWidth = 1;
        
        let baseR = CONFIG.mapSize;
        if(this.arenaMode === 'royal') baseR = CONFIG.mapSize * 1.4;
        else if(this.arenaMode === 'duel' || this.arenaMode === 'mini' || this.arenaMode === 'arena' || this.arenaMode === '5vs1') baseR = CONFIG.mapSize * 1.5;
        if(this.arenaMode === 'survival_random') baseR = 10000;
        if(this.arenaMode === 'random_start') baseR = 10000;
        if(this.arenaMode === 'team') baseR = CONFIG.mapSize / 3;
        if(this.arenaMode === '5vs1') baseR = CONFIG.mapSize / 2;

        const sf = 75 / baseR;
        
        ctx.arc(s/2, s/2, this.zoneRadius * sf, 0, Math.PI*2);
        ctx.stroke();

        for(let e of this.entities) {
            let x = s/2 + e.x*sf, y = s/2 + e.y*sf;
            if(x<0||x>s||y<0||y>s) continue;
            if (e.isBoss) { ctx.font = "14px Arial"; ctx.textAlign = "center"; ctx.textBaseline="middle"; ctx.fillText("üåÄ", x, y); } 
            else { 
                let col = "red";
                if (e === this.player) col = "#0f0";
                else if (e.team === 'blue') col = '#44f';
                else if (e.team === 'red') col = '#f44';
                else if (e.rank <= 5) col = Top5Colors[e.rank - 1]; 
                if (e.isZombie) col = '#000';
                if (e.isSurvivor) col = '#0f0';
                if (e.isAnomalyBot) {
                     // Pulsing Violet for Anomaly
                     let t = (Date.now() % 1000) / 1000; 
                     let light = 40 + t * 40; 
                     col = `hsl(280, 100%, ${light}%)`;
                }

                ctx.fillStyle = col; 
                ctx.beginPath(); ctx.arc(x, y, (e===this.player)?3:2, 0, Math.PI*2); ctx.fill(); 
            }
        }
    }
    menuLoop() { if(this.active) return; this.ctx.fillStyle='#050a10'; this.ctx.fillRect(0,0,this.canvas.width/window.devicePixelRatio,this.canvas.height/window.devicePixelRatio); requestAnimationFrame(()=>this.menuLoop()); }
    gameOver() {
        if(this.modeSettings.secondChance && this.player.hasSecondChance) {
             this.player.hasSecondChance = false;
             this.player.score *= 0.5; this.player.alive = true; this.gameOverSequence = false;
             this.player.x = (Math.random()-0.5)*this.zoneRadius; this.player.y = (Math.random()-0.5)*this.zoneRadius;
             this.player.damageTimer = 0; this.player.shieldHp = 500; this.player.shieldActive = true;
             ui.notify("–í–¢–û–†–ê–Ø –ü–û–ü–´–¢–ö–ê!");
             return;
        }
        this.active = false;
        const score = Math.floor(this.player.score);
        const coins = Math.floor(score / 5);
        document.getElementById('finalScore').innerText = score;
        document.getElementById('finalCoins').innerText = coins;
        ui.addCoins(coins);
        this.gameOverSequence = false;
        document.getElementById('ui-layer').style.display='none';
        this.menuLoop();
    }
}

class Entity {
    constructor(x, y, conf, isPlayer, name, colorOverride) {
        this.x = x; this.y = y; this.conf = conf; this.isPlayer = isPlayer; this.name = name;
        this.score = 50; this.radius = CONFIG.baseSize; this.angle = 0; this.alive = true;
        this.vx = 0; this.vy = 0;
        this.inventory = { type: null, count: 0 }; 
        this.activeEffects = { speed: 0, magnet: 0, grow: 0, bonus: 0 };
        this.effectTimer = 0; this.cooldownTimer = 0; this.effectMax = 0; this.effectPower = 1;
        this.texture = null; this.textureRadius = 0; this.seed = Math.random()*1000;
        this.eatingProgress = 0; this.isSprinting = false; this.boostTimer = 0;
        this.inRing = false; this.isBoss = false; this.bossState = 0; 
        this.slowTimer = 0; this.waves = []; this.waveCD = 10; 
        this.magnetRadiusMult = 1.0;
        
        this.npcItemTimer = 15 + Math.random()*45;
        this.isBigBoss = false; 

        let baseAmmo = 3;
        let baseReload = (conf.id === 'earth' || conf.id === 'sun') ? 10 : 15;
        if (isPlayer) {
             let lvl = ui.data.upgradeAmmo || 0;
             baseAmmo += lvl; 
             if (lvl === 1) baseReload = 10;
             if (lvl === 2) baseReload = 8;
             if (lvl === 3) baseReload = 6;
             if (lvl === 4) baseReload = 5;
        }
        this.ammo = baseAmmo; this.maxAmmo = baseAmmo; 
        this.reloadTime = baseReload;

        this.reloadTimer = 0; this.fireTimer = 0;
        this.aimDelay = 0; 
        this.frozenEffectTimer = 0;
        this.frozenDoTTimer = 0;
        this.frozenColor = '#fff';
        this.burnTimer = 0;
        this.damageTimer = 0; 
        this.eatingColorTimer = 0;
        this.isAiming = false; 
        this.moons = [];
        this.moonCD = 0;
        this.bossAttackType = 0; 
        this.bossSubTimer = 0;
        this.bossTargetAngle = 0;
        this.bossOrbitAngle = 0;
        this.bossAtkColor = '#FF0000';
        this.bossDoubleWave = 0; 
        this.isSpectral = false;
        this.isAnomaly = false;
        this.isTON618 = false;
        this.isPhoenix = false;
        this.isProbe = false;
        this.isStarKing = false;
        this.isFlorant = false;
        this.isHunter = false;
        this.isAnomalyBot = false;
        this.isAgilityBoss = false;
        this.hunterState = 'roam'; // roam, chase, flee

        this.rayCD = 0;
        this.rayState = 0; 
        this.rayTimer = 0;
        this.rayAngle = 0;
        
        this.shieldActive = false;
        this.shieldHp = 0;
        this.maxShieldHp = 0; // Added for HP Bar
        this.shieldCD = 0;
        this.shieldDecayTimer = 0;
        
        this.lightStripActive = false;
        this.lightStripTimer = 0;
        this.lightStripCD = 0;
        this.lightStripFireTimer = 0;
        this.lightStripMaxTime = (conf.id === 'venus' || conf.id === 'jupiter' || conf.id === 'saturn') ? 30 : ((conf.category === 'star' || conf.id === 'tts16a') ? 35 : 25);
        
        this.blueStripActive = false;
        this.blueStripTimer = 0;
        this.blueStripCD = 0;
        this.blueStripFireTimer = 0;
        this.aiBlueStripCooldown = 60 + Math.random() * 60;
        
        this.blueBulletCD = 0;
        
        this.vampireStock = 5;
        this.vampireTimer = 0;
        this.vampireFireCD = 0;
        this.vampireDot = null;
        
        this.iceSwordActive = false;
        this.iceSwordCD = 0;
        this.iceSwordTimer = 0;
        this.iceSwordAngle = 0;
        this.iceSwordSpeed = 0;
        this.iceSwordHitTimer = 0;

        this.gravityManeuverActive = false;
        this.gravityManeuverTimer = 0;
        this.gravityManeuverCD = 0;
        this.gravityManeuverRadius = 0;

        this.dmgTextAccumulator = 0;
        this.dmgTextTimer = 0;
        
        this.damageTakenTimer = 0;
        this.regenTimer = 0;
        this.decayTimer = 0;
        
        this.florantShields = [];
        this.florantSpawnTimer = 0;

        this.rank = 100; 
        this.pastelNameColor = PastelColors[Math.floor(Math.random() * PastelColors.length)] || '#ffffff'; 
        
        // Bot AI
        this.aiTargetX = this.x;
        this.aiTargetY = this.y;
        this.aiRetargetTimer = 0;
        this.aiSprintTimer = 0;
        this.aiPanicTimer = 0;
        this.aiLightStripTimer = 0;

        if(conf.hasRing) {
             this.ringColor = conf.ringColor || randomColor();
             this.ringAngle = (Math.random() - 0.5) * Math.PI;
             this.ringAspect = 0.2 + Math.random() * 0.5;
             this.ringThick = this.radius * (0.2 + Math.random() * 0.4);
             this.ringAlpha = 0.4 + Math.random() * 0.4;
             
             this.extraRings = [];
             let count = 1 + Math.floor(Math.random() * 5);
             for(let i=0; i<count; i++) {
                 this.extraRings.push({
                     r: 1.2 + Math.random() * 0.8,
                     color: randomColor(),
                     width: 0.02 + Math.random()*0.05
                 });
             }
        }
        
        if (this.isFlorant) {
            for(let i=0; i<6; i++) {
                this.florantShields.push({
                    angle: i * (Math.PI/3),
                    dist: this.radius * 2.5,
                    radius: this.radius * 0.4,
                });
            }
        }

        this.greatImpactCD = 0;
        this.greatImpactState = 0; 
        this.greatImpactTimer = 0;

        if (isPlayer) {
            if (conf.id !== 'earth') {
                 this.atmosphereColor = hexToRgbaStr(conf.color, 0.6);
            } else {
                 this.atmosphereColor = hexToRgbaStr(colorOverride || '#1E90FF', 0.6);
            }
        } else {
            if (conf.color) this.atmosphereColor = hexToRgbaStr(conf.color, 0.6);
            else {
                const colors = ['#f00', '#0f0', '#00f', '#ff0', '#0ff', '#f0f'];
                this.atmosphereColor = hexToRgbaStr(colors[Math.floor(Math.random() * colors.length)], 0.6);
            }
        }

        if(isPlayer && ui.data.upgradeSecondChance) {
             let chance = Math.min(300, ui.data.upgradeSecondChance * 10);
             if(Math.random() * 100 < chance) this.hasSecondChance = true;
        }

        this.isZombie = false;
        this.isSurvivor = false;
        this.respawnTimer = 0;
        this.respawnPending = false;
        this.isRussianEmpire = false;
        this.flagSwapTimer = 0;
        this.reState = false; 
    }
    get mass() { return this.score; }
    
    makeZombie() {
        this.isZombie = true; this.isSurvivor = false;
        this.nameColorOverride = '#f00';
        this.conf.hasRing = false; 
        this.radius = CONFIG.baseSize * 1.5;
    }

    makeSurvivor() {
        this.isZombie = false; this.isSurvivor = true;
        this.nameColorOverride = '#0f0';
    }

    addScore(val) { 
        if (isNaN(val)) return;
        this.score += val; 
        if (this.isPlayer) game.showFloatingText(this.x, this.y - this.radius, "+" + Math.floor(val), "#0f0");
    }
    
    kill() { 
        if(this.respawnPending) return;

        if (game.arenaMode === '5vs1' && !this.isBigBoss) {
            this.respawnPending = true;
            this.respawnTimer = 5.0;
            this.alive = false; 
            game.explodeEntity(this);
            return;
        }

        this.alive = false; 
        if (this.isPlayer) {
            game.gameOverSequence = true;
        }
    }

    takeDamage(amount, silent) {
        if(game.protectionTimer > 0) return;
        if(game.gameTime < 10) return; 
        if(game.mod.immunity >= 100 && this.isPlayer) return; 
        if(isNaN(amount)) return;
        
        if (this.isAnomalyBot) amount *= 20; // Anomaly takes more damage

        let resist = 0;
        if (this.score >= 2000) resist = 0.95;
        else if (this.score >= 1000) resist = 0.90 + ((this.score - 1000)/1000) * 0.05;
        else if (this.score >= 500) resist = 0.65 + ((this.score - 500)/500) * 0.25;
        else resist = (this.score / 500) * 0.65;
        
        amount *= (1.0 - resist);

        if(this.isPlayer) {
            let evadeChance = 0;
            if (this.conf.id === 'jupiter') evadeChance = 0.05;
            else if (this.conf.id === 'betelgeuse') evadeChance = 0.10;
            else if (this.conf.id === 'sun' || this.conf.id === 'sirius') evadeChance = 0.07;
            
            if (Math.random() < evadeChance) {
                if(!silent) game.showFloatingText(this.x, this.y - this.radius, "–£–ö–õ–û–ù–ï–ù–ò–ï!", "lime");
                return;
            }
        }

        if(this.shieldActive) {
             amount /= (game.gameTime > 4) ? 5 : 10;
        }
        
        this.score -= amount;
        if (isNaN(this.score)) this.score = 0;

        if (this.isZombie && this.score < 50) {
            this.makeSurvivor();
            ui.notify("–ó–û–ú–ë–ò –ò–°–¶–ï–õ–ï–ù!");
        }

        this.damageTimer = 0.5;
        this.damageTakenTimer = 0; 

        if(this.isPlayer && !silent) {
            this.dmgTextAccumulator += amount;
            if(this.dmgTextTimer <= 0) {
                 game.showFloatingText(this.x, this.y - this.radius, "-" + Math.floor(this.dmgTextAccumulator), "red");
                 this.dmgTextAccumulator = 0;
                 this.dmgTextTimer = 0.2;
            }
        }
    }
    
    pickupItem(type) { 
        if (this.isPlayer) {
            ui.addItem(type);
            return true;
        } else {
            if(this.inventory.count < 2) {
                if (this.inventory.count === 0) this.inventory.type = type;
                if (this.inventory.type === type) { this.inventory.count++; return true; }
            }
            return false;
        }
    }
    
    useItem(type) { 
        if (!type && this.inventory.type) type = this.inventory.type;
        
        if (!this.isPlayer) {
             if(this.inventory.count > 0 && this.cooldownTimer <= 0) { 
                this.inventory.count--;
                const conf = ITEMS_TYPES[this.inventory.type]; 
                this.activeEffects[this.inventory.type] = conf.duration;
                if (this.inventory.count === 0) this.inventory.type = null;
             }
             return;
        }
        
        if (this.activeEffects[type] > 0) return; 

        const conf = ITEMS_TYPES[type];
        let duration = conf.duration + (ui.data.upgrades[type]||0);
        this.activeEffects[type] = duration;
        ui.notify(ITEMS_TYPES[type].name+"!");
        ui.updateInventoryDisplay(); 
    }

    useWave(isGreat = false) { 
        if(this.waveCD <= 0 || isGreat) { 
            let waveR = 0; 
            if (!this.isBoss && !isGreat) this.waveCD = (15 + Math.random() * 15) * 1.75; 
            this.waves.push({ r: 0, alpha: 1, isGreat: isGreat, maxR: 0 }); 
        } 
    }
    useGreatImpact() {
        if(this.greatImpactCD <= 0) {
            this.greatImpactState = 1;
            this.greatImpactTimer = 0;
            if(this.isPlayer) this.greatImpactCD = 100; else this.greatImpactCD = (100 + Math.random()*130) * 1.75;
        }
    }
    useRay() {
        if(this.rayCD <= 0) {
            this.rayState = 1; 
            this.rayTimer = (this.conf.id==='earth' || this.conf.id==='venus' ? 1.72 : 1.5) * (this.conf.id==='jupiter'?1.5:1.0);
            if(this.conf.category === 'star' || this.conf.id === 'tts16a' || this.isPhoenix || this.isTON618) this.rayTimer *= 2;
            
            if(this.isBoss) {
                if (game.bossStage === 1) this.rayTimer = 5.0;
                else this.rayTimer = 5 * Math.pow(1.1, game.bossStage - 1);
            }
            if(this.isPhoenix) this.rayTimer = 2.0;

            let target = null;
            let minDist = 99999;
            // Boss Aiming Fix
            let searchRad = 2000;
            if (this.isBoss) searchRad = 4000;
            
            // Find biggest nearby target
            let bestTarget = null;
            let maxScore = -1;

            if (game.activeBoss && Math.hypot(game.activeBoss.x-this.x, game.activeBoss.y-this.y) < 2000 && !this.isBoss) {
                target = game.activeBoss;
            } else {
                for(let e of game.entities) {
                    if(e !== this && e.alive && Math.abs(e.x-this.x) < searchRad && Math.abs(e.y-this.y) < searchRad) {
                         if (this.isBoss && e.isBoss) continue; // Boss don't attack boss
                         if (this.isBoss && e.isProbe) continue;
                         
                         let d = Math.hypot(e.x-this.x, e.y-this.y);
                         if (d < searchRad) {
                             if (e.score > maxScore) {
                                 maxScore = e.score;
                                 bestTarget = e;
                             }
                         }
                    }
                }
                target = bestTarget;
            }
            if(target) this.rayAngle = Math.atan2(target.y-this.y, target.x-this.x);
            else this.rayAngle = this.angle; 

            if(this.conf.id === 'venus') this.rayAngle += (Math.random()-0.5)*0.35; 
            if(this.isPlayer) this.rayCD = 40; else this.rayCD = (40 + Math.random()*80) * 1.75;
        }
    }
    useGravityManeuver() {
        if (this.gravityManeuverCD > 0) return;
        
        let dur = 3;
        if(this.isPlayer) {
            if(this.conf.category === 'gas') dur = 4;
            if(this.conf.category === 'star') dur = 5;
        } else if (this.isBoss) {
            dur = 5 + game.bossStage * 0.5;
        } else {
            dur = 3 + Math.random();
        }

        let radiusMult = 1.0;
        if (this.isBoss) {
            radiusMult = 1.0 + (game.bossStage * 0.1);
        }

        this.gravityManeuverActive = true;
        this.gravityManeuverTimer = dur;
        this.gravityManeuverRadius = this.radius * 6 * radiusMult; 
        
        if (this.isPlayer) ui.notify("–ì–†–ê–í–ò–¢–ê–¶–ò–û–ù–ù–´–ô –ú–ê–ù–Å–í–†!");
    }
    autoFire(game) {
        if(this.ammo > 0 && this.fireTimer <= 0) {
            let target = null; let minD = 1200;
            for(let e of game.entities) {
                if(e === this) continue;
                let d = Math.hypot(e.x-this.x, e.y-this.y);
                if(d < minD) { minD = d; target = e; }
            }
            if(target) this.fireSnowball(target.x-this.x, target.y-this.y);
        }
    }
    spawnMoon() {
        if (this.moonCD > 0 && this.conf.id !== 'mercury') return;
        if (this.conf.id === 'mercury') { this.addScore(30); if(this.isPlayer) ui.notify("–£ –ú–µ—Ä–∫—É—Ä–∏—è –Ω–µ—Ç —Å–ø—É—Ç–Ω–∏–∫–∞!"); return; }
        
        this.moonCD = 20;

        if (this.conf.id === 'venus' && this.isPlayer) {
            ui.notify("–£ –í–µ–Ω–µ—Ä—ã –Ω–µ—Ç —Å–ø—É—Ç–Ω–∏–∫–æ–≤!");
        }

        if (this.isBoss && this.activeBoss) {
            let count = 4;
            let col = this.bossAtkColor || '#ff0000';
            
            if (this.isProbe) {
                 count = 4; col = '#ff0000';
                 for(let i=0; i<count; i++) {
                    this.moons.push({
                        angle: i*(Math.PI*2/count), dist: this.radius*3, radius: this.radius*0.1, 
                        speed: (2*Math.PI) * 1.5, color: col, revs:0, maxRevs:999,
                        dmgMult: 1.0
                    });
                 }
                 return;
            }

            if (this.isStarKing) {
                count = 10; 
                for(let i=0; i<count; i++) {
                    this.moons.push({
                        angle: i * (Math.PI * 2 / count),
                        dist: this.radius * 2.5,
                        radius: this.radius * 0.3,
                        speed: 1.0, 
                        color: '#ffff00', 
                        isStar: true, 
                        revs: 0, 
                        maxRevs: 999, 
                        dmgMult: 2.0
                    });
                }
                return;
            }

            if (this.isTON618) {
                 count = 6; col = '#F5DEB3';
                 for(let i=0; i<count; i++) {
                    this.moons.push({
                        angle: i*(Math.PI*2/count), dist: this.radius*4, radius: this.radius*0.5, 
                        speed: (2*Math.PI) / 3.0, color: col, revs:0, maxRevs:999,
                        dmgMult: 4.0 
                    });
                 }
                 return;
            }

            for(let i=0; i<count; i++) {
                this.moons.push({
                    angle: i*(Math.PI*2/count), dist: this.radius*3, radius: this.radius*0.25, 
                    speed: (2*Math.PI)/4.0, color: col, revs:0, maxRevs:5
                });
            }
            return;
        }

        if (this.conf.id === 'sun') {
             const grp1 = [
                 { id:'mercury', r:0.85, c:'#A9A9A9' }, { id:'venus', r:1.0, c:'#F4A460' }, { id:'earth', r:1.0, c:'#1E90FF' }, { id:'mars', r:0.85, c:'#CD5C5C' }
             ];
             const grp2 = [
                 { id:'jupiter', r:1.5, c:'#DEB887' }, { id:'saturn', r:1.4, c:'#F4A460' }, { id:'uranus', r:1.25, c:'#AFEEEE' }, { id:'neptune', r:1.2, c:'#4169E1' }
             ];
             
             grp1.forEach((m, i) => {
                 this.moons.push({
                     angle: i * (Math.PI/2), dist: this.radius * 3, radius: this.radius * 0.3 * m.r,
                     speed: ((2*Math.PI)/5.0) * 1.5, color: m.c, conf: PLANETS.find(p=>p.id===m.id), revs: 0, maxRevs: 5, dmgMult: 1.0
                 });
             });
             grp2.forEach((m, i) => {
                 this.moons.push({
                     angle: i * (Math.PI/2) + (Math.PI/4), dist: (this.radius * 3) * 1.3, radius: this.radius * 0.3 * m.r,
                     speed: (2*Math.PI)/5.0, color: m.c, conf: PLANETS.find(p=>p.id===m.id), revs: 0, maxRevs: 5, dmgMult: 1.3
                 });
             });
             return;
        }
        
        if (this.conf.id === 'sirius' || this.conf.id === 'betelgeuse') {
            let col = (this.conf.id === 'sirius') ? '#A0D2FF' : '#FF4500';
            let atmos = (this.conf.id === 'sirius') ? 'rgba(160,210,255,0.5)' : 'rgba(255,69,0,0.5)';
            this.moons.push({
                angle: 0, dist: (this.radius * 3) * 1.15, radius: (this.radius * 0.3) * 1.3,
                speed: (2*Math.PI)/4.5, color: col, atmosphere: atmos, revs: 0, maxRevs: 5, dmgMult: 2.0
            });
            return;
        }

        if (this.conf.id === 'jupiter') {
            const jMoons = [ {color: '#8B4513', size: 1.2}, {color: '#FFFF00', size: 1.0}, {color: '#888888', size: 1.0}, {color: '#FFFFFF', size: 0.8} ];
            jMoons.forEach((m, i) => {
                this.moons.push({
                    angle: i*(Math.PI/2), dist: this.radius*3, radius: this.radius*0.3*m.size, speed: (2*Math.PI)/4.5, color: m.color, revs:0, maxRevs:5
                });
            });
            return;
        }

        let count = (this.conf.id === 'mars') ? 2 : (this.conf.id === 'venus' ? 2 : 1);
        let speed = (this.conf.type === 2 || this.conf.type === 4) ? (2*Math.PI)/3.5 : (2*Math.PI)/4.5;
        let color = '#888';
        if (this.conf.id !== 'earth') color = adjustColor(this.conf.color, 20);

        for(let i=0; i<count; i++) {
            if(this.conf.id === 'venus') {
                this.fireSnowball(100, 100); this.fireSnowball(-100, 100);
            } else {
                let mRadius = (this.conf.id === 'mars') ? this.radius * 0.05 : this.radius * 0.3;
                let startAng = (i===0) ? 0 : Math.PI;
                this.moons.push({
                    angle: startAng, dist: this.radius * 3, radius: mRadius, speed: speed, color: color, revs: 0, maxRevs: 5
                });
            }
        }
    }
    activateShield() {
        if(this.shieldCD > 0) return;
        this.shieldActive = true;
        this.shieldHp = this.score * 0.2;
        this.maxShieldHp = this.shieldHp; // Set Max HP for Bar
        this.shieldCD = 25;
        if(this.isPlayer) ui.notify("–©–ò–¢!");
    }
    activateIceSword() {
        if(this.iceSwordCD > 0) return;
        this.iceSwordActive = true;
        this.iceSwordTimer = 0;
        this.iceSwordAngle = this.angle;
        this.iceSwordSpeed = 0;
        this.iceSwordCD = 30;
    }
    toggleLightStrip() {
        if (this.blueStripActive) this.toggleBlueStrip();

        if(this.lightStripCD > 0 && !this.lightStripActive) return;
        this.lightStripActive = !this.lightStripActive;
        const btn = document.getElementById('btnStrip');
        const txt = document.getElementById('lightStripText');
        if(this.lightStripActive) {
            btn.classList.add('active-mode');
            txt.style.display = 'block';
            this.lightStripTimer = this.lightStripMaxTime;
        } else {
            btn.classList.remove('active-mode');
            txt.style.display = 'none';
            const cd = (this.conf.id === 'venus') ? 20 : 30;
            this.lightStripCD = cd;
        }
    }
    toggleBlueStrip() {
        if (this.lightStripActive) this.toggleLightStrip();

        if (this.blueStripCD > 0 && !this.blueStripActive) return;
        
        this.blueStripActive = !this.blueStripActive;
        
        if (this.isPlayer) {
            const btn = document.getElementById('btnBlueStrip');
            const txt = document.getElementById('blueStripText');
            if (this.blueStripActive) {
                btn.classList.add('blue-active-mode');
                txt.style.display = 'block';
                this.blueStripTimer = 23.0; 
            } else {
                btn.classList.remove('blue-active-mode');
                txt.style.display = 'none';
                this.blueStripCD = 30;
            }
        } else {
            if (this.blueStripActive) this.blueStripTimer = 1 + Math.random() * 9;
            else this.blueStripCD = 30;
        }
    }
    fireLightStrip() {
        if(this.lightStripFireTimer > 0) return;
        this.score *= 0.99;
        
        let fireRate = (this.conf.id === 'venus') ? 0.15 : 0.55; 
        if (this.isProbe) fireRate = 0.5;
        if (this.isAgilityBoss) fireRate = 1.0;

        this.lightStripFireTimer = fireRate;
        
        const count = (this.conf.id === 'mercury') ? 3 : 1;
        let angle = 0;
        if(this.isPlayer) {
             if(game.isMobile) angle = Math.atan2(game.joystick.dy, game.joystick.dx);
             else {
                 let dx = game.mouse.x; let dy = game.mouse.y; 
                 angle = Math.atan2(dy, dx);
             }
        } else {
             angle = this.angle;
             if (this.isAgilityBoss) {
                 angle = Math.atan2(game.player.y - this.y, game.player.x - this.x);
             }
             if (this.isProbe) {
                 let target = game.player;
                 let maxScore = -1;
                 for(let e of game.entities) {
                     if(!e.isBoss && !e.isProbe && Math.hypot(e.x-this.x, e.y-this.y) < 1500) {
                         if (e.score > maxScore) { maxScore = e.score; target = e; }
                     }
                 }
                 if(target) angle = Math.atan2(target.y - this.y, target.x - this.x);
             }
        }

        for(let i=0; i<count; i++) {
            let fireAng = angle;
            let dmgMult = 1.0;
            let sizeMult = 1.0;

            if (this.conf.id === 'mercury') {
                if(i===1) { fireAng -= 0.13; dmgMult = 0.75; sizeMult = 0.7; }
                if(i===2) { fireAng += 0.13; dmgMult = 0.75; sizeMult = 0.7; }
                if(i===0) { dmgMult = 1.25; sizeMult = 1.15; }
            } else if (this.conf.id === 'venus') { 
                dmgMult = 0.35; fireAng += (Math.random()-0.5)*0.2; 
            } else if (this.conf.category === 'star' || this.conf.id === 'tts16a') {
                dmgMult = 2.0; 
                if (this.conf.id === 'betelgeuse') dmgMult = 3.0; 
            } else if (this.isProbe) {
                 dmgMult = 1.5;
            }

            const speed = (this.radius * 2) * 8 * (this.conf.id==='venus'?1.25:1.0); 
            game.snowballs.push({
                x: this.x + Math.cos(fireAng)*(this.radius+10), y: this.y + Math.sin(fireAng)*(this.radius+10),
                vx: Math.cos(fireAng)*speed, vy: Math.sin(fireAng)*speed,
                radius: 1, color: (this.conf.id==='sirius'?'#00BFFF':(this.conf.id==='betelgeuse' || this.isProbe || this.isAgilityBoss ?'#ff0000':'#ff0')), owner: this, life: 3.0, type: 'strip',
                len: this.radius * sizeMult, wid: (this.radius/8) * sizeMult, damage: this.score * 0.0175 * dmgMult,
                isTTS: (this.conf.id === 'tts16a')
            });
        }
    }
    fireBlueStrip() {
        if (this.blueStripFireTimer > 0) return;
        
        let dmg = 1;
        let cost = 1;
        let costChance = 0.4;

        if (this.score >= 1000) { dmg = 10; cost = 7; costChance = 1.0; }
        else if (this.score >= 500) { 
            let t = (this.score - 500) / 500;
            dmg = 7 + t * 3; 
            cost = 5 + t * 2;
            costChance = 0.75;
        }
        else if (this.score >= 200) {
            let t = (this.score - 200) / 300;
            dmg = 4 + t * 3;
            cost = 3 + t * 2;
            costChance = 0.8; 
        }
        else if (this.score >= 100) {
            let t = (this.score - 100) / 100;
            dmg = 2 + t * 2;
            cost = 1 + t * 2;
            costChance = 0.8;
        }
        else if (this.score > 70) {
            dmg = 1.5; cost = 1; costChance = 0.6;
        }

        if (Math.random() < costChance) {
            this.score -= cost;
            if (this.isPlayer) game.showFloatingText(this.x, this.y - this.radius, "-" + Math.floor(cost), "cyan");
            if (this.score <= 25 && !this.isBoss && !this.isPlayer) this.kill();
            if (this.score <= 25 && this.isPlayer) { /* Player dies in update */ }
        }

        this.blueStripFireTimer = 0.23;

        let angle = this.angle;
        if (this.isPlayer) {
             if(game.isMobile) angle = Math.atan2(game.joystick.dy, game.joystick.dx);
             else angle = Math.atan2(game.mouse.y, game.mouse.x);
        } else if (this.aiTargetX) {
             angle = Math.atan2(this.aiTargetY - this.y, this.aiTargetX - this.x);
        }

        let spread = (Math.random() * 2) * (Math.PI / 180);
        if (Math.random() < 0.5) spread *= -1;
        angle += spread;

        let len = (this.radius * 0.5); 
        let wid = (this.radius / 16); 
        
        let speed = (this.radius * 2) * 8 * 1.75; 

        game.snowballs.push({
            x: this.x + Math.cos(angle)*(this.radius+10), 
            y: this.y + Math.sin(angle)*(this.radius+10),
            vx: Math.cos(angle)*speed, 
            vy: Math.sin(angle)*speed,
            radius: 1, 
            color: '#00BFFF', 
            owner: this, 
            life: 2.0, 
            type: 'strip',
            len: len, 
            wid: wid, 
            damage: dmg,
            isTTS: false
        });
    }
    fireBlueBullet() {
        if(this.blueBulletCD > 0) return;
        this.blueBulletCD = 40; 
        let target = null, minD=9999;
        let searchRad = 2000;
        if (this.isHunter) searchRad = 4000;
        for(let e of game.entities) { 
            if(e!==this && e.alive && Math.hypot(e.x-this.x, e.y-this.y) < searchRad) { 
                let d=Math.hypot(e.x-this.x, e.y-this.y); 
                if(d<minD){minD=d; target=e;} 
            } 
        }
        if(!target && this.isPlayer) { target = {x: this.x + Math.cos(this.angle)*500, y: this.y + Math.sin(this.angle)*500, alive:false}; }
        
        if (target) {
            let spd = (this.radius * 2) * 8 * (this.conf.id==='jupiter'?0.9:1.85) * 1.5; 
            let ang = Math.atan2(target.y-this.y, target.x-this.x);
            game.snowballs.push({
                x:this.x, y:this.y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd,
                radius:1, color:'#0ff', owner:this, life:2.5, type:'blueBullet',
                len:this.radius, wid:this.radius/8, damage:0, target:target
            });
        }
    }
    fireVampire() {
        if(this.vampireFireCD > 0 || this.vampireStock <= 0) return;
        this.vampireStock--;
        this.vampireFireCD = 1.0;
        let target = null, minD=9999;
        let searchRad = 2000;
        for(let e of game.entities) { 
            if(e!==this && e.alive && Math.hypot(e.x-this.x, e.y-this.y) < searchRad) { 
                let d=Math.hypot(e.x-this.x, e.y-this.y); if(d<minD){minD=d; target=e;} 
            } 
        }
        if(!target && this.isPlayer) target = {x:this.x+Math.cos(this.angle)*500, y:this.y+Math.sin(this.angle)*500, alive:false};
        
        if (target) {
            let spd = ((this.radius * 2) * 8 * 1.2) / 1.25; 
            let ang = Math.atan2(target.y-this.y, target.x-this.x);
            let size = (this.radius/2); 
            // Calculate 9% of current score as snapshot
            let dmgSnapshot = this.score * 0.09;
            if(isNaN(dmgSnapshot)) dmgSnapshot = 0;

            game.snowballs.push({
                x:this.x, y:this.y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd,
                radius:size, color:'#f00', owner:this, life:3.0, type:'vampire',
                damageSnapshot: dmgSnapshot, target:target 
            });
        }
    }
    fireSnowball(dx, dy) {
        if (this.ammo > 0 && this.fireTimer <= 0) {
            this.ammo--;
            this.fireTimer = 1.0; 
            const angle = Math.atan2(dy, dx);
            const size = this.radius / 3;
            let lvl = (this.isPlayer ? (ui.data.abilityLevels?.snowball || 0) : 0);
            let finalSize = size * (1 + lvl * 0.075);
            let color = '#eeeeee';
            
            if (this.conf.id === 'mercury') color = '#887766';
            else if (this.conf.id === 'venus') color = '#ddaa00';
            else if (this.conf.id === 'earth') color = '#ffffff';
            else if (this.conf.type === 1 || this.conf.type === 3 || this.isBoss) color = this.conf.color;
            
            if (game.arenaMode === 'countryballs') {
                 color = '#fff';
            }

            const speed = (this.radius * 2) * 8; 
            game.snowballs.push({
                x: this.x + Math.cos(angle) * (this.radius + 10),
                y: this.y + Math.sin(angle) * (this.radius + 10),
                vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                radius: finalSize, color: color, owner: this, life: 3.0, type: (this.conf.id==='earth'?'homing':'normal'),
                damage: this.score * 0.05, target: (this.isPlayer ? null : game.player),
                isTTS: (this.conf.id === 'tts16a')
            });
        }
    }
    applyFrozenEffect(color, hard=false) {
        if (game.mod.immunity >= 100 && this.isPlayer) return; 
        
        let cost = this.score * 0.02; 
        this.score -= cost; 
        if (this.isPlayer) game.showFloatingText(this.x, this.y - this.radius, "-" + Math.floor(cost), "red");
        this.slowTimer = hard ? 5.0 : 3.0; 
        this.frozenEffectTimer = hard ? 5.0 : 5.0; 
        this.frozenColor = color;
        if (this.isPlayer) ui.notify("–ó–ê–ú–û–†–û–ó–ö–ê!");
    }
    update(game, dt) {
        if(isNaN(this.score)) this.score = 50;

        // Passive Score Logic
        if (game.mod.passiveScorePlayer > 0 && this.isPlayer && this.alive) {
            this.addScore(game.mod.passiveScorePlayer * dt);
        }
        if (game.mod.passiveScoreBot > 0 && !this.isPlayer && !this.isBoss && this.alive) {
            this.addScore(game.mod.passiveScoreBot * dt);
        }

        if(this.dmgTextTimer > 0) this.dmgTextTimer -= dt;

        for (let k in this.activeEffects) {
             if (this.activeEffects[k] > 0) this.activeEffects[k] -= dt;
        }

        if (this.cooldownTimer > 0) this.cooldownTimer -= dt;

        if (this.fireTimer > 0) this.fireTimer -= dt;
        if (this.ammo < this.maxAmmo) {
            this.reloadTimer += dt;
            if (this.reloadTimer >= this.reloadTime) { this.ammo++; this.reloadTimer = 0; }
        }
        if (this.isPlayer) ui.updateAmmo(this.ammo, this.maxAmmo, this.reloadTimer, this.reloadTime);

        if(this.shieldActive) {
            let decayRate = 0.05; 
            if(this.conf.id === 'jupiter') decayRate = 0.035;
            
            // SAVE LIFE MODE FIX: Shield on Core decays 3x faster
            if (this.isCentralCore && game.arenaMode === 'save_life') decayRate *= 3;

            this.shieldDecayTimer += dt;
            if(this.shieldDecayTimer >= 0.5) {
                this.shieldHp -= this.shieldHp * decayRate;
                this.shieldDecayTimer = 0;
            }
            if(this.shieldHp <= 10) { this.shieldActive = false; }
        }
        if(this.shieldCD > 0) this.shieldCD -= dt;

        if(this.lightStripActive) {
            this.lightStripTimer -= dt;
            if(this.lightStripTimer <= 0) this.toggleLightStrip();
            
            if(this.isPlayer) {
                 if (game.mouse.down || game.aimJoy.active || (game.isMobile && game.joystick.active)) {
                      this.fireLightStrip();
                 }
            } else if (this.isProbe) {
                 this.fireLightStrip();
            }
        }
        if(this.lightStripFireTimer > 0) this.lightStripFireTimer -= dt;
        if(this.lightStripCD > 0) this.lightStripCD -= dt;

        if(this.blueStripActive) {
            this.blueStripTimer -= dt;
            if (this.blueStripTimer <= 0) this.toggleBlueStrip();
            
            if (this.isPlayer) {
                 if (game.mouse.down || game.aimJoy.active || (game.isMobile && game.joystick.active)) {
                      this.fireBlueStrip();
                 }
            } else {
                 this.fireBlueStrip();
            }
        }
        if (this.blueStripFireTimer > 0) this.blueStripFireTimer -= dt;
        if (this.blueStripCD > 0) this.blueStripCD -= dt;

        if(this.blueBulletCD > 0) this.blueBulletCD -= dt;
        
        if(this.vampireTimer <= 0) {
            if(this.vampireStock < 5) { this.vampireStock++; this.vampireTimer = 5; }
        } else this.vampireTimer -= dt;
        if(this.vampireFireCD > 0) this.vampireFireCD -= dt;
        
        if (this.vampireDot) {
            this.vampireDot.timer -= dt;
            this.vampireDot.tickAccumulator += dt;
            
            if(this.vampireDot.tickAccumulator >= 1.0) {
                this.vampireDot.tickAccumulator -= 1.0;
                // Deal 1/3 of total snapshot damage (3% of attacker per sec)
                let tickDmg = this.vampireDot.total / 3.0;
                if(isNaN(tickDmg)) tickDmg = 0;
                
                this.takeDamage(tickDmg, true);
                if(this.isPlayer) game.showFloatingText(this.x, this.y - this.radius, "-" + Math.floor(tickDmg), "darkred");

                if (this.vampireDot.owner && this.vampireDot.owner.alive) {
                    let heal = tickDmg * 0.6;
                    if(!isNaN(heal)) this.vampireDot.owner.addScore(heal);
                }
            }
            
            if (this.vampireDot.timer <= 0) this.vampireDot = null;
        }

        if(this.iceSwordActive) {
            this.iceSwordTimer += dt;
            if(this.iceSwordTimer < 2.5) {
                this.iceSwordSpeed = (this.iceSwordTimer/2.5) * (Math.PI*9); 
            } else if (this.iceSwordTimer < 5.0) {
                this.iceSwordSpeed = (Math.PI*9);
            } else {
                this.iceSwordSpeed = Math.max(0, (Math.PI*9) * (1 - (this.iceSwordTimer - 5.0)));
                if (this.iceSwordTimer > 5.0) this.iceSwordActive = false; 
            }
            this.iceSwordAngle += this.iceSwordSpeed * dt;
            
            const length = this.radius * 6;
            const points = 5; 
            game.entities.forEach(e => {
                 if(e!==this && e.alive) {
                     let hit = false;
                     for(let i=1; i<=points; i++) {
                         let pDist = (length / points) * i;
                         let px = this.x + Math.cos(this.iceSwordAngle)*pDist;
                         let py = this.y + Math.sin(this.iceSwordAngle)*pDist;
                         if(Math.hypot(e.x-px, e.y-py) < e.radius + 10) { hit = true; break; }
                     }
                     if(hit) e.takeDamage(e.score * 0.015);
                 }
            });
        }
        if(this.iceSwordCD > 0) this.iceSwordCD -= dt;

        if (this.gravityManeuverActive) {
            this.gravityManeuverTimer -= dt;
            game.entities.forEach(e => {
                if(e!==this && e.alive) {
                    if (game.mod.immunity >= 100 && e.isPlayer) return;
                    let dist = Math.hypot(e.x-this.x, e.y-this.y);
                    if(dist < this.gravityManeuverRadius) {
                        let pullSpeed = (this.radius * 2 / 3); 
                        if(this.isPhoenix) pullSpeed = (this.radius * 4); 
                        
                        let angle = Math.atan2(this.y-e.y, this.x-e.x);
                        e.x += Math.cos(angle) * pullSpeed * dt;
                        e.y += Math.sin(angle) * pullSpeed * dt;
                        e.slowTimer = 0.2; 
                    }
                }
            });

            if(this.gravityManeuverTimer <= 0) {
                if (!this.isPhoenix) {
                    this.gravityManeuverActive = false;
                    if(this.isPlayer) this.gravityManeuverCD = 40;
                    else if (this.isTON618) this.gravityManeuverCD = 10;
                    else if (this.isBoss) {
                        let s = game.bossStage;
                        this.gravityManeuverCD = Math.max(5, 20 - s*1.5);
                    } else {
                        this.gravityManeuverCD = 40 + Math.random()*160;
                    }
                }
            }
        }
        if(this.gravityManeuverCD > 0 && !this.gravityManeuverActive) this.gravityManeuverCD -= dt;

        if (this.score <= 45 && !this.isBoss && !this.isZombie) { 
            this.decayTimer += dt;
            if (this.decayTimer > 1.0) {
                this.score -= 3;
                this.decayTimer = 0;
            }
            if (this.score <= 25) this.kill();
        }

        // --- NEW IMMUNITY LOGIC ---
        // Base decay multiplier is 1.25 (25% faster status recovery)
        let decayMult = 1.25; 
        if (this.isPlayer) {
            let immLvl = ui.data.upgradeImmunity || 0;
            if (immLvl > 0) {
                let bonus = 0.05 * Math.pow(1.5, immLvl - 1); 
                decayMult += bonus;
            }
        }

        if (this.frozenEffectTimer > 0) {
            this.frozenEffectTimer -= dt * decayMult; // Faster pass
            this.frozenDoTTimer += dt;
            if (this.frozenDoTTimer >= 1.0) { 
                let dmg = this.score * 0.01;
                this.score -= dmg; 
                if (this.isPlayer) game.showFloatingText(this.x, this.y - this.radius, "-" + Math.floor(dmg), "red");
                this.frozenDoTTimer = 0; 
            }
        }
        if (this.isPlayer) {
            const hud = document.getElementById('frozenHud');
            if (this.frozenEffectTimer > 0) { hud.style.display = 'flex'; document.getElementById('frozenTimerVal').innerText = this.frozenEffectTimer.toFixed(1); } else { hud.style.display = 'none'; }
        }
        
        if (this.burnTimer > 0) {
            this.burnTimer -= dt * decayMult; 
            let dmg = this.score * 0.1 * dt;
            this.score -= dmg; 
        }
        if (this.damageTimer > 0) this.damageTimer -= dt;
        if (this.eatingColorTimer > 0) this.eatingColorTimer -= dt;

        if (this.moonCD > 0) this.moonCD -= dt;
        if (this.greatImpactCD > 0) this.greatImpactCD -= dt;
        if (this.rayCD > 0) this.rayCD -= dt;
        if (this.slowTimer > 0) this.slowTimer -= dt * decayMult; // Faster pass for slow too

        if (this.isRussianEmpire) {
            this.flagSwapTimer -= dt;
            if(this.flagSwapTimer <= 0) {
                this.reState = !this.reState;
                this.flagSwapTimer = 3.0;
                this.conf.reState = this.reState; 
                this.texture = null; 
            }
        }
    
        if (this.isFlorant && this.alive) {
            if (this.florantSpawnTimer <= 0) this.florantSpawnTimer = 5.0;
            this.florantSpawnTimer -= dt;
            if (this.florantSpawnTimer <= 0) {
                let hp = 150 + Math.random() * 1350;
                if (Math.random() < 0.7) hp = 350 + Math.random() * 400;
                let angle = Math.random() * Math.PI * 2;
                let dist = this.radius + 150;
                let minion = new Entity(this.x + Math.cos(angle)*dist, this.y + Math.sin(angle)*dist, {color:'#006400', detail:'#32CD32', type:1}, false, "Sprout");
                minion.score = hp;
                game.entities.push(minion);
                if (game.isPlayer && !game.player.alive) {} else ui.notify("–§–ª–æ—Ä–∞–Ω—Ç –ø—Ä–∏–∑–≤–∞–ª –æ—Ç—Ä–æ—Å—Ç–æ–∫!");
            }
            if (this.florantShields) {
                this.florantShields.forEach(sh => {
                    sh.angle += 1.0 * dt; 
                });
            }
        }

        if (this.isPlayer) {
             const mBtn = document.getElementById('btnMoon');
             if (this.moonCD > 0) { mBtn.classList.add('cd'); document.getElementById('cdMoon').innerText = Math.ceil(this.moonCD); }
             else { mBtn.classList.remove('cd'); document.getElementById('cdMoon').innerText = ""; }

             const gBtn = document.getElementById('btnGreat');
             if (this.greatImpactCD > 0) { gBtn.classList.add('cd'); document.getElementById('cdGreat').innerText = Math.ceil(this.greatImpactCD); }
             else { gBtn.classList.remove('cd'); document.getElementById('cdGreat').innerText = ""; }

             const rBtn = document.getElementById('btnRay');
             if (this.rayCD > 0) { rBtn.classList.add('cd'); document.getElementById('cdRay').innerText = Math.ceil(this.rayCD); }
             else { rBtn.classList.remove('cd'); document.getElementById('cdRay').innerText = ""; }

             const sBtn = document.getElementById('btnShield');
             if (this.shieldCD > 0) { sBtn.classList.add('cd'); document.getElementById('cdShield').innerText = Math.ceil(this.shieldCD); } else { sBtn.classList.remove('cd'); document.getElementById('cdShield').innerText = ""; }
             
             const iBtn = document.getElementById('btnIceSword');
             if(this.iceSwordCD > 0) { iBtn.classList.add('cd'); document.getElementById('cdIceSword').innerText = Math.ceil(this.iceSwordCD); } else { iBtn.classList.remove('cd'); document.getElementById('cdIceSword').innerText = ""; }
             
             const bBtn = document.getElementById('btnBlueBullet');
             if(this.blueBulletCD > 0) { bBtn.classList.add('cd'); document.getElementById('cdBlueBullet').innerText = Math.ceil(this.blueBulletCD); } else { bBtn.classList.remove('cd'); document.getElementById('cdBlueBullet').innerText = ""; }
             
             const grvBtn = document.getElementById('btnGrav');
             if(this.gravityManeuverCD > 0) { grvBtn.classList.add('cd'); document.getElementById('cdGrav').innerText = Math.ceil(this.gravityManeuverCD); } else { grvBtn.classList.remove('cd'); document.getElementById('cdGrav').innerText = ""; }

             document.getElementById('stockVampire').innerText = this.vampireStock;
             
             const stripBtn = document.getElementById('btnStrip');
             if(this.lightStripActive) stripBtn.classList.add('active-mode'); else stripBtn.classList.remove('active-mode');
        }

        if (this.greatImpactState > 0) {
            if (this.greatImpactState === 1) { 
                this.useWave(true);
                this.greatImpactState = 2; this.greatImpactTimer = 0.325; 
            } else if (this.greatImpactState === 2) { 
                this.greatImpactTimer -= dt;
                if(this.greatImpactTimer <= 0) {
                    this.useWave(true);
                    this.greatImpactState = 3; this.greatImpactTimer = 0.325; 
                }
            } else if (this.greatImpactState === 3) { 
                this.greatImpactTimer -= dt;
                if(this.greatImpactTimer <= 0) {
                    this.useWave(true);
                    this.greatImpactState = 0; 
                }
            }
        }

        if (this.rayState > 0) {
            this.rayTimer -= dt;
            if (this.rayState === 1 && this.rayTimer <= 0) { 
                this.rayState = 2;
                this.rayTimer = (this.conf.category==='star' || this.conf.id==='tts16a' || this.isPhoenix || this.isTON618)?6.0:3.0; 
            }
            if (this.rayState === 2) {
                if (this.rayTimer <= 0) this.rayState = 0;
                else {
                    const rayLen = this.radius * 15;
                    const ex = this.x + Math.cos(this.rayAngle) * rayLen;
                    const ey = this.y + Math.sin(this.rayAngle) * rayLen;
                    game.entities.forEach(e => {
                        if (e !== this && e.alive) {
                            if (game.arenaMode === 'team' && e.team === this.team) return;
                            // Save Life logic here handled by update loop checks mainly, 
                            // but ray could potentially hit friendlies if not checked.
                            if (game.arenaMode === 'save_life') {
                                if ((this.isPlayer && e.isCentralCore) || (this.isCentralCore && e.isPlayer)) return;
                                if (e.team === this.team) return;
                            }

                            let distToEnt = Math.hypot(e.x - this.x, e.y - this.y);
                            if (distToEnt > rayLen + e.radius) return;

                            let num = Math.abs((ey - this.y)*e.x - (ex - this.x)*e.y + ex*this.y - ey*this.x); 
                            let den = Math.sqrt(Math.pow(ey - this.y, 2) + Math.pow(ex - this.x, 2));
                            if (den > 0 && num/den < e.radius + this.radius/4) { 
                                let dmg = e.score * 0.06 * dt; 
                                if (this.conf.category === 'star' || this.conf.id === 'tts16a') dmg *= 2.0; 
                                if (this.conf.id === 'betelgeuse') dmg *= 2.0; 
                                if (this.isTON618) dmg = e.score * 0.20 * dt; 
                                if (this.isPhoenix) dmg = e.score * 0.40 * dt; 
                                
                                if(e.shieldActive) dmg /= 10;
                                e.takeDamage(dmg);
                            }
                        }
                    });
                }
            }
        }

        if (this.isSpectral || this.isAnomaly) {
            let range = this.radius * (this.isAnomaly ? 4 : 3);
            game.entities.forEach(e => {
                if(e!==this && Math.hypot(e.x-this.x, e.y-this.y) < range) {
                    let dmg = e.score * 0.1 * dt; 
                    if(this.isAnomaly) dmg = e.score * 0.1 * 25 * dt; // Anomaly AoE x25
                    e.takeDamage(dmg, true); 
                }
            });
        }

        for (let i = this.moons.length - 1; i>=0; i--) {
            let m = this.moons[i];
            m.angle += m.speed * dt;
            if (m.angle >= Math.PI * 2 * (m.revs + 1)) m.revs++;
            if (m.revs >= m.maxRevs) { this.moons.splice(i,1); continue; }
            m.x = this.x + Math.cos(m.angle) * m.dist; m.y = this.y + Math.sin(m.angle) * m.dist;
            game.entities.forEach(e => {
                if (e !== this && Math.hypot(e.x - m.x, e.y - m.y) < e.radius + m.radius) {
                    if (game.arenaMode === 'team' && e.team === this.team) return;
                    if (game.arenaMode === 'save_life' && ((this.isPlayer && e.isCentralCore) || (e.isPlayer && this.isCentralCore))) return;
                    let lvl = (this.isPlayer ? (ui.data.abilityLevels?.moon || 0) : 0);
                    let baseDmg = e.score * (0.025 + lvl*0.01) * dt * 2;
                    if (m.dmgMult) baseDmg *= m.dmgMult;
                    if (m.isStar) baseDmg = 500 * dt; 
                    e.takeDamage(baseDmg, true);
                }
            });
        }

        if (this.isBoss && this.alive) {
            this.damageTakenTimer += dt;
            if (this.damageTakenTimer > 3.0) { 
                this.regenTimer += dt;
                if (this.regenTimer >= 1.0) {
                    this.regenTimer = 0;
                    if (!this.isProbe) {
                        let regen = 0;
                        const s = game.bossStage;
                        if (s===1) regen=25; else if(s===2) regen=50; else if(s===3) regen=75;
                        else if(s===4) regen=100; else if(s===5) regen=125; else if(s===6) regen=162;
                        else if(s===7) regen=250; else regen=250;
                        this.addScore(regen);
                    }
                }
            }
        }
        
        if (this.isPhoenix) {
             this.gravityManeuverActive = true;
             this.gravityManeuverTimer = 9999;
             this.gravityManeuverRadius = this.radius * 6;
        }

        if (this.isBoss) {
            let stageMult = Math.pow(1.5, game.bossStage - 1);

            if(this.gravityManeuverCD <= 0 && !this.gravityManeuverActive && this.bossState === 0 && !this.isPhoenix) {
                let hasEnemies = false;
                for(let e of game.entities) {
                    if(!e.isBoss && Math.hypot(e.x-this.x, e.y-this.y) < this.radius*6) { hasEnemies=true; break; }
                }
                if(hasEnemies) this.useGravityManeuver();
            }

            if (this.isStarKing) {
                 this.bossSubTimer -= dt;
                 if (this.bossSubTimer <= 0) {
                      this.bossSubTimer = 1.0;
                      let target = null; let minD = 99999;
                      for(let e of game.entities) { if(!e.isBoss) { let d=Math.hypot(e.x-this.x, e.y-this.y); if(d<minD){minD=d; target=e;} } } 
                      if (target) {
                           let ang = Math.atan2(target.y-this.y, target.x-this.x);
                           let spd = this.radius * 1.0;
                           game.snowballs.push({
                               x:this.x, y:this.y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd,
                               radius: this.radius * 0.3, color: '#FFFF00', owner: this, life: 15,
                               type: 'starProjectile', damage: 500
                           });
                      }
                 }
            }

            if (this.isProbe) {
                 // Removed fireLightStrip call here, handled in lightStripActive update
                 if (this.waveCD > 0) this.waveCD -= dt;
                 if (this.waveCD <= 0) {
                      this.bossState = 2; 
                      this.bossAttackType = 2; 
                      let target = null; let minD = 99999; 
                      for(let e of game.entities) { if(!e.isBoss) { let d=Math.hypot(e.x-this.x, e.y-this.y); if(d<minD){minD=d; target=e;} } } 
                      if(target) this.bossTargetAngle = Math.atan2(target.y - this.y, target.x - this.x);
                      this.waveCD = 1.0; 
                 }
            }

            if (!this.isProbe && !this.isStarKing && !this.isHunter && this.bossState === 0) { 
                this.waveCD -= dt; 
                let attackInterval = this.isAnomaly ? (1 + Math.random()*2) : 2.0;

                if (this.waveCD <= attackInterval) {
                    this.bossState = 1; 
                    let r = Math.random();
                    if (game.bossStage === 2) this.bossAttackType = 7; 
                    else if (game.bossStage === 4) this.bossAttackType = 8; 
                    else if (game.bossStage === 5) this.bossAttackType = 9; 
                    else if (game.bossStage === 6) this.bossAttackType = (r<0.3?10:(r<0.6?11:2)); 
                    else if (game.bossStage === 7) this.bossAttackType = (r<0.5 ? 9 : 2); 
                    else if (game.bossStage === 8) this.bossAttackType = 2; 
                    else if (game.bossStage === 9) this.bossAttackType = 2; 
                    else {
                        if (r < 0.3) this.bossAttackType = 1; 
                        else if (r < 0.5) { 
                            this.bossAttackType = 2; 
                            let target = null; let minD = 99999; 
                            for(let e of game.entities) { if(!e.isBoss) { let d=Math.hypot(e.x-this.x, e.y-this.y); if(d<minD){minD=d; target=e;} } } 
                            if(target) this.bossTargetAngle = Math.atan2(target.y - this.y, target.x - this.x); 
                            this.bossSubTimer = 3.0; 
                        }
                        else if (r < 0.7) { this.bossAttackType = 3; this.bossSubTimer = 20.0; } 
                        else this.bossAttackType = 6; 
                    }
                    if (this.bossAttackType === 10) this.bossSubTimer = 3.0; 
                    if (this.bossAttackType === 11) this.bossSubTimer = 5.0; // Rotating Cross
                }
            }
            else if (!this.isProbe && this.bossState === 1) { 
                this.waveCD -= dt; 
                if (this.bossAttackType === 10 || this.bossAttackType === 11) {
                    this.angle += 5.0 * dt; 
                    this.bossSubTimer -= dt;
                    if(this.bossSubTimer <= 0) {
                        this.bossState = 2;
                        if(this.bossAttackType === 10) {
                            this.spectralRays = [];
                            for(let i=0; i<12; i++) {
                                 this.spectralRays.push({ angle: i*(Math.PI*2/12), len: this.radius*5 }); 
                            }
                            this.bossSubTimer = 3.0; 
                        } else { // 11
                            this.bossSubTimer = 10.0; // Duration of cross
                        }
                        this.waveCD = 15;
                    }
                }
                else if (this.waveCD <= 0) { 
                    this.bossState = 2; 
                    if (this.bossAttackType === 1) this.useWave(); 
                    if (this.bossAttackType === 7) { this.useWave(); this.bossDoubleWave = 1; this.bossSubTimer = 0.5; } 
                    if (this.bossAttackType === 8) this.useWave(); 
                    if (this.bossAttackType === 9) this.useWave(); 
                    if (this.bossAttackType === 6) {
                         let target = game.player;
                         for(let e of game.entities) { if(!e.isBoss && Math.hypot(e.x-this.x,e.y-this.y)<2000) target=e; }
                         let dx = target.x-this.x, dy = target.y-this.y; let ang = Math.atan2(dy, dx); let speed = this.radius * 8;
                         game.snowballs.push({ x:this.x, y:this.y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, radius:this.radius/2, color:'red', owner:this, life:3, isBossShot:true });
                         this.bossState = 0; this.waveCD = 10;
                    }
                }
            }
            else if (this.bossState === 2) { 
                if (this.bossAttackType === 1 && !this.waves.length) { this.bossState = 0; this.waveCD = 10; }
                
                if (this.bossAttackType === 7) {
                    if (this.bossDoubleWave === 1) {
                         this.bossSubTimer -= dt;
                         if (this.bossSubTimer <= 0) { this.useWave(); this.bossDoubleWave = 2; }
                    } else if (this.bossDoubleWave === 2 && !this.waves.length) {
                         this.bossState = 0; this.waveCD = 7; 
                    }
                }

                if (this.bossAttackType === 8 && !this.waves.length) { this.bossState = 0; this.waveCD = 2; } 

                if (this.bossAttackType === 9 && !this.waves.length) { this.bossState = 0; this.waveCD = 15; } 
                
                if (this.bossAttackType === 10) {
                    this.bossSubTimer -= dt;
                    this.angle += 3.77 * dt; 
                    
                    if(this.spectralRays) {
                        this.spectralRays.forEach(ray => {
                            let currentAngle = this.angle + ray.angle;
                            let ex = this.x + Math.cos(currentAngle) * ray.len;
                            let ey = this.y + Math.sin(currentAngle) * ray.len;
                            
                            game.entities.forEach(e => {
                                if (!e.isBoss && Math.hypot(e.x-ex, e.y-ey) < this.radius*1.5 + e.radius) {
                                    e.takeDamage(e.score * 0.20 * dt); 
                                }
                            });
                        });
                    }
                    if(this.bossSubTimer <= 0) { this.bossState = 0; this.waveCD = 10; }
                }
                
                if (this.bossAttackType === 11) {
                    this.bossSubTimer -= dt;
                    this.angle += 2.0 * dt;
                    // Collision logic for Cross is handled in drawing? No, need here.
                    const rays = 4;
                    const len = this.radius * 20;
                    game.entities.forEach(e => {
                        if (!e.isBoss) {
                            for(let i=0; i<rays; i++) {
                                let ang = this.angle + i * (Math.PI/2);
                                let ex = this.x + Math.cos(ang) * len;
                                let ey = this.y + Math.sin(ang) * len;
                                // Simple line collision
                                let num = Math.abs((ey - this.y)*e.x - (ex - this.x)*e.y + ex*this.y - ey*this.x); 
                                let den = Math.sqrt(Math.pow(ey - this.y, 2) + Math.pow(ex - this.x, 2));
                                if (den > 0 && num/den < e.radius + this.radius/2) {
                                    e.takeDamage(e.score * 0.3 * dt);
                                }
                            }
                        }
                    });
                    if (this.bossSubTimer <= 0) { this.bossState = 0; this.waveCD = 10; }
                }

                if (this.bossAttackType === 2) {
                    this.waveCD -= dt; 
                    if (this.waveCD < -5.0) { 
                        this.bossState = 0; 
                        this.waveCD = 10; 
                    } 
                    else {
                        if (this.waveCD < 0) { 
                            if (Math.floor(Date.now() / 333) % 2 === 0) {
                                let rayLen = this.radius * 20; 
                                let ex = this.x + Math.cos(this.bossTargetAngle) * rayLen; 
                                let ey = this.y + Math.sin(this.bossTargetAngle) * rayLen;
                                game.entities.forEach(e => {
                                    if(!e.isBoss) {
                                        let distToEnt = Math.hypot(e.x - this.x, e.y - this.y);
                                        if (distToEnt > rayLen + e.radius) return;

                                        let num = Math.abs((ey - this.y)*e.x - (ex - this.x)*e.y + ex*this.y - ey*this.x); 
                                        let den = Math.sqrt(Math.pow(ey - this.y, 2) + Math.pow(ex - this.x, 2));
                                        if (den > 0 && num/den < e.radius + this.radius/4) {
                                            let dmg = e.score * 0.45 * dt; 
                                            if (game.bossStage > 7) dmg = e.score * 0.6 * dt; 
                                            e.takeDamage(dmg);
                                        }
                                    }
                                });
                            }
                        }
                    }
                }
                if (this.bossAttackType === 3) {
                    this.bossSubTimer -= dt; this.bossOrbitAngle += (Math.PI / 2) * dt; let dist = this.radius * 3;
                    for(let i=0; i<2; i++) {
                         let ang = this.bossOrbitAngle + (i * Math.PI); let ox = this.x + Math.cos(ang) * dist; let oy = this.y + Math.sin(ang) * dist;
                         game.entities.forEach(e => {
                             if(!e.isBoss && Math.hypot(e.x - ox, e.y - oy) < e.radius + this.radius) { let dmg = e.score * 0.1 * dt; e.takeDamage(dmg); }
                         });
                    }
                    if (this.bossSubTimer <= 0) { this.bossState = 0; this.waveCD = 10; }
                }
            }
        } else if(this.waveCD > 0) this.waveCD -= dt;
        
        for (let i = this.waves.length - 1; i >= 0; i--) {
            let w = this.waves[i];
            let lvl = (this.isPlayer ? (ui.data.abilityLevels?.wave || 0) : 0);
            let speed = 300 * (1 + lvl*0.05); 
            let maxR = this.radius * 5.28 * (1 + lvl*0.075);
            let damageFactor = 0.05;

            if (this.isBoss) {
                 speed = 195; 
                 maxR = this.radius * 11.52; 
                 damageFactor = 0.05 * Math.pow(1.5, game.bossStage - 1);
                 maxR *= 2; 
            }
            else if (this.conf.category === 'star' || this.conf.id === 'tts16a') { 
                maxR *= 2; damageFactor *= 2;
            }

            if (w.isGreat) { speed *= 1.55; maxR *= 1.25; }
            
            w.maxR = maxR;

            w.r += speed * dt;
            w.alpha = 1 - (w.r / maxR);
            if(w.r > maxR) { this.waves.splice(i, 1); continue; }
            
            game.entities.forEach(e => {
                if(e !== this && Math.hypot(e.x - this.x, e.y - this.y) < w.r + e.radius) {
                     if (game.arenaMode === 'team' && e.team === this.team) return; 
                     if (game.arenaMode === 'save_life') {
                         if ((this.isPlayer && e.isCentralCore) || (this.isCentralCore && e.isPlayer)) return;
                         if (e.team === this.team) return;
                     }
                     if (game.arenaMode === '5vs1') {
                         if (this.isBigBoss && e.isBigBoss) return;
                         if (!this.isBigBoss && !e.isBigBoss) return;
                     }

                     if (Math.hypot(e.x - this.x, e.y - this.y) > w.r - 20) {
                        let dmg = e.score * damageFactor * dt * 2;
                        if(w.isGreat) dmg *= 1.5; 
                        e.takeDamage(dmg, true); 
                        if (e.slowTimer <= 0) e.slowTimer = 5.0;
                     }
                }
            });
        }

        if(this.isPlayer) { ui.updateTimer(this.activeEffects); this.isSprinting = game.isSprinting; }
        
        let safeScore = Math.max(0, this.score);
        let scale = 1 + Math.sqrt(safeScore) * 0.15; 
        
        let targetR = CONFIG.baseSize * scale;
        if(this.activeEffects && this.activeEffects.grow > 0) targetR *= 1.4;
        this.radius += (targetR - this.radius) * 2 * dt;

        let speed = ((2500 / (Math.pow(this.radius, 0.4) + 5)) * game.matchSpeedFactor);
        let sMod = (this.activeEffects && this.activeEffects.speed > 0) ? 1.15 : 1; 
        if (!this.isPlayer && this.isSprinting) sMod *= 1.2;

        if(this.conf.id === 'mercury') sMod *= 1.2;
        if(this.conf.id === 'mars') sMod *= 1.03;
        if(this.conf.id === 'jupiter') sMod *= 0.85;
        if(this.conf.id === 'saturn') sMod *= 0.9;
        if(this.conf.id === 'uranus') sMod *= 0.95;
        if(this.conf.id === 'neptune') sMod *= 0.97;
        
        // Rule Immunity Modifier
        if (this.isPlayer && game.mod.ruleImmunity) {
            // Cancel speed penalty from Agility mode or other modes
            if (this.isAgilityBoss) { /* Player is never AgilityBoss */ }
        } else {
            if(this.isAgilityBoss) sMod *= 0.1;
        }
        
        if(this.isCentralCore) speed = 0; 
        
        speed *= sMod;

        // Rule Immunity check for sprint cost? Prompt says "reduced point cost for sprint"
        if(this.isSprinting && this.score > 20) { 
            speed *= 2.5; 
            let cost = this.score * 0.03 * dt; 
            if (this.isPlayer && game.mod.ruleImmunity) cost *= 0.5; // Reduced sprint cost
            this.score -= cost; 
        }
        if(this.inRing) speed *= 0.4;
        
        if (this.frozenEffectTimer > 0) {
             if(this.frozenEffectTimer < 3) speed *= 0.55; 
             else speed *= 0.35; 
        }
        else if (this.slowTimer > 0) speed *= 0.25; 

        if (this.isBoss && this.bossState === 2) speed = 0; 
        if (this.rayState > 0) speed *= 0.62; 
        
        if (this.lightStripActive) speed *= 0.25; 
        if (this.blueStripActive) speed *= 0.15;  
        this.isAiming = false;
        if (this.isPlayer) {
            if (game.aimJoy.active || (this.lightStripActive && game.mouse.down) || (this.blueStripActive && game.mouse.down)) { 
                this.isAiming = true; 
                if (!this.lightStripActive && !this.blueStripActive) speed *= 0.75; 
            }
        }

        let dx = 0, dy = 0;
        if(this.isPlayer) {
            if(game.isMobile) { dx = game.joystick.dx; dy = game.joystick.dy; } else { dx = game.mouse.x; dy = game.mouse.y; }
        } else { this.runAI(game, dt); dx = this.vx; dy = this.vy; }
        if (this.isBoss && this.bossState > 0) { dx = 0; dy = 0; }

        if(dx!==0 || dy!==0) {
            const angle = Math.atan2(dy, dx);
            let diff = angle - this.angle;
            while (diff > Math.PI) diff -= Math.PI*2; while (diff < -Math.PI) diff += Math.PI*2;
            this.angle += diff * 5 * dt;

            if (speed > 5000) speed = 5000; 

            this.x += Math.cos(angle) * speed * dt * (Math.hypot(dx,dy)>0.1?1:0);
            this.y += Math.sin(angle) * speed * dt * (Math.hypot(dx,dy)>0.1?1:0);
        }
        if(!this.isPlayer && Math.hypot(this.x,this.y) > game.zoneRadius) { this.vx = -this.x; this.vy = -this.y; }
    }

    runAI(game, dt) {
        if (this.isHunter) {
            // Hunter AI Logic
            let target = game.player; 
            if (!target.alive) {
                // Roam if player dead
                if(Math.random()<0.02) { this.vx = (Math.random()-0.5); this.vy = (Math.random()-0.5); }
                return;
            }
            let dist = Math.hypot(this.x - target.x, this.y - target.y);
            
            if (this.score < target.score * 0.9) {
                // Flee
                this.hunterState = 'flee';
                this.vx = this.x - target.x;
                this.vy = this.y - target.y;
                if (this.ammo > 0 && this.fireTimer <= 0 && dist < 1500) {
                    this.fireSnowball(target.x - this.x, target.y - this.y);
                }
            } else if (this.score > target.score * 1.1) {
                // Chase
                this.hunterState = 'chase';
                this.vx = target.x - this.x;
                this.vy = target.y - this.y;
                if (Math.random() < 0.01) this.isSprinting = true; // Sprint occasionally
                if (this.isSprinting && Math.random() < 0.05) this.isSprinting = false;
                
                if (this.ammo > 0 && this.fireTimer <= 0 && dist < 800) {
                    this.fireSnowball(target.x - this.x, target.y - this.y);
                }
            } else {
                // Farm / Maintain Distance
                this.hunterState = 'roam';
                // Look for stars nearby
                let bestStar = null; let minStarD = 500;
                game.stars.forEach(s => {
                    let d = Math.hypot(s.x - this.x, s.y - this.y);
                    if (d < minStarD) { minStarD = d; bestStar = s; }
                });
                if (bestStar) {
                    this.vx = bestStar.x - this.x;
                    this.vy = bestStar.y - this.y;
                } else {
                    // Circle player?
                    this.vx = (this.y - target.y);
                    this.vy = -(this.x - target.x);
                }
            }
            return;
        }

        if(this.boostTimer > 0) { this.isSprinting = true; this.boostTimer -= dt; } else { this.isSprinting = false; if(Math.random() < 0.002) this.boostTimer = 1 + Math.random()*2; }
        
        this.npcItemTimer -= dt;
        if(this.npcItemTimer <= 0) {
            this.npcItemTimer = 15 + Math.random()*45;
            let keys = Object.keys(ITEMS_TYPES);
            let randItem = keys[Math.floor(Math.random()*keys.length)];
            this.activeEffects[randItem] = ITEMS_TYPES[randItem].duration;
        }
        if(this.inventory.count > 0) this.useItem();
        
        if(Math.random() < 0.0003) this.spawnMoon();

        if(game.gameTime > 15) {
            if (this.greatImpactCD <= 0 && Math.random() < 0.001) this.useGreatImpact();
            if (this.rayCD <= 0 && Math.random() < 0.002) this.useRay();
            if (this.shieldCD <= 0 && Math.random() < 0.001) this.activateShield();
            if (this.iceSwordCD <= 0 && Math.random() < 0.00028) this.activateIceSword();
            if (this.blueBulletCD <= 0 && Math.random() < 0.001) this.fireBlueBullet();
            if (this.vampireStock > 0 && Math.random() < 0.002) this.fireVampire();
            if (this.gravityManeuverCD <= 0 && Math.random() < 0.001) {
                 let smaller = false;
                 for(let e of game.entities) {
                     if(e!==this && e.alive && e.score < this.score && Math.hypot(e.x-this.x, e.y-this.y) < this.radius*6) { smaller=true; break; }
                 }
                 if(smaller) this.useGravityManeuver();
            }
            if (this.aimDelay > 0) this.aimDelay -= dt;
        }

                if (game.arenaMode === '5vs1' && !this.isBigBoss) {
             let boss = game.entities.find(e => e.isBigBoss) || game.player;
             let dist = Math.hypot(this.x - boss.x, this.y - boss.y);
             let optimalDist = boss.radius + 600;
             
                          let angleToBoss = Math.atan2(boss.y - this.y, boss.x - this.x);
             
             if (dist > optimalDist + 200) {
                 this.vx = Math.cos(angleToBoss);
                 this.vy = Math.sin(angleToBoss);
             } else if (dist < optimalDist - 100) {
                 this.vx = -Math.cos(angleToBoss);
                 this.vy = -Math.sin(angleToBoss);
             } else {
                 this.vx = Math.cos(angleToBoss + Math.PI/2);
                 this.vy = Math.sin(angleToBoss + Math.PI/2);
             }
             
             if (this.ammo > 0 && this.aimDelay <= 0) {
                 this.fireSnowball(boss.x - this.x, boss.y - this.y);
                 this.aimDelay = 2.0; 
             }
             return;
        }

        let target = null, itemTarget = null; let minD = 1000, minItemD = 800;
        for (let it of game.items) {
            let d = Math.hypot(this.x - it.x, this.y - it.y);
            if (d < minItemD) { itemTarget = it; minItemD = d; }
        }

                if (game.arenaMode === 'team' && game.zoneTimer > 0) {
             target = null;         } else {
            for(let e of game.entities) {
                if(e===this) continue;
                if(game.arenaMode === 'team' && e.team === this.team) continue;
                if(game.arenaMode === 'save_life' && e.team === this.team) continue;
                if(game.arenaMode === 'zombie' && e.isZombie === this.isZombie) continue;

                let d = Math.hypot(this.x-e.x, this.y-e.y);
                if (e.mass > this.mass * 1.1 && d < 600) { 
                    this.vx = this.x - e.x; this.vy = this.y - e.y; 
                    if(game.gameTime > 15) {
                        if (d < this.radius * 3 && this.waveCD <= 0 && !this.isBoss) this.useWave();
                        if (this.ammo > 0 && this.aimDelay <= 0) { this.fireSnowball(e.x - this.x, e.y - this.y); this.aimDelay = (8 + Math.random() * 17) * 3 * 1.75; }
                    }
                    return; 
                } 
                if(e.mass < this.mass * 0.8 && d < minD) { target = e; minD = d; } 
            }
        }
        
                if (this.isInvader) {
             const core = game.entities.find(e => e.isCentralCore);
             if (core) {
                 target = core; minD = Math.hypot(this.x-core.x, this.y-core.y);
             }
        }

        this.aiBlueStripCooldown -= dt;
        if (!this.isPlayer && !this.isBoss && this.aiBlueStripCooldown <= 0 && this.score > 200) {
            if (!this.blueStripActive && this.blueStripCD <= 0) {
                 this.toggleBlueStrip();
                 this.aiBlueStripCooldown = 60 + Math.random() * 60;
            }
        }

        if (this.blueStripActive && target) {
            this.aiTargetX = target.x;
            this.aiTargetY = target.y;
        }

        if (itemTarget && (!target || minItemD < minD)) {
            this.vx = itemTarget.x - this.x; this.vy = itemTarget.y - this.y;
        } else if(target) { 
            this.vx = target.x - this.x; this.vy = target.y - this.y;
            if(game.gameTime > 15) {
                if (minD < 500 && this.ammo > 0 && this.aimDelay <= 0) { this.fireSnowball(target.x - this.x, target.y - this.y); this.aimDelay = (8 + Math.random() * 17) * 3 * 1.75; }
                if (!this.isBoss && this.waveCD <= 0 && minD < this.radius * 2.5) this.useWave();
                if (this.lightStripCD <= 0 && Math.random() < 0.00014) { this.toggleLightStrip(); }
                if (this.lightStripActive) this.fireLightStrip();
            }
        } else { 
            if(Math.random()<0.02) { this.vx = (Math.random()-0.5); this.vy = (Math.random()-0.5); }
        }
    }

}

class UI {
    constructor() {
        this.data = { coins: 1500, unlocked: ['earth'], planet: 'earth', name: 'Player', color: '#1E90FF', upgrades: { speed: 0, magnet: 0, grow: 0, bonus: 0 }, abilityLevels: { snowball: 0, wave: 0, moon: 0 }, fpsSide: 'left', lastClaim: 0, joyMove: {x:50,y:50,s:150}, joyAim: {x:140,y:180,s:225}, upgradeSecondChance: 0, upgradeAmmo: 0, upgradeImmunity: 0 };
        this.invCounts = { speed: 0, magnet: 0, grow: 0, bonus: 0 };
        this.currentTab = 'planets';
        this.tempMobile = false;
        this.tempArenaMode = null;
        this.lang = 'ru';
        this.load(); this.applyFpsSide();
        document.getElementById('playerNameInput').addEventListener('input', (e) => { this.data.name = e.target.value; this.save(); });
        document.getElementById('quoteDisplay').innerText = QUOTES[Math.floor(Math.random()*QUOTES.length)];
        this.checkFreeCoins();
        this.updateTexts();
    }
    toggleLanguage() {
        this.lang = this.lang === 'ru' ? 'en' : 'ru';
        this.updateTexts();
        const btn = document.querySelector('.lang-btn');
        btn.innerText = this.lang === 'ru' ? '–†–£–°–°–ö–ò–ô' : 'ENGLISH';
    }
    updateTexts() {
        const elems = document.querySelectorAll('[data-lang-key]');
        elems.forEach(el => {
            const key = el.getAttribute('data-lang-key');
            if (LANG_DATA[this.lang] && LANG_DATA[this.lang][key]) {
                el.innerHTML = LANG_DATA[this.lang][key];
            }
        });
    }
    ripple(e, callback) {
        const btn = e.currentTarget; const circle = document.createElement("span"); const d = Math.max(btn.clientWidth, btn.clientHeight);
        circle.style.width = circle.style.height = `${d}px`; circle.style.left = `${e.clientX - btn.getBoundingClientRect().left - d/2}px`; circle.style.top = `${e.clientY - btn.getBoundingClientRect().top - d/2}px`;
        circle.classList.add("ripple"); const o = btn.getElementsByClassName("ripple")[0]; if(o) o.remove(); btn.appendChild(circle); setTimeout(() => { if(callback) callback(); }, 300);
    }
    load() { const s = localStorage.getItem('DaymixSaveV27'); if(s) this.data = Object.assign(this.data, JSON.parse(s)); if(!this.data.abilityLevels) this.data.abilityLevels = { snowball: 0, wave: 0, moon: 0 }; }
    save() { localStorage.setItem('DaymixSaveV27', JSON.stringify(this.data)); }
    addCoins(n) { this.data.coins += n; this.save(); }
    notify(msg) { const d = document.createElement('div'); d.className = 'notif-msg'; d.innerText = msg; document.getElementById('notif-area').appendChild(d); setTimeout(()=>d.remove(), 1500); }
    toggleFpsSide() { this.data.fpsSide = this.data.fpsSide === 'right' ? 'left' : 'right'; this.save(); this.applyFpsSide(); }
    applyFpsSide() { const el = document.getElementById('fpsCounter'), btn = document.getElementById('fpsSideBtn'); if(this.data.fpsSide === 'right') { el.classList.add('right-side'); btn.innerText = "Right"; } else { el.classList.remove('right-side'); btn.innerText = "Left"; } }
    toggleColorPicker() { const p = document.getElementById('colorPicker'); p.style.display = p.style.display === 'flex' ? 'none' : 'flex'; }
    setPlayerColor(c) { this.data.color = c; this.save(); document.getElementById('playerNameInput').style.borderColor = c; this.toggleColorPicker(); }
    showModeSelect() { document.getElementById('mainMenu').style.display = 'none'; document.getElementById('difficultyScreen').style.display = 'none'; document.getElementById('modeScreen').style.display = 'flex'; }
    showDifficulty(isMob) {
        this.tempMobile = isMob;
        document.getElementById('modeScreen').style.display = 'none';
        document.getElementById('difficultyScreen').style.display = 'flex';
        document.querySelectorAll('.diff-card').forEach(x=>x.classList.remove('selected-diff'));
        document.querySelectorAll('.arena-card').forEach(x=>x.classList.remove('selected-arena'));
        const cards = document.querySelectorAll('.diff-card');
        cards.forEach(c => c.onclick = (e) => {
            cards.forEach(x => x.classList.remove('selected-diff'));
            c.classList.add('selected-diff');
            const diff = parseInt(c.id.replace('diff',''));
            game.start(ui.tempMobile, diff);
        });
    }
    setArenaMode(mode) {
        document.querySelectorAll('.arena-card').forEach(x => x.classList.remove('selected-arena'));
        event.currentTarget.classList.add('selected-arena');
        this.tempArenaMode = mode;
        game.start(this.tempMobile, 2);
    }
    showMainMenu() { document.getElementById('modeScreen').style.display = 'none'; document.getElementById('difficultyScreen').style.display = 'none'; document.getElementById('shopScreen').style.display = 'none'; document.getElementById('modifierScreen').style.display = 'none'; document.getElementById('mainMenu').style.display = 'flex'; this.checkFreeCoins(); }
    toggleSettings() { const s = document.getElementById('settings-panel'); s.style.display = s.style.display === 'block' ? 'none' : 'block'; }
    openShop() { document.getElementById('mainMenu').style.display = 'none'; document.getElementById('shopScreen').style.display = 'flex'; this.updateShopUI(); }
    closeShop() { this.showMainMenu(); }
    switchTab(tab) { this.currentTab = tab; document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active')); if(document.getElementById('tab'+(tab.charAt(0).toUpperCase()+tab.slice(1)))) document.getElementById('tab'+(tab.charAt(0).toUpperCase()+tab.slice(1))).classList.add('active'); this.renderShopCards(); }
    updateShopUI() { document.getElementById('shopCoins').innerText = this.data.coins; this.renderShopCards(); }
    selectRandomPlanet() {
        const owned = PLANETS.filter(p => this.data.unlocked.includes(p.id));
        if(owned.length > 0) {
            const r = owned[Math.floor(Math.random() * owned.length)];
            this.selectPlanet(r.id);
            this.notify("–í—ã–±—Ä–∞–Ω–æ: " + r.name);
        }
    }
    sellPlanet(id, event) {
        event.stopPropagation();
        const p = PLANETS.find(x => x.id === id);
        if (p && this.data.unlocked.includes(id) && this.data.planet !== id && id !== 'earth') {
            const refund = Math.floor(p.price * 0.5);
            this.data.coins += refund;
            this.data.unlocked = this.data.unlocked.filter(x => x !== id);
            this.save();
            this.updateShopUI();
            this.notify("–ü—Ä–æ–¥–∞–Ω–æ: " + p.name + " (+" + refund + ")");
        } else {
            this.notify("–ù–µ–ª—å–∑—è –ø—Ä–æ–¥–∞—Ç—å!");
        }
    }
    renderShopCards() {
        const c = document.getElementById('cards-container'); c.innerHTML = '';
        if (this.currentTab === 'planets') {
            PLANETS.forEach(p => {
                const el = document.createElement('div');
                const unlocked = this.data.unlocked.includes(p.id);
                const isSelected = this.data.planet === p.id;
                el.className = `shop-card ${isSelected ? 'selected' : ''}`;
                let btnHTML = isSelected ? `<button class="card-btn owned">–í–´–ë–†–ê–ù–û</button>` : (unlocked ? `<button class="card-btn" onclick="ui.selectPlanet('${p.id}')">–í–´–ë–†–ê–¢–¨</button>` : `<button class="card-btn buy" onclick="ui.buyPlanet('${p.id}')">–ö–£–ü–ò–¢–¨: ${p.price}</button>`);
                let sellHTML = (unlocked && !isSelected && p.id !== 'earth') ? `<div class="card-sell-opt" style="position:absolute; top:10px; right:10px; cursor:pointer;" onclick="ui.sellPlanet('${p.id}', event)">‚ãÆ</div>` : '';

                el.innerHTML = `${sellHTML}
                <div class="card-title">${p.name}</div>
                <div class="card-img-box">
                    <div class="card-planet-preview" style="background:${p.color}; border-color:${p.detail}; box-shadow:0 0 ${p.glow?15:0}px ${p.color}"></div>
                </div>
                <div class="card-desc">${p.desc}</div>
                ${btnHTML}`;
                
                el.onmouseenter = () => { document.getElementById('fullDescArea').innerText = p.fullDesc; };
                el.onmouseleave = () => { document.getElementById('fullDescArea').innerText = "–ù–∞–≤–µ–¥–∏—Ç–µ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è"; };
                
                c.appendChild(el);
            });
        } else if (this.currentTab === 'upgrades') {
            for (let type in UPGRADES_DATA) {
                const info = UPGRADES_DATA[type];
                const lvl = this.data.upgrades[type] || 0;
                const cost = Math.floor(100 * Math.pow(1.5, lvl));
                const el = document.createElement('div'); el.className = 'shop-card';
                el.innerHTML = `<div class="card-title">${ITEMS_TYPES[type].name} (–£—Ä. ${lvl})</div><div class="card-img-box"><div class="card-upgrade-icon">${info.icon}</div></div><div class="card-desc">–≠—Ñ—Ñ–µ–∫—Ç:<br>–°–µ–∫ + 1<br>–ú–æ—â—å + %</div><button class="card-btn buy" onclick="ui.buyUpgrade('${type}', ${cost})">–ö–£–ü–ò–¢–¨: ${cost}</button>`;
                c.appendChild(el);
            }
        } else if (this.currentTab === 'abilities') {
            for (let type in ABILITY_UPGRADES) {
                const info = ABILITY_UPGRADES[type];
                const lvl = this.data.abilityLevels[type] || 0;
                const cost = Math.floor(200 * Math.pow(1.5, lvl));
                const el = document.createElement('div'); el.className = 'shop-card';
                el.innerHTML = `<div class="card-title">${info.name} (–£—Ä. ${lvl})</div><div class="card-img-box"><div class="card-upgrade-icon">‚ú®</div></div><div class="card-desc">${info.desc}</div><button class="card-btn buy" onclick="ui.buyAbility('${type}', ${cost})">–ö–£–ü–ò–¢–¨: ${cost}</button>`;
                c.appendChild(el);
            }
        } else if (this.currentTab === 'misc') {
             // Second Chance
             const lvl = this.data.upgradeSecondChance || 0;
             const cost = Math.floor(500 * Math.pow(1.5, lvl));
             const el = document.createElement('div'); el.className = 'shop-card';
             const chance = Math.min(300, lvl*10);
             if (lvl < 30) {
                 el.innerHTML = `<div class="card-title">–í—Ç–æ—Ä–∞—è –ø–æ–ø—ã—Ç–∫–∞ (–£—Ä. ${lvl})</div><div class="card-img-box"><div class="card-upgrade-icon">‚ôªÔ∏è</div></div><div class="card-desc">–®–∞–Ω—Å: ${chance/10}%<br>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å 50% –æ—á–∫–æ–≤</div><button class="card-btn buy" onclick="ui.buyMisc('secondChance', ${cost})">–ö–£–ü–ò–¢–¨: ${cost}</button>`;
             } else {
                 el.classList.add('selected');
                 el.innerHTML = `<div class="card-title">–í—Ç–æ—Ä–∞—è –ø–æ–ø—ã—Ç–∫–∞ (MAX)</div><div class="card-img-box"><div class="card-upgrade-icon">‚ôªÔ∏è</div></div><div class="card-desc">–ú–∞–∫—Å–∏–º—É–º</div><button class="card-btn owned">MAX</button>`;
             }
             c.appendChild(el);

             // Ammo
             const aLvl = this.data.upgradeAmmo || 0;
             const aCosts = [150, 250, 400, 675];
             const el2 = document.createElement('div'); 
             if (aLvl < 4) {
                 const aCost = aCosts[aLvl];
                 const nextAmmo = 4 + aLvl;
                 const nextRel = (aLvl===0?10:(aLvl===1?8:(aLvl===2?6:5)));
                 el2.className = 'shop-card';
                 el2.innerHTML = `<div class="card-title">–ë–æ–µ–∑–∞–ø–∞—Å (–£—Ä. ${aLvl})</div><div class="card-img-box"><div class="card-upgrade-icon">üî´</div></div><div class="card-desc">–ë–æ–µ–∑–∞–ø–∞—Å: ${nextAmmo}<br>–ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞: ${nextRel}—Å</div><button class="card-btn buy" onclick="ui.buyMisc('ammo', ${aCost})">–ö–£–ü–ò–¢–¨: ${aCost}</button>`;
             } else {
                 el2.className = 'shop-card selected';
                 el2.innerHTML = `<div class="card-title">–ë–æ–µ–∑–∞–ø–∞—Å (MAX)</div><div class="card-img-box"><div class="card-upgrade-icon">üî´</div></div><div class="card-desc">–ú–∞–∫—Å–∏–º—É–º —É–ª—É—á—à–µ–Ω–∏–π</div><button class="card-btn owned">MAX</button>`;
             }
             c.appendChild(el2);

             // Immunity
             const iLvl = this.data.upgradeImmunity || 0;
             const iCost = Math.floor(100 + (iLvl * 50)); // Base 100, +50 each time
             const el3 = document.createElement('div');
             el3.className = 'shop-card';
             let nextBonus = (0.05 * Math.pow(1.5, iLvl)) * 100;
             el3.innerHTML = `<div class="card-title">–ò–º–º—É–Ω–∏—Ç–µ—Ç (–£—Ä. ${iLvl})</div><div class="card-img-box"><div class="card-upgrade-icon">üíâ</div></div><div class="card-desc">–≠—Ñ—Ñ–µ–∫—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç<br>–±—ã—Å—Ç—Ä–µ–µ –Ω–∞ ${nextBonus.toFixed(1)}%</div><button class="card-btn buy" onclick="ui.buyMisc('immunity', ${iCost})">–ö–£–ü–ò–¢–¨: ${iCost}</button>`;
             c.appendChild(el3);
        }
    }

    scrollShop(dir) {
        const c = document.getElementById('cards-container');
        c.scrollBy({ left: dir * 300, behavior: 'smooth' });
    }

    buyPlanet(id) { const p = PLANETS.find(x => x.id === id); if(this.data.coins >= p.price) { this.data.coins -= p.price; this.data.unlocked.push(id); this.notify("–ö—É–ø–ª–µ–Ω–æ!"); this.selectPlanet(id); } else this.notify("–ù—É–∂–Ω–æ –±–æ–ª—å—à–µ –º–æ–Ω–µ—Ç!"); }
    selectPlanet(id) { this.data.planet = id; this.save(); this.updateShopUI(); }
    buyUpgrade(t, cost) { if(this.data.coins >= cost) { this.data.coins -= cost; this.data.upgrades[t]++; this.save(); this.updateShopUI(); } else this.notify("–ù—É–∂–Ω–æ –±–æ–ª—å—à–µ –º–æ–Ω–µ—Ç!"); }
    buyAbility(t, cost) { if(this.data.coins >= cost) { this.data.coins -= cost; this.data.abilityLevels[t]++; this.save(); this.updateShopUI(); } else this.notify("–ù—É–∂–Ω–æ –±–æ–ª—å—à–µ –º–æ–Ω–µ—Ç!"); }
    buyMisc(t, cost) {
        if(this.data.coins >= cost) {
            if (t === 'secondChance' && (this.data.upgradeSecondChance||0) < 30) {
                this.data.coins -= cost;
                this.data.upgradeSecondChance = (this.data.upgradeSecondChance||0)+1;
                this.save(); this.updateShopUI();
            }
            if (t === 'ammo' && (this.data.upgradeAmmo||0) < 4) {
                this.data.coins -= cost;
                this.data.upgradeAmmo = (this.data.upgradeAmmo||0)+1;
                this.save(); this.updateShopUI();
            }
            if (t === 'immunity') {
                this.data.coins -= cost;
                this.data.upgradeImmunity = (this.data.upgradeImmunity||0) + 1;
                this.save(); this.updateShopUI();
            }
        } else this.notify("–ù—É–∂–Ω–æ –±–æ–ª—å—à–µ –º–æ–Ω–µ—Ç!");
    }

    pauseGame() {
        if(!game.active || game.gameOverSequence) return;
        game.paused = true;
        document.getElementById('pauseMenu').style.display = 'flex';
    }
    resumeGame() {
        game.paused = false;
        document.getElementById('pauseMenu').style.display = 'none';
        game.lastTime = performance.now();
        game.loop(performance.now());
    }

    updateHUD(player, entities, bossTime, activeBoss, zoneTimer) {
        document.getElementById('scoreVal').innerText = Math.floor(player.score);
        const tDisp = document.getElementById('bossTimerDisplay'), waveDisp = document.getElementById('bossWaveDisplay'), bLabel = document.getElementById('bossLabel');

        if (zoneTimer > 0) {
            bLabel.innerText = "–ó–û–ù–ê –ß–ï–†–ï–ó";
            tDisp.innerText = Math.ceil(zoneTimer).toString();
            tDisp.style.color = "cyan";
            waveDisp.style.display = 'none';
        } else if(activeBoss) { 
            bLabel.innerText = "–ë–û–°–° –°–¢–ê–î–ò–Ø " + game.bossStage; tDisp.innerText = "–ë–ò–¢–í–ê!"; tDisp.style.color = activeBoss.atmosphereColor || "red"; 
            if (activeBoss.waveCD > 0 && activeBoss.waveCD < 100) { waveDisp.innerText = "–ê–¢–ê–ö–ê: " + Math.ceil(activeBoss.waveCD); waveDisp.style.display = 'block'; } else waveDisp.style.display = 'none';
        } else { 
            bLabel.innerText = "–ë–û–°–° –ß–ï–†–ï–ó"; const m = Math.floor(bossTime/60), s = Math.floor(bossTime%60); 
            tDisp.innerText = (bossTime>9999)?"--:--":`${m}:${s.toString().padStart(2,'0')}`; tDisp.style.color = "white"; waveDisp.style.display = 'none';
        }

        const sorted = [...entities].sort((a,b)=>b.score-a.score);
        sorted.forEach((e, i) => { e.rank = i + 1; });

        let h = ''; sorted.slice(0,10).forEach((e,i)=> {
            let color = '#fff';
            if (e === player) color = '#0f0';
            else if (e.isBoss) color = (game.bossStage>=4)?'#d0f':'#f00';
            else if (i < 5) color = Top5Colors[i]; 
            
            h += `<div class="lb-row" style="color:${color}">${i+1}. ${e.name} : ${Math.floor(e.score)}</div>`
        });
        document.getElementById('lb-content').innerHTML = h;

        const setCD = (id, val) => { const el = document.getElementById(id); if(val>0){ el.innerText=Math.ceil(val); el.parentElement.classList.add('cd'); } else { el.innerText=''; el.parentElement.classList.remove('cd'); } };
        setCD('cdWave', player.waveCD);

        if(player.lightStripActive) {
            document.getElementById('lightStripText').style.display = 'block';
            document.getElementById('lightStripTimerVal').innerText = player.lightStripTimer.toFixed(1);
        } else {
            document.getElementById('lightStripText').style.display = 'none';
        }

        if(player.blueStripActive) {
            document.getElementById('blueStripText').style.display = 'block';
            document.getElementById('blueStripTimerVal').innerText = player.blueStripTimer.toFixed(1);
            document.getElementById('lightStripText').style.display = 'none';
        } else {
            document.getElementById('blueStripText').style.display = 'none';
        }

        const bStripBtn = document.getElementById('btnBlueStrip');
        if (player.blueStripActive) bStripBtn.classList.add('blue-active-mode'); 
        else bStripBtn.classList.remove('blue-active-mode');

        if (player.blueStripCD > 0) {
            bStripBtn.classList.add('cd'); bStripBtn.innerText = Math.ceil(player.blueStripCD);
        } else {
            bStripBtn.classList.remove('cd'); bStripBtn.innerText = "üíé";
        }

    }
    toggleLb() {
        document.getElementById('lbWrapper').classList.toggle('lb-collapsed');
    }
    toggleMobileAbilities() {
        const grp = document.getElementById('abilityGroup');
        grp.classList.toggle('hidden-mobile');
    }
    updateAmmo(curr, max, reloadTimer, reloadTime) {
        for(let i=1; i<=7; i++) {
            const dot = document.getElementById('ammo'+i);
            if(i <= max) {
                dot.style.display = 'block';
                if(i <= curr) dot.classList.add('active'); else dot.classList.remove('active');
            } else {
                dot.style.display = 'none';
            }
        }
        const timerText = document.getElementById('reloadTimerDisplay');
        if (curr < max) {
            timerText.style.display = 'block';
            let timeLeft = (reloadTime - reloadTimer).toFixed(1);
            timerText.innerText = timeLeft + "s";
        } else {
            timerText.style.display = 'none';
        }
    }
    updateFPS(val) {
        const el = document.getElementById('fpsCounter'); el.innerText = val + " FPS";
        let color = '#00FF00'; if (val < 20) color = interpolateColor('#8B0000', '#FF0000', val / 20); else if (val < 40) color = interpolateColor('#FF0000', '#FFFF00', (val - 20) / 20); else if (val < 60) color = interpolateColor('#FFFF00', '#00FF00', (val - 40) / 20); else if (val < 165) color = interpolateColor('#00FF00', '#008000', (val - 60) / 105); else color = interpolateColor('#008000', '#00FFFF', Math.min(1, (val - 165) / 15));
        el.style.color = color; el.style.borderColor = color;
    }

    addItem(type) {
        if(this.invCounts[type] < 99) {
            this.invCounts[type]++;
            this.updateInventoryDisplay();
            this.notify("–ü–û–î–û–ë–†–ê–ù–û: " + ITEMS_TYPES[type].name);
        }
    }
    manualUse(type) {
        if(game.player && this.invCounts[type] > 0) {
            if (game.player.activeEffects && game.player.activeEffects[type] > 0) return;
            this.invCounts[type]--;
            game.player.useItem(type);
            this.updateInventoryDisplay();
        }
    }
    updateInventoryDisplay() {
        ['speed', 'magnet', 'grow', 'bonus'].forEach(t => {
            const el = document.getElementById('cnt_'+t);
            const box = document.getElementById('slot_'+t);
            if(this.invCounts[t] > 0 || (game.player && game.player.activeEffects[t] > 0)) {
                box.style.display = 'flex';
                el.style.display = 'block'; el.innerText = this.invCounts[t];
                box.style.opacity = '1';
                if (game.player && game.player.activeEffects[t] > 0) {
                    box.classList.add('active');
                    if(this.invCounts[t] === 0) el.style.display = 'none';
                } else {
                    box.classList.remove('active');
                }
            } else {
                box.style.display = 'none';
                box.classList.remove('active');
            }
        });

        if(game.isMobile) {
            const mCount = document.getElementById('mobSlotCount');
            const total = this.invCounts.speed + this.invCounts.magnet + this.invCounts.grow + this.invCounts.bonus;
            mCount.innerText = total; mCount.style.display = total>0 ? 'flex':'none';
        }

    }

    toggleInventory() {
        const inv = document.getElementById('pc-inventory');
        if(inv.style.display === 'flex') inv.style.display = 'none';
        else inv.style.display = 'flex';
        this.updateInventoryDisplay();
    }

    updateTimer(effects) {
        ['speed', 'magnet', 'grow', 'bonus'].forEach(t => {
            const bar = document.getElementById('time_'+t);
            const box = document.getElementById('slot_'+t);
            if(effects[t] > 0) {
                const conf = ITEMS_TYPES[t];
                const totalDur = conf.duration + (this.data.upgrades[t]||0);
                const pct = (effects[t] / totalDur) * 100;
                bar.style.height = pct + '%';
                box.classList.add('active');
            } else {
                bar.style.height = '0%';
                if(this.invCounts[t] > 0) box.classList.remove('active');
            }
        });
    }
    updateSpinCooldown(curr, max) { const ov = document.getElementById('spinCooldown'); if(curr>0) { ov.style.display='flex'; ov.innerText=Math.ceil(curr); } else ov.style.display='none'; }
    showSpinOverlay() { const o = document.getElementById('spin-overlay'), c = document.getElementById('spinCards'); c.innerHTML=''; o.style.display='flex'; ['speed','magnet','grow','bonus'].forEach(t => { const d = document.createElement('div'); d.className='spin-card'; d.innerHTML=`<div style="font-size:30px">${ITEMS_TYPES[t].icon}</div><div>${ITEMS_TYPES[t].name}</div><div style="font-size:10px; color:#aaa; margin-top:5px;">–ù–∞–∂–º–∏ —á—Ç–æ–±—ã –≤–∑—è—Ç—å</div>`; d.onclick=()=>{game.applySpinResult(t); ui.closeSpin();}; c.appendChild(d); }); }
    closeSpin() { document.getElementById('spin-overlay').style.display='none'; }

    exitGame() {
        this.showMainMenu();
        game.active = false;
        game.paused = false;
        document.getElementById('ui-layer').style.display='none';
        document.getElementById('pauseMenu').style.display='none';
        game.menuLoop();
    }

    checkFreeCoins() {
        const btn = document.getElementById('btnFreeCoins');
        const now = Date.now();
        if (now - (this.data.lastClaim || 0) > 300000) {
            btn.classList.remove('disabled');
            btn.innerText = "–ë–ï–°–ü–õ–ê–¢–ù–´–ï –ú–û–ù–ï–¢–´ (250-1500)";
        } else {
            btn.classList.add('disabled');
            const minLeft = Math.ceil((300000 - (now - this.data.lastClaim)) / 60000);
            btn.innerText = `–ñ–¥–∏ ${minLeft} –º–∏–Ω`;
        }
    }

    claimFreeCoins() {
        const now = Date.now();
        if (now - (this.data.lastClaim || 0) > 300000) {
            const reward = 250 + Math.floor(Math.random() * 1251);
            this.addCoins(reward);
            this.data.lastClaim = now;
            this.save();
            this.notify(`+${reward} –ú–æ–Ω–µ—Ç!`);
            this.checkFreeCoins();
        }
    }

    toggleHudEditor(show) {
        document.getElementById('hudEditorScreen').style.display = show ? 'block' : 'none';
        if(show) {
            this.initEditor('editMoveJoy', this.data.joyMove);
            this.initEditor('editAimJoy', this.data.joyAim);
        }
    }
    initEditor(id, data) {
        const el = document.getElementById(id);
        el.style.width = data.s + 'px'; el.style.height = data.s + 'px';
        el.style.left = 'auto'; el.style.bottom = 'auto';
        if (id === 'editMoveJoy') { el.style.left = data.x + 'px'; el.style.bottom = data.y + 'px'; }
        else { el.style.right = data.x + 'px'; el.style.bottom = data.y + 'px'; }

        let isDrag = false;
        const onDown = (e) => { isDrag = true; document.getElementById('editorSizeSlider').value = data.s; document.getElementById('editorSizeSlider').oninput = (ev) => { data.s = ev.target.value; el.style.width = data.s + 'px'; el.style.height = data.s + 'px'; }; };
        const onMove = (e) => {
            if(!isDrag) return;
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            if(id === 'editMoveJoy') { data.x = cx - data.s/2; data.y = window.innerHeight - cy - data.s/2; el.style.left = data.x+'px'; el.style.bottom = data.y+'px'; }
            else { data.x = window.innerWidth - cx - data.s/2; data.y = window.innerHeight - cy - data.s/2; el.style.right = data.x+'px'; el.style.bottom = data.y+'px'; }
        };
        const onUp = () => isDrag = false;

        el.onmousedown = onDown; window.onmousemove = onMove; window.onmouseup = onUp;
        el.ontouchstart = onDown; window.ontouchmove = onMove; window.ontouchend = onUp;

    }
    saveHudLayout() {
        this.save(); this.loadHudSettings(); this.toggleHudEditor(false);
    }
    loadHudSettings() {
        document.documentElement.style.setProperty('--joy-size', this.data.joyMove.s + 'px');
        document.documentElement.style.setProperty('--joy-x', this.data.joyMove.x + 'px');
        document.documentElement.style.setProperty('--joy-y', this.data.joyMove.y + 'px');
        document.documentElement.style.setProperty('--aim-size', this.data.joyAim.s + 'px');
        document.documentElement.style.setProperty('--aim-x', this.data.joyAim.x + 'px');
        document.documentElement.style.setProperty('--aim-y', this.data.joyAim.y + 'px');
    }

    showModifier() {
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('modifierScreen').style.display = 'flex';
    }
    modUpdate(key, val) {
        if(key==='botScore') document.getElementById('valBotScore').innerText = parseFloat(val).toFixed(2);
        if(key==='bossScore') document.getElementById('valBossScore').innerText = parseFloat(val).toFixed(2);
        if(key==='playerScore') document.getElementById('valPlayerScore').innerText = parseFloat(val).toFixed(2);
        if(key==='playerDmg') document.getElementById('valPlayerDmg').innerText = parseFloat(val).toFixed(2);
        if(key==='weaponDmg') document.getElementById('valWeaponDmg').innerText = parseFloat(val).toFixed(2);
        if(key==='passiveScorePlayer') document.getElementById('valPassiveScorePlayer').innerText = val;
        if(key==='passiveScoreBot') document.getElementById('valPassiveScoreBot').innerText = val;
        if(key==='vacuumMult') document.getElementById('valVacuum').innerText = parseFloat(val).toFixed(2);
        
        if(key==='botCount') document.getElementById('valBotCount').innerText = val;
        if(key==='customMapSize') document.getElementById('valMapSize').innerText = val;
        if(key==='immunity') document.getElementById('valImmunity').innerText = val + "%";

        if (key === 'botScore' || key === 'bossScore' || key === 'playerScore' || key === 'playerDmg' || key === 'weaponDmg' || key === 'vacuumMult') game.mod[key] = parseFloat(val);
        else game.mod[key] = parseInt(val);

        if (key === 'customMapSize') {
             game.mod.mapSize = false;
             game.mod.customMapSize = parseInt(val);
        }

    }
    toggleGameMode(key) {
        game.modeSettings[key] = !game.modeSettings[key];
        const el = document.getElementById(key === 'secondChance' ? 'chkSecondChance' : (key==='bossRush'?'chkBossRush':(key==='pseudoMulti'?'chkPseudoMulti':'chkDisableEvents')));
        if(game.modeSettings[key]) el.classList.add('checked'); else el.classList.remove('checked');
    }
    toggleModRuleImmunity() {
        game.mod.ruleImmunity = !game.mod.ruleImmunity;
        const el = document.getElementById('chkRuleImmunity');
        if(game.mod.ruleImmunity) {
            el.classList.add('checked');
            document.getElementById('valRuleImmunity').innerText = "On";
        } else {
            el.classList.remove('checked');
            document.getElementById('valRuleImmunity').innerText = "Off";
        }
    }

}
const game = new Game(); const ui = new UI();
</script>

</body>
</html>